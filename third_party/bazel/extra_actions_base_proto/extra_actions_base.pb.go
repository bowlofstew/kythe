// Code generated by protoc-gen-go.
// source: third_party/bazel/src/main/protobuf/extra_actions_base.proto
// DO NOT EDIT!

/*
Package extra_actions_base_proto is a generated protocol buffer package.

It is generated from these files:
	third_party/bazel/src/main/protobuf/extra_actions_base.proto

It has these top-level messages:
	ExtraActionSummary
	DetailedExtraActionInfo
	ExtraActionInfo
	EnvironmentVariable
	SpawnInfo
	CppCompileInfo
	CppLinkInfo
	JavaCompileInfo
	PythonInfo
*/
package extra_actions_base_proto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// A list of extra actions and metadata for the print_action command.
type ExtraActionSummary struct {
	Action           []*DetailedExtraActionInfo `protobuf:"bytes,1,rep,name=action" json:"action,omitempty"`
	XXX_unrecognized []byte                     `json:"-"`
}

func (m *ExtraActionSummary) Reset()         { *m = ExtraActionSummary{} }
func (m *ExtraActionSummary) String() string { return proto.CompactTextString(m) }
func (*ExtraActionSummary) ProtoMessage()    {}

func (m *ExtraActionSummary) GetAction() []*DetailedExtraActionInfo {
	if m != nil {
		return m.Action
	}
	return nil
}

// An individual action printed by the print_action command.
type DetailedExtraActionInfo struct {
	// If the given action was included in the output due to a request for a
	// specific file, then this field contains the name of that file so that the
	// caller can correctly associate the extra action with that file.
	//
	// The data in this message is currently not sufficient to run the action on a
	// production machine, because not all necessary input files are identified,
	// especially for C++.
	//
	// There is no easy way to fix this; we could require that all header files
	// are declared and then add all of them here (which would be a huge superset
	// of the files that are actually required), or we could run the include
	// scanner and add those files here.
	TriggeringFile *string `protobuf:"bytes,1,opt,name=triggering_file" json:"triggering_file,omitempty"`
	// The actual action.
	Action           *ExtraActionInfo `protobuf:"bytes,2,req,name=action" json:"action,omitempty"`
	XXX_unrecognized []byte           `json:"-"`
}

func (m *DetailedExtraActionInfo) Reset()         { *m = DetailedExtraActionInfo{} }
func (m *DetailedExtraActionInfo) String() string { return proto.CompactTextString(m) }
func (*DetailedExtraActionInfo) ProtoMessage()    {}

func (m *DetailedExtraActionInfo) GetTriggeringFile() string {
	if m != nil && m.TriggeringFile != nil {
		return *m.TriggeringFile
	}
	return ""
}

func (m *DetailedExtraActionInfo) GetAction() *ExtraActionInfo {
	if m != nil {
		return m.Action
	}
	return nil
}

// Provides information to an extra_action on the original action it is
// shadowing.
type ExtraActionInfo struct {
	// The label of the ActionOwner of the shadowed action.
	Owner *string `protobuf:"bytes,1,opt,name=owner" json:"owner,omitempty"`
	// An id uniquely describing the shadowed action at the ActionOwner level.
	Id *string `protobuf:"bytes,2,opt,name=id" json:"id,omitempty"`
	// The mnemonic of the shadowed action. Used to distinguish actions with the
	// same ActionType.
	Mnemonic         *string                   `protobuf:"bytes,5,opt,name=mnemonic" json:"mnemonic,omitempty"`
	XXX_extensions   map[int32]proto.Extension `json:"-"`
	XXX_unrecognized []byte                    `json:"-"`
}

func (m *ExtraActionInfo) Reset()         { *m = ExtraActionInfo{} }
func (m *ExtraActionInfo) String() string { return proto.CompactTextString(m) }
func (*ExtraActionInfo) ProtoMessage()    {}

var extRange_ExtraActionInfo = []proto.ExtensionRange{
	{1000, 536870911},
}

func (*ExtraActionInfo) ExtensionRangeArray() []proto.ExtensionRange {
	return extRange_ExtraActionInfo
}
func (m *ExtraActionInfo) ExtensionMap() map[int32]proto.Extension {
	if m.XXX_extensions == nil {
		m.XXX_extensions = make(map[int32]proto.Extension)
	}
	return m.XXX_extensions
}

func (m *ExtraActionInfo) GetOwner() string {
	if m != nil && m.Owner != nil {
		return *m.Owner
	}
	return ""
}

func (m *ExtraActionInfo) GetId() string {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return ""
}

func (m *ExtraActionInfo) GetMnemonic() string {
	if m != nil && m.Mnemonic != nil {
		return *m.Mnemonic
	}
	return ""
}

type EnvironmentVariable struct {
	Name             *string `protobuf:"bytes,1,req,name=name" json:"name,omitempty"`
	Value            *string `protobuf:"bytes,2,req,name=value" json:"value,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *EnvironmentVariable) Reset()         { *m = EnvironmentVariable{} }
func (m *EnvironmentVariable) String() string { return proto.CompactTextString(m) }
func (*EnvironmentVariable) ProtoMessage()    {}

func (m *EnvironmentVariable) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *EnvironmentVariable) GetValue() string {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return ""
}

// provides access to data that is specific to spawn actions.
// Usually provided by actions using the "Spawn" & "Genrule" Mnemonics.
type SpawnInfo struct {
	Argument         []string               `protobuf:"bytes,1,rep,name=argument" json:"argument,omitempty"`
	Variable         []*EnvironmentVariable `protobuf:"bytes,2,rep,name=variable" json:"variable,omitempty"`
	InputFile        []string               `protobuf:"bytes,4,rep,name=input_file" json:"input_file,omitempty"`
	OutputFile       []string               `protobuf:"bytes,5,rep,name=output_file" json:"output_file,omitempty"`
	XXX_unrecognized []byte                 `json:"-"`
}

func (m *SpawnInfo) Reset()         { *m = SpawnInfo{} }
func (m *SpawnInfo) String() string { return proto.CompactTextString(m) }
func (*SpawnInfo) ProtoMessage()    {}

func (m *SpawnInfo) GetArgument() []string {
	if m != nil {
		return m.Argument
	}
	return nil
}

func (m *SpawnInfo) GetVariable() []*EnvironmentVariable {
	if m != nil {
		return m.Variable
	}
	return nil
}

func (m *SpawnInfo) GetInputFile() []string {
	if m != nil {
		return m.InputFile
	}
	return nil
}

func (m *SpawnInfo) GetOutputFile() []string {
	if m != nil {
		return m.OutputFile
	}
	return nil
}

var E_SpawnInfo_SpawnInfo = &proto.ExtensionDesc{
	ExtendedType:  (*ExtraActionInfo)(nil),
	ExtensionType: (*SpawnInfo)(nil),
	Field:         1003,
	Name:          "blaze.SpawnInfo.spawn_info",
	Tag:           "bytes,1003,opt,name=spawn_info",
}

// Provides access to data that is specific to C++ compile actions.
// Usually provided by actions using the "CppCompile" Mnemonic.
type CppCompileInfo struct {
	Tool           *string  `protobuf:"bytes,1,opt,name=tool" json:"tool,omitempty"`
	CompilerOption []string `protobuf:"bytes,2,rep,name=compiler_option" json:"compiler_option,omitempty"`
	SourceFile     *string  `protobuf:"bytes,3,opt,name=source_file" json:"source_file,omitempty"`
	OutputFile     *string  `protobuf:"bytes,4,opt,name=output_file" json:"output_file,omitempty"`
	// Due to header discovery, this won't include headers unless the build is
	// actually performed. If set, this field will include the value of
	// "source_file" in addition to the headers.
	SourcesAndHeaders []string `protobuf:"bytes,5,rep,name=sources_and_headers" json:"sources_and_headers,omitempty"`
	XXX_unrecognized  []byte   `json:"-"`
}

func (m *CppCompileInfo) Reset()         { *m = CppCompileInfo{} }
func (m *CppCompileInfo) String() string { return proto.CompactTextString(m) }
func (*CppCompileInfo) ProtoMessage()    {}

func (m *CppCompileInfo) GetTool() string {
	if m != nil && m.Tool != nil {
		return *m.Tool
	}
	return ""
}

func (m *CppCompileInfo) GetCompilerOption() []string {
	if m != nil {
		return m.CompilerOption
	}
	return nil
}

func (m *CppCompileInfo) GetSourceFile() string {
	if m != nil && m.SourceFile != nil {
		return *m.SourceFile
	}
	return ""
}

func (m *CppCompileInfo) GetOutputFile() string {
	if m != nil && m.OutputFile != nil {
		return *m.OutputFile
	}
	return ""
}

func (m *CppCompileInfo) GetSourcesAndHeaders() []string {
	if m != nil {
		return m.SourcesAndHeaders
	}
	return nil
}

var E_CppCompileInfo_CppCompileInfo = &proto.ExtensionDesc{
	ExtendedType:  (*ExtraActionInfo)(nil),
	ExtensionType: (*CppCompileInfo)(nil),
	Field:         1001,
	Name:          "blaze.CppCompileInfo.cpp_compile_info",
	Tag:           "bytes,1001,opt,name=cpp_compile_info",
}

// Provides access to data that is specific to C++ link  actions.
// Usually provided by actions using the "CppLink" Mnemonic.
type CppLinkInfo struct {
	InputFile               []string `protobuf:"bytes,1,rep,name=input_file" json:"input_file,omitempty"`
	OutputFile              *string  `protobuf:"bytes,2,opt,name=output_file" json:"output_file,omitempty"`
	InterfaceOutputFile     *string  `protobuf:"bytes,3,opt,name=interface_output_file" json:"interface_output_file,omitempty"`
	LinkTargetType          *string  `protobuf:"bytes,4,opt,name=link_target_type" json:"link_target_type,omitempty"`
	LinkStaticness          *string  `protobuf:"bytes,5,opt,name=link_staticness" json:"link_staticness,omitempty"`
	LinkStamp               []string `protobuf:"bytes,6,rep,name=link_stamp" json:"link_stamp,omitempty"`
	BuildInfoHeaderArtifact []string `protobuf:"bytes,7,rep,name=build_info_header_artifact" json:"build_info_header_artifact,omitempty"`
	LinkOpt                 []string `protobuf:"bytes,8,rep,name=link_opt" json:"link_opt,omitempty"`
	XXX_unrecognized        []byte   `json:"-"`
}

func (m *CppLinkInfo) Reset()         { *m = CppLinkInfo{} }
func (m *CppLinkInfo) String() string { return proto.CompactTextString(m) }
func (*CppLinkInfo) ProtoMessage()    {}

func (m *CppLinkInfo) GetInputFile() []string {
	if m != nil {
		return m.InputFile
	}
	return nil
}

func (m *CppLinkInfo) GetOutputFile() string {
	if m != nil && m.OutputFile != nil {
		return *m.OutputFile
	}
	return ""
}

func (m *CppLinkInfo) GetInterfaceOutputFile() string {
	if m != nil && m.InterfaceOutputFile != nil {
		return *m.InterfaceOutputFile
	}
	return ""
}

func (m *CppLinkInfo) GetLinkTargetType() string {
	if m != nil && m.LinkTargetType != nil {
		return *m.LinkTargetType
	}
	return ""
}

func (m *CppLinkInfo) GetLinkStaticness() string {
	if m != nil && m.LinkStaticness != nil {
		return *m.LinkStaticness
	}
	return ""
}

func (m *CppLinkInfo) GetLinkStamp() []string {
	if m != nil {
		return m.LinkStamp
	}
	return nil
}

func (m *CppLinkInfo) GetBuildInfoHeaderArtifact() []string {
	if m != nil {
		return m.BuildInfoHeaderArtifact
	}
	return nil
}

func (m *CppLinkInfo) GetLinkOpt() []string {
	if m != nil {
		return m.LinkOpt
	}
	return nil
}

var E_CppLinkInfo_CppLinkInfo = &proto.ExtensionDesc{
	ExtendedType:  (*ExtraActionInfo)(nil),
	ExtensionType: (*CppLinkInfo)(nil),
	Field:         1002,
	Name:          "blaze.CppLinkInfo.cpp_link_info",
	Tag:           "bytes,1002,opt,name=cpp_link_info",
}

// Provides access to data that is specific to java compile actions.
// Usually provided by actions using the "Javac" Mnemonic.
type JavaCompileInfo struct {
	Outputjar        *string  `protobuf:"bytes,1,opt,name=outputjar" json:"outputjar,omitempty"`
	Classpath        []string `protobuf:"bytes,2,rep,name=classpath" json:"classpath,omitempty"`
	Sourcepath       []string `protobuf:"bytes,3,rep,name=sourcepath" json:"sourcepath,omitempty"`
	SourceFile       []string `protobuf:"bytes,4,rep,name=source_file" json:"source_file,omitempty"`
	JavacOpt         []string `protobuf:"bytes,5,rep,name=javac_opt" json:"javac_opt,omitempty"`
	Processor        []string `protobuf:"bytes,6,rep,name=processor" json:"processor,omitempty"`
	Processorpath    []string `protobuf:"bytes,7,rep,name=processorpath" json:"processorpath,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *JavaCompileInfo) Reset()         { *m = JavaCompileInfo{} }
func (m *JavaCompileInfo) String() string { return proto.CompactTextString(m) }
func (*JavaCompileInfo) ProtoMessage()    {}

func (m *JavaCompileInfo) GetOutputjar() string {
	if m != nil && m.Outputjar != nil {
		return *m.Outputjar
	}
	return ""
}

func (m *JavaCompileInfo) GetClasspath() []string {
	if m != nil {
		return m.Classpath
	}
	return nil
}

func (m *JavaCompileInfo) GetSourcepath() []string {
	if m != nil {
		return m.Sourcepath
	}
	return nil
}

func (m *JavaCompileInfo) GetSourceFile() []string {
	if m != nil {
		return m.SourceFile
	}
	return nil
}

func (m *JavaCompileInfo) GetJavacOpt() []string {
	if m != nil {
		return m.JavacOpt
	}
	return nil
}

func (m *JavaCompileInfo) GetProcessor() []string {
	if m != nil {
		return m.Processor
	}
	return nil
}

func (m *JavaCompileInfo) GetProcessorpath() []string {
	if m != nil {
		return m.Processorpath
	}
	return nil
}

var E_JavaCompileInfo_JavaCompileInfo = &proto.ExtensionDesc{
	ExtendedType:  (*ExtraActionInfo)(nil),
	ExtensionType: (*JavaCompileInfo)(nil),
	Field:         1000,
	Name:          "blaze.JavaCompileInfo.java_compile_info",
	Tag:           "bytes,1000,opt,name=java_compile_info",
}

// Provides access to data that is specific to python rules.
// Usually provided by actions using the "Python" Mnemonic.
type PythonInfo struct {
	SourceFile       []string `protobuf:"bytes,1,rep,name=source_file" json:"source_file,omitempty"`
	DepFile          []string `protobuf:"bytes,2,rep,name=dep_file" json:"dep_file,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *PythonInfo) Reset()         { *m = PythonInfo{} }
func (m *PythonInfo) String() string { return proto.CompactTextString(m) }
func (*PythonInfo) ProtoMessage()    {}

func (m *PythonInfo) GetSourceFile() []string {
	if m != nil {
		return m.SourceFile
	}
	return nil
}

func (m *PythonInfo) GetDepFile() []string {
	if m != nil {
		return m.DepFile
	}
	return nil
}

var E_PythonInfo_PythonInfo = &proto.ExtensionDesc{
	ExtendedType:  (*ExtraActionInfo)(nil),
	ExtensionType: (*PythonInfo)(nil),
	Field:         1005,
	Name:          "blaze.PythonInfo.python_info",
	Tag:           "bytes,1005,opt,name=python_info",
}

func init() {
	proto.RegisterExtension(E_SpawnInfo_SpawnInfo)
	proto.RegisterExtension(E_CppCompileInfo_CppCompileInfo)
	proto.RegisterExtension(E_CppLinkInfo_CppLinkInfo)
	proto.RegisterExtension(E_JavaCompileInfo_JavaCompileInfo)
	proto.RegisterExtension(E_PythonInfo_PythonInfo)
}
