// Code generated by protoc-gen-gogo.
// source: kythe/proto/serving.proto
// DO NOT EDIT!

/*
	Package serving_proto is a generated protocol buffer package.

	It is generated from these files:
		kythe/proto/serving.proto

	It has these top-level messages:
		Node
		Edge
		EdgeGroup
		PagedEdgeSet
		PageIndex
		EdgePage
		FileDirectory
		CorpusRoots
		File
		RawAnchor
		ExpandedAnchor
		FileDecorations
		PagedCrossReferences
*/
package serving_proto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import kythe_proto_common "kythe.io/kythe/proto/common_proto"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
const _ = proto.ProtoPackageIsVersion1

// A derivative of xref.NodeInfo for serving.
type Node struct {
	Ticket string                     `protobuf:"bytes,1,opt,name=ticket,proto3" json:"ticket,omitempty"`
	Fact   []*kythe_proto_common.Fact `protobuf:"bytes,2,rep,name=fact" json:"fact,omitempty"`
}

func (m *Node) Reset()                    { *m = Node{} }
func (m *Node) String() string            { return proto.CompactTextString(m) }
func (*Node) ProtoMessage()               {}
func (*Node) Descriptor() ([]byte, []int) { return fileDescriptorServing, []int{0} }

func (m *Node) GetFact() []*kythe_proto_common.Fact {
	if m != nil {
		return m.Fact
	}
	return nil
}

// Full representation of a Kythe edge; useful during post-processing.
type Edge struct {
	Source  *Node                      `protobuf:"bytes,1,opt,name=source" json:"source,omitempty"`
	Kind    string                     `protobuf:"bytes,2,opt,name=kind,proto3" json:"kind,omitempty"`
	Ordinal int32                      `protobuf:"varint,5,opt,name=ordinal,proto3" json:"ordinal,omitempty"`
	Target  *Node                      `protobuf:"bytes,3,opt,name=target" json:"target,omitempty"`
	Fact    []*kythe_proto_common.Fact `protobuf:"bytes,4,rep,name=fact" json:"fact,omitempty"`
}

func (m *Edge) Reset()                    { *m = Edge{} }
func (m *Edge) String() string            { return proto.CompactTextString(m) }
func (*Edge) ProtoMessage()               {}
func (*Edge) Descriptor() ([]byte, []int) { return fileDescriptorServing, []int{1} }

func (m *Edge) GetSource() *Node {
	if m != nil {
		return m.Source
	}
	return nil
}

func (m *Edge) GetTarget() *Node {
	if m != nil {
		return m.Target
	}
	return nil
}

func (m *Edge) GetFact() []*kythe_proto_common.Fact {
	if m != nil {
		return m.Fact
	}
	return nil
}

// An EdgeGroup represents a set of edges with the same kind and source.
//
// Note: this is a derivative of xref.EdgeSet_Group
type EdgeGroup struct {
	Kind string            `protobuf:"bytes,1,opt,name=kind,proto3" json:"kind,omitempty"`
	Edge []*EdgeGroup_Edge `protobuf:"bytes,2,rep,name=edge" json:"edge,omitempty"`
}

func (m *EdgeGroup) Reset()                    { *m = EdgeGroup{} }
func (m *EdgeGroup) String() string            { return proto.CompactTextString(m) }
func (*EdgeGroup) ProtoMessage()               {}
func (*EdgeGroup) Descriptor() ([]byte, []int) { return fileDescriptorServing, []int{2} }

func (m *EdgeGroup) GetEdge() []*EdgeGroup_Edge {
	if m != nil {
		return m.Edge
	}
	return nil
}

type EdgeGroup_Edge struct {
	Target  *Node `protobuf:"bytes,1,opt,name=target" json:"target,omitempty"`
	Ordinal int32 `protobuf:"varint,2,opt,name=ordinal,proto3" json:"ordinal,omitempty"`
}

func (m *EdgeGroup_Edge) Reset()                    { *m = EdgeGroup_Edge{} }
func (m *EdgeGroup_Edge) String() string            { return proto.CompactTextString(m) }
func (*EdgeGroup_Edge) ProtoMessage()               {}
func (*EdgeGroup_Edge) Descriptor() ([]byte, []int) { return fileDescriptorServing, []int{2, 0} }

func (m *EdgeGroup_Edge) GetTarget() *Node {
	if m != nil {
		return m.Target
	}
	return nil
}

// PagedEdgeSets are used for efficiently storing EdgeSets, all originating from
// the same source ticket, in order to handle pagination requests.
type PagedEdgeSet struct {
	// The source node for all the edges in the edge set.
	Source *Node `protobuf:"bytes,1,opt,name=source" json:"source,omitempty"`
	// Each group is a collection of outbound edges from source node sharing a
	// given kind.
	Group []*EdgeGroup `protobuf:"bytes,2,rep,name=group" json:"group,omitempty"`
	// Total number of edges in all of the EdgePages, including this one.
	TotalEdges int32 `protobuf:"varint,3,opt,name=total_edges,proto3" json:"total_edges,omitempty"`
	// Page indices for other EdgePages, sorted by edge kind.
	PageIndex []*PageIndex `protobuf:"bytes,4,rep,name=page_index" json:"page_index,omitempty"`
}

func (m *PagedEdgeSet) Reset()                    { *m = PagedEdgeSet{} }
func (m *PagedEdgeSet) String() string            { return proto.CompactTextString(m) }
func (*PagedEdgeSet) ProtoMessage()               {}
func (*PagedEdgeSet) Descriptor() ([]byte, []int) { return fileDescriptorServing, []int{3} }

func (m *PagedEdgeSet) GetSource() *Node {
	if m != nil {
		return m.Source
	}
	return nil
}

func (m *PagedEdgeSet) GetGroup() []*EdgeGroup {
	if m != nil {
		return m.Group
	}
	return nil
}

func (m *PagedEdgeSet) GetPageIndex() []*PageIndex {
	if m != nil {
		return m.PageIndex
	}
	return nil
}

// PageIndex is a pointer to an EdgePage.  In order to keep the PagedEdgeSet
// small, we don't store edges here.  We just store a key for looking up an
// EdgePage and the type of edge.
type PageIndex struct {
	// The kind of all edges on the referred EdgePage.
	EdgeKind string `protobuf:"bytes,1,opt,name=edge_kind,proto3" json:"edge_kind,omitempty"`
	// Total number of edges on the referred EdgePage.
	EdgeCount int32 `protobuf:"varint,2,opt,name=edge_count,proto3" json:"edge_count,omitempty"`
	// Key that can be used to lookup the referred EdgePage.
	PageKey string `protobuf:"bytes,3,opt,name=page_key,proto3" json:"page_key,omitempty"`
}

func (m *PageIndex) Reset()                    { *m = PageIndex{} }
func (m *PageIndex) String() string            { return proto.CompactTextString(m) }
func (*PageIndex) ProtoMessage()               {}
func (*PageIndex) Descriptor() ([]byte, []int) { return fileDescriptorServing, []int{4} }

// EdgePages are a group of edges for a particular edge kind and source ticket.
type EdgePage struct {
	// Corresponding PageIndex key that can be used to lookup this page.
	PageKey      string     `protobuf:"bytes,1,opt,name=page_key,proto3" json:"page_key,omitempty"`
	SourceTicket string     `protobuf:"bytes,2,opt,name=source_ticket,proto3" json:"source_ticket,omitempty"`
	EdgesGroup   *EdgeGroup `protobuf:"bytes,3,opt,name=edges_group" json:"edges_group,omitempty"`
}

func (m *EdgePage) Reset()                    { *m = EdgePage{} }
func (m *EdgePage) String() string            { return proto.CompactTextString(m) }
func (*EdgePage) ProtoMessage()               {}
func (*EdgePage) Descriptor() ([]byte, []int) { return fileDescriptorServing, []int{5} }

func (m *EdgePage) GetEdgesGroup() *EdgeGroup {
	if m != nil {
		return m.EdgesGroup
	}
	return nil
}

// FileDirectory describes a virtual directory of file nodes.
type FileDirectory struct {
	// Set of URIs for each contained sub-directory's corpus, root, and full path.
	Subdirectory []string `protobuf:"bytes,1,rep,name=subdirectory" json:"subdirectory,omitempty"`
	// Set of file node tickets contained within this directory.
	FileTicket []string `protobuf:"bytes,2,rep,name=file_ticket" json:"file_ticket,omitempty"`
}

func (m *FileDirectory) Reset()                    { *m = FileDirectory{} }
func (m *FileDirectory) String() string            { return proto.CompactTextString(m) }
func (*FileDirectory) ProtoMessage()               {}
func (*FileDirectory) Descriptor() ([]byte, []int) { return fileDescriptorServing, []int{6} }

// CorpusRoots describes all of the known corpus/root pairs that contain file
// nodes.
type CorpusRoots struct {
	Corpus []*CorpusRoots_Corpus `protobuf:"bytes,1,rep,name=corpus" json:"corpus,omitempty"`
}

func (m *CorpusRoots) Reset()                    { *m = CorpusRoots{} }
func (m *CorpusRoots) String() string            { return proto.CompactTextString(m) }
func (*CorpusRoots) ProtoMessage()               {}
func (*CorpusRoots) Descriptor() ([]byte, []int) { return fileDescriptorServing, []int{7} }

func (m *CorpusRoots) GetCorpus() []*CorpusRoots_Corpus {
	if m != nil {
		return m.Corpus
	}
	return nil
}

type CorpusRoots_Corpus struct {
	Corpus string   `protobuf:"bytes,1,opt,name=corpus,proto3" json:"corpus,omitempty"`
	Root   []string `protobuf:"bytes,2,rep,name=root" json:"root,omitempty"`
}

func (m *CorpusRoots_Corpus) Reset()                    { *m = CorpusRoots_Corpus{} }
func (m *CorpusRoots_Corpus) String() string            { return proto.CompactTextString(m) }
func (*CorpusRoots_Corpus) ProtoMessage()               {}
func (*CorpusRoots_Corpus) Descriptor() ([]byte, []int) { return fileDescriptorServing, []int{7, 0} }

// A File is a specialized Node structure for file nodes.
type File struct {
	Ticket   string `protobuf:"bytes,1,opt,name=ticket,proto3" json:"ticket,omitempty"`
	Text     []byte `protobuf:"bytes,2,opt,name=text,proto3" json:"text,omitempty"`
	Encoding string `protobuf:"bytes,3,opt,name=encoding,proto3" json:"encoding,omitempty"`
}

func (m *File) Reset()                    { *m = File{} }
func (m *File) String() string            { return proto.CompactTextString(m) }
func (*File) ProtoMessage()               {}
func (*File) Descriptor() ([]byte, []int) { return fileDescriptorServing, []int{8} }

// A RawAnchor is a specialized Node structure for anchor nodes.
type RawAnchor struct {
	Ticket       string `protobuf:"bytes,1,opt,name=ticket,proto3" json:"ticket,omitempty"`
	StartOffset  int32  `protobuf:"varint,2,opt,name=start_offset,proto3" json:"start_offset,omitempty"`
	EndOffset    int32  `protobuf:"varint,3,opt,name=end_offset,proto3" json:"end_offset,omitempty"`
	SnippetStart int32  `protobuf:"varint,4,opt,name=snippet_start,proto3" json:"snippet_start,omitempty"`
	SnippetEnd   int32  `protobuf:"varint,5,opt,name=snippet_end,proto3" json:"snippet_end,omitempty"`
}

func (m *RawAnchor) Reset()                    { *m = RawAnchor{} }
func (m *RawAnchor) String() string            { return proto.CompactTextString(m) }
func (*RawAnchor) ProtoMessage()               {}
func (*RawAnchor) Descriptor() ([]byte, []int) { return fileDescriptorServing, []int{9} }

// ExpandedAnchors are constructed from an RawAnchor and its associated File.
// They contain normalized Spans based on their parent file's text as well as
// the UTF8-encoded text for both the anchor's span and its snippet span.
type ExpandedAnchor struct {
	Ticket      string                   `protobuf:"bytes,1,opt,name=ticket,proto3" json:"ticket,omitempty"`
	Kind        string                   `protobuf:"bytes,2,opt,name=kind,proto3" json:"kind,omitempty"`
	Parent      string                   `protobuf:"bytes,3,opt,name=parent,proto3" json:"parent,omitempty"`
	Text        string                   `protobuf:"bytes,4,opt,name=text,proto3" json:"text,omitempty"`
	Span        *kythe_proto_common.Span `protobuf:"bytes,5,opt,name=span" json:"span,omitempty"`
	Snippet     string                   `protobuf:"bytes,6,opt,name=snippet,proto3" json:"snippet,omitempty"`
	SnippetSpan *kythe_proto_common.Span `protobuf:"bytes,7,opt,name=snippet_span" json:"snippet_span,omitempty"`
}

func (m *ExpandedAnchor) Reset()                    { *m = ExpandedAnchor{} }
func (m *ExpandedAnchor) String() string            { return proto.CompactTextString(m) }
func (*ExpandedAnchor) ProtoMessage()               {}
func (*ExpandedAnchor) Descriptor() ([]byte, []int) { return fileDescriptorServing, []int{10} }

func (m *ExpandedAnchor) GetSpan() *kythe_proto_common.Span {
	if m != nil {
		return m.Span
	}
	return nil
}

func (m *ExpandedAnchor) GetSnippetSpan() *kythe_proto_common.Span {
	if m != nil {
		return m.SnippetSpan
	}
	return nil
}

// FileDecorations stores a file's contents and all contained anchor edges.
type FileDecorations struct {
	File *File `protobuf:"bytes,1,opt,name=file" json:"file,omitempty"`
	// The decorations located in the file, sorted by starting offset.
	Decoration []*FileDecorations_Decoration `protobuf:"bytes,2,rep,name=decoration" json:"decoration,omitempty"`
}

func (m *FileDecorations) Reset()                    { *m = FileDecorations{} }
func (m *FileDecorations) String() string            { return proto.CompactTextString(m) }
func (*FileDecorations) ProtoMessage()               {}
func (*FileDecorations) Descriptor() ([]byte, []int) { return fileDescriptorServing, []int{11} }

func (m *FileDecorations) GetFile() *File {
	if m != nil {
		return m.File
	}
	return nil
}

func (m *FileDecorations) GetDecoration() []*FileDecorations_Decoration {
	if m != nil {
		return m.Decoration
	}
	return nil
}

// Represents an edge from an anchor contained within the file to some target.
type FileDecorations_Decoration struct {
	Anchor *RawAnchor `protobuf:"bytes,1,opt,name=anchor" json:"anchor,omitempty"`
	Kind   string     `protobuf:"bytes,2,opt,name=kind,proto3" json:"kind,omitempty"`
	Target *Node      `protobuf:"bytes,3,opt,name=target" json:"target,omitempty"`
}

func (m *FileDecorations_Decoration) Reset()         { *m = FileDecorations_Decoration{} }
func (m *FileDecorations_Decoration) String() string { return proto.CompactTextString(m) }
func (*FileDecorations_Decoration) ProtoMessage()    {}
func (*FileDecorations_Decoration) Descriptor() ([]byte, []int) {
	return fileDescriptorServing, []int{11, 0}
}

func (m *FileDecorations_Decoration) GetAnchor() *RawAnchor {
	if m != nil {
		return m.Anchor
	}
	return nil
}

func (m *FileDecorations_Decoration) GetTarget() *Node {
	if m != nil {
		return m.Target
	}
	return nil
}

// PagedCrossReferences are used for efficiently storing pre-cached data for
// CrossReferencesReply.{definition,reference,documentation} anchors.  Related
// nodes can be retrieved from edge sets/pages.
type PagedCrossReferences struct {
	SourceTicket    string                            `protobuf:"bytes,1,opt,name=source_ticket,proto3" json:"source_ticket,omitempty"`
	Group           []*PagedCrossReferences_Group     `protobuf:"bytes,2,rep,name=group" json:"group,omitempty"`
	PageIndex       []*PagedCrossReferences_PageIndex `protobuf:"bytes,3,rep,name=page_index" json:"page_index,omitempty"`
	TotalReferences int32                             `protobuf:"varint,4,opt,name=total_references,proto3" json:"total_references,omitempty"`
	// Whether the source node is incomplete.  This changes whether
	// /kythe/edge/defines edges are considered declarations or definitions.
	// /kythe/edge/completes edges are always grouped as definitions.
	Incomplete bool `protobuf:"varint,5,opt,name=incomplete,proto3" json:"incomplete,omitempty"`
}

func (m *PagedCrossReferences) Reset()                    { *m = PagedCrossReferences{} }
func (m *PagedCrossReferences) String() string            { return proto.CompactTextString(m) }
func (*PagedCrossReferences) ProtoMessage()               {}
func (*PagedCrossReferences) Descriptor() ([]byte, []int) { return fileDescriptorServing, []int{12} }

func (m *PagedCrossReferences) GetGroup() []*PagedCrossReferences_Group {
	if m != nil {
		return m.Group
	}
	return nil
}

func (m *PagedCrossReferences) GetPageIndex() []*PagedCrossReferences_PageIndex {
	if m != nil {
		return m.PageIndex
	}
	return nil
}

type PagedCrossReferences_Group struct {
	Kind   string            `protobuf:"bytes,1,opt,name=kind,proto3" json:"kind,omitempty"`
	Anchor []*ExpandedAnchor `protobuf:"bytes,2,rep,name=anchor" json:"anchor,omitempty"`
}

func (m *PagedCrossReferences_Group) Reset()         { *m = PagedCrossReferences_Group{} }
func (m *PagedCrossReferences_Group) String() string { return proto.CompactTextString(m) }
func (*PagedCrossReferences_Group) ProtoMessage()    {}
func (*PagedCrossReferences_Group) Descriptor() ([]byte, []int) {
	return fileDescriptorServing, []int{12, 0}
}

func (m *PagedCrossReferences_Group) GetAnchor() []*ExpandedAnchor {
	if m != nil {
		return m.Anchor
	}
	return nil
}

type PagedCrossReferences_Page struct {
	PageKey      string                      `protobuf:"bytes,1,opt,name=page_key,proto3" json:"page_key,omitempty"`
	SourceTicket string                      `protobuf:"bytes,2,opt,name=source_ticket,proto3" json:"source_ticket,omitempty"`
	Group        *PagedCrossReferences_Group `protobuf:"bytes,3,opt,name=group" json:"group,omitempty"`
}

func (m *PagedCrossReferences_Page) Reset()         { *m = PagedCrossReferences_Page{} }
func (m *PagedCrossReferences_Page) String() string { return proto.CompactTextString(m) }
func (*PagedCrossReferences_Page) ProtoMessage()    {}
func (*PagedCrossReferences_Page) Descriptor() ([]byte, []int) {
	return fileDescriptorServing, []int{12, 1}
}

func (m *PagedCrossReferences_Page) GetGroup() *PagedCrossReferences_Group {
	if m != nil {
		return m.Group
	}
	return nil
}

// A PageIndex is a reference to a Page.
type PagedCrossReferences_PageIndex struct {
	Kind    string `protobuf:"bytes,1,opt,name=kind,proto3" json:"kind,omitempty"`
	Count   int32  `protobuf:"varint,2,opt,name=count,proto3" json:"count,omitempty"`
	PageKey string `protobuf:"bytes,3,opt,name=page_key,proto3" json:"page_key,omitempty"`
}

func (m *PagedCrossReferences_PageIndex) Reset()         { *m = PagedCrossReferences_PageIndex{} }
func (m *PagedCrossReferences_PageIndex) String() string { return proto.CompactTextString(m) }
func (*PagedCrossReferences_PageIndex) ProtoMessage()    {}
func (*PagedCrossReferences_PageIndex) Descriptor() ([]byte, []int) {
	return fileDescriptorServing, []int{12, 2}
}

func init() {
	proto.RegisterType((*Node)(nil), "kythe.proto.serving.Node")
	proto.RegisterType((*Edge)(nil), "kythe.proto.serving.Edge")
	proto.RegisterType((*EdgeGroup)(nil), "kythe.proto.serving.EdgeGroup")
	proto.RegisterType((*EdgeGroup_Edge)(nil), "kythe.proto.serving.EdgeGroup.Edge")
	proto.RegisterType((*PagedEdgeSet)(nil), "kythe.proto.serving.PagedEdgeSet")
	proto.RegisterType((*PageIndex)(nil), "kythe.proto.serving.PageIndex")
	proto.RegisterType((*EdgePage)(nil), "kythe.proto.serving.EdgePage")
	proto.RegisterType((*FileDirectory)(nil), "kythe.proto.serving.FileDirectory")
	proto.RegisterType((*CorpusRoots)(nil), "kythe.proto.serving.CorpusRoots")
	proto.RegisterType((*CorpusRoots_Corpus)(nil), "kythe.proto.serving.CorpusRoots.Corpus")
	proto.RegisterType((*File)(nil), "kythe.proto.serving.File")
	proto.RegisterType((*RawAnchor)(nil), "kythe.proto.serving.RawAnchor")
	proto.RegisterType((*ExpandedAnchor)(nil), "kythe.proto.serving.ExpandedAnchor")
	proto.RegisterType((*FileDecorations)(nil), "kythe.proto.serving.FileDecorations")
	proto.RegisterType((*FileDecorations_Decoration)(nil), "kythe.proto.serving.FileDecorations.Decoration")
	proto.RegisterType((*PagedCrossReferences)(nil), "kythe.proto.serving.PagedCrossReferences")
	proto.RegisterType((*PagedCrossReferences_Group)(nil), "kythe.proto.serving.PagedCrossReferences.Group")
	proto.RegisterType((*PagedCrossReferences_Page)(nil), "kythe.proto.serving.PagedCrossReferences.Page")
	proto.RegisterType((*PagedCrossReferences_PageIndex)(nil), "kythe.proto.serving.PagedCrossReferences.PageIndex")
}
func (m *Node) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Node) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ticket) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintServing(data, i, uint64(len(m.Ticket)))
		i += copy(data[i:], m.Ticket)
	}
	if len(m.Fact) > 0 {
		for _, msg := range m.Fact {
			data[i] = 0x12
			i++
			i = encodeVarintServing(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *Edge) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Edge) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Source != nil {
		data[i] = 0xa
		i++
		i = encodeVarintServing(data, i, uint64(m.Source.Size()))
		n1, err := m.Source.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if len(m.Kind) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintServing(data, i, uint64(len(m.Kind)))
		i += copy(data[i:], m.Kind)
	}
	if m.Target != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintServing(data, i, uint64(m.Target.Size()))
		n2, err := m.Target.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if len(m.Fact) > 0 {
		for _, msg := range m.Fact {
			data[i] = 0x22
			i++
			i = encodeVarintServing(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.Ordinal != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintServing(data, i, uint64(m.Ordinal))
	}
	return i, nil
}

func (m *EdgeGroup) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *EdgeGroup) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Kind) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintServing(data, i, uint64(len(m.Kind)))
		i += copy(data[i:], m.Kind)
	}
	if len(m.Edge) > 0 {
		for _, msg := range m.Edge {
			data[i] = 0x12
			i++
			i = encodeVarintServing(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *EdgeGroup_Edge) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *EdgeGroup_Edge) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Target != nil {
		data[i] = 0xa
		i++
		i = encodeVarintServing(data, i, uint64(m.Target.Size()))
		n3, err := m.Target.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.Ordinal != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintServing(data, i, uint64(m.Ordinal))
	}
	return i, nil
}

func (m *PagedEdgeSet) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *PagedEdgeSet) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Source != nil {
		data[i] = 0xa
		i++
		i = encodeVarintServing(data, i, uint64(m.Source.Size()))
		n4, err := m.Source.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if len(m.Group) > 0 {
		for _, msg := range m.Group {
			data[i] = 0x12
			i++
			i = encodeVarintServing(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.TotalEdges != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintServing(data, i, uint64(m.TotalEdges))
	}
	if len(m.PageIndex) > 0 {
		for _, msg := range m.PageIndex {
			data[i] = 0x22
			i++
			i = encodeVarintServing(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *PageIndex) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *PageIndex) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.EdgeKind) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintServing(data, i, uint64(len(m.EdgeKind)))
		i += copy(data[i:], m.EdgeKind)
	}
	if m.EdgeCount != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintServing(data, i, uint64(m.EdgeCount))
	}
	if len(m.PageKey) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintServing(data, i, uint64(len(m.PageKey)))
		i += copy(data[i:], m.PageKey)
	}
	return i, nil
}

func (m *EdgePage) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *EdgePage) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PageKey) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintServing(data, i, uint64(len(m.PageKey)))
		i += copy(data[i:], m.PageKey)
	}
	if len(m.SourceTicket) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintServing(data, i, uint64(len(m.SourceTicket)))
		i += copy(data[i:], m.SourceTicket)
	}
	if m.EdgesGroup != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintServing(data, i, uint64(m.EdgesGroup.Size()))
		n5, err := m.EdgesGroup.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	return i, nil
}

func (m *FileDirectory) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *FileDirectory) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Subdirectory) > 0 {
		for _, s := range m.Subdirectory {
			data[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if len(m.FileTicket) > 0 {
		for _, s := range m.FileTicket {
			data[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	return i, nil
}

func (m *CorpusRoots) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CorpusRoots) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Corpus) > 0 {
		for _, msg := range m.Corpus {
			data[i] = 0xa
			i++
			i = encodeVarintServing(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CorpusRoots_Corpus) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CorpusRoots_Corpus) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Corpus) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintServing(data, i, uint64(len(m.Corpus)))
		i += copy(data[i:], m.Corpus)
	}
	if len(m.Root) > 0 {
		for _, s := range m.Root {
			data[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	return i, nil
}

func (m *File) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *File) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ticket) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintServing(data, i, uint64(len(m.Ticket)))
		i += copy(data[i:], m.Ticket)
	}
	if len(m.Text) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintServing(data, i, uint64(len(m.Text)))
		i += copy(data[i:], m.Text)
	}
	if len(m.Encoding) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintServing(data, i, uint64(len(m.Encoding)))
		i += copy(data[i:], m.Encoding)
	}
	return i, nil
}

func (m *RawAnchor) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *RawAnchor) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ticket) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintServing(data, i, uint64(len(m.Ticket)))
		i += copy(data[i:], m.Ticket)
	}
	if m.StartOffset != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintServing(data, i, uint64(m.StartOffset))
	}
	if m.EndOffset != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintServing(data, i, uint64(m.EndOffset))
	}
	if m.SnippetStart != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintServing(data, i, uint64(m.SnippetStart))
	}
	if m.SnippetEnd != 0 {
		data[i] = 0x28
		i++
		i = encodeVarintServing(data, i, uint64(m.SnippetEnd))
	}
	return i, nil
}

func (m *ExpandedAnchor) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ExpandedAnchor) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ticket) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintServing(data, i, uint64(len(m.Ticket)))
		i += copy(data[i:], m.Ticket)
	}
	if len(m.Kind) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintServing(data, i, uint64(len(m.Kind)))
		i += copy(data[i:], m.Kind)
	}
	if len(m.Parent) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintServing(data, i, uint64(len(m.Parent)))
		i += copy(data[i:], m.Parent)
	}
	if len(m.Text) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintServing(data, i, uint64(len(m.Text)))
		i += copy(data[i:], m.Text)
	}
	if m.Span != nil {
		data[i] = 0x2a
		i++
		i = encodeVarintServing(data, i, uint64(m.Span.Size()))
		n6, err := m.Span.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if len(m.Snippet) > 0 {
		data[i] = 0x32
		i++
		i = encodeVarintServing(data, i, uint64(len(m.Snippet)))
		i += copy(data[i:], m.Snippet)
	}
	if m.SnippetSpan != nil {
		data[i] = 0x3a
		i++
		i = encodeVarintServing(data, i, uint64(m.SnippetSpan.Size()))
		n7, err := m.SnippetSpan.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	return i, nil
}

func (m *FileDecorations) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *FileDecorations) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.File != nil {
		data[i] = 0xa
		i++
		i = encodeVarintServing(data, i, uint64(m.File.Size()))
		n8, err := m.File.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if len(m.Decoration) > 0 {
		for _, msg := range m.Decoration {
			data[i] = 0x12
			i++
			i = encodeVarintServing(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *FileDecorations_Decoration) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *FileDecorations_Decoration) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Anchor != nil {
		data[i] = 0xa
		i++
		i = encodeVarintServing(data, i, uint64(m.Anchor.Size()))
		n9, err := m.Anchor.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n9
	}
	if len(m.Kind) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintServing(data, i, uint64(len(m.Kind)))
		i += copy(data[i:], m.Kind)
	}
	if m.Target != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintServing(data, i, uint64(m.Target.Size()))
		n10, err := m.Target.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n10
	}
	return i, nil
}

func (m *PagedCrossReferences) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *PagedCrossReferences) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SourceTicket) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintServing(data, i, uint64(len(m.SourceTicket)))
		i += copy(data[i:], m.SourceTicket)
	}
	if len(m.Group) > 0 {
		for _, msg := range m.Group {
			data[i] = 0x12
			i++
			i = encodeVarintServing(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.PageIndex) > 0 {
		for _, msg := range m.PageIndex {
			data[i] = 0x1a
			i++
			i = encodeVarintServing(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.TotalReferences != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintServing(data, i, uint64(m.TotalReferences))
	}
	if m.Incomplete {
		data[i] = 0x28
		i++
		if m.Incomplete {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *PagedCrossReferences_Group) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *PagedCrossReferences_Group) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Kind) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintServing(data, i, uint64(len(m.Kind)))
		i += copy(data[i:], m.Kind)
	}
	if len(m.Anchor) > 0 {
		for _, msg := range m.Anchor {
			data[i] = 0x12
			i++
			i = encodeVarintServing(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *PagedCrossReferences_Page) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *PagedCrossReferences_Page) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.PageKey) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintServing(data, i, uint64(len(m.PageKey)))
		i += copy(data[i:], m.PageKey)
	}
	if len(m.SourceTicket) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintServing(data, i, uint64(len(m.SourceTicket)))
		i += copy(data[i:], m.SourceTicket)
	}
	if m.Group != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintServing(data, i, uint64(m.Group.Size()))
		n11, err := m.Group.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	return i, nil
}

func (m *PagedCrossReferences_PageIndex) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *PagedCrossReferences_PageIndex) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Kind) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintServing(data, i, uint64(len(m.Kind)))
		i += copy(data[i:], m.Kind)
	}
	if m.Count != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintServing(data, i, uint64(m.Count))
	}
	if len(m.PageKey) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintServing(data, i, uint64(len(m.PageKey)))
		i += copy(data[i:], m.PageKey)
	}
	return i, nil
}

func encodeFixed64Serving(data []byte, offset int, v uint64) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	data[offset+4] = uint8(v >> 32)
	data[offset+5] = uint8(v >> 40)
	data[offset+6] = uint8(v >> 48)
	data[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Serving(data []byte, offset int, v uint32) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintServing(data []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		data[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	data[offset] = uint8(v)
	return offset + 1
}
func (m *Node) Size() (n int) {
	var l int
	_ = l
	l = len(m.Ticket)
	if l > 0 {
		n += 1 + l + sovServing(uint64(l))
	}
	if len(m.Fact) > 0 {
		for _, e := range m.Fact {
			l = e.Size()
			n += 1 + l + sovServing(uint64(l))
		}
	}
	return n
}

func (m *Edge) Size() (n int) {
	var l int
	_ = l
	if m.Source != nil {
		l = m.Source.Size()
		n += 1 + l + sovServing(uint64(l))
	}
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovServing(uint64(l))
	}
	if m.Target != nil {
		l = m.Target.Size()
		n += 1 + l + sovServing(uint64(l))
	}
	if len(m.Fact) > 0 {
		for _, e := range m.Fact {
			l = e.Size()
			n += 1 + l + sovServing(uint64(l))
		}
	}
	if m.Ordinal != 0 {
		n += 1 + sovServing(uint64(m.Ordinal))
	}
	return n
}

func (m *EdgeGroup) Size() (n int) {
	var l int
	_ = l
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovServing(uint64(l))
	}
	if len(m.Edge) > 0 {
		for _, e := range m.Edge {
			l = e.Size()
			n += 1 + l + sovServing(uint64(l))
		}
	}
	return n
}

func (m *EdgeGroup_Edge) Size() (n int) {
	var l int
	_ = l
	if m.Target != nil {
		l = m.Target.Size()
		n += 1 + l + sovServing(uint64(l))
	}
	if m.Ordinal != 0 {
		n += 1 + sovServing(uint64(m.Ordinal))
	}
	return n
}

func (m *PagedEdgeSet) Size() (n int) {
	var l int
	_ = l
	if m.Source != nil {
		l = m.Source.Size()
		n += 1 + l + sovServing(uint64(l))
	}
	if len(m.Group) > 0 {
		for _, e := range m.Group {
			l = e.Size()
			n += 1 + l + sovServing(uint64(l))
		}
	}
	if m.TotalEdges != 0 {
		n += 1 + sovServing(uint64(m.TotalEdges))
	}
	if len(m.PageIndex) > 0 {
		for _, e := range m.PageIndex {
			l = e.Size()
			n += 1 + l + sovServing(uint64(l))
		}
	}
	return n
}

func (m *PageIndex) Size() (n int) {
	var l int
	_ = l
	l = len(m.EdgeKind)
	if l > 0 {
		n += 1 + l + sovServing(uint64(l))
	}
	if m.EdgeCount != 0 {
		n += 1 + sovServing(uint64(m.EdgeCount))
	}
	l = len(m.PageKey)
	if l > 0 {
		n += 1 + l + sovServing(uint64(l))
	}
	return n
}

func (m *EdgePage) Size() (n int) {
	var l int
	_ = l
	l = len(m.PageKey)
	if l > 0 {
		n += 1 + l + sovServing(uint64(l))
	}
	l = len(m.SourceTicket)
	if l > 0 {
		n += 1 + l + sovServing(uint64(l))
	}
	if m.EdgesGroup != nil {
		l = m.EdgesGroup.Size()
		n += 1 + l + sovServing(uint64(l))
	}
	return n
}

func (m *FileDirectory) Size() (n int) {
	var l int
	_ = l
	if len(m.Subdirectory) > 0 {
		for _, s := range m.Subdirectory {
			l = len(s)
			n += 1 + l + sovServing(uint64(l))
		}
	}
	if len(m.FileTicket) > 0 {
		for _, s := range m.FileTicket {
			l = len(s)
			n += 1 + l + sovServing(uint64(l))
		}
	}
	return n
}

func (m *CorpusRoots) Size() (n int) {
	var l int
	_ = l
	if len(m.Corpus) > 0 {
		for _, e := range m.Corpus {
			l = e.Size()
			n += 1 + l + sovServing(uint64(l))
		}
	}
	return n
}

func (m *CorpusRoots_Corpus) Size() (n int) {
	var l int
	_ = l
	l = len(m.Corpus)
	if l > 0 {
		n += 1 + l + sovServing(uint64(l))
	}
	if len(m.Root) > 0 {
		for _, s := range m.Root {
			l = len(s)
			n += 1 + l + sovServing(uint64(l))
		}
	}
	return n
}

func (m *File) Size() (n int) {
	var l int
	_ = l
	l = len(m.Ticket)
	if l > 0 {
		n += 1 + l + sovServing(uint64(l))
	}
	l = len(m.Text)
	if l > 0 {
		n += 1 + l + sovServing(uint64(l))
	}
	l = len(m.Encoding)
	if l > 0 {
		n += 1 + l + sovServing(uint64(l))
	}
	return n
}

func (m *RawAnchor) Size() (n int) {
	var l int
	_ = l
	l = len(m.Ticket)
	if l > 0 {
		n += 1 + l + sovServing(uint64(l))
	}
	if m.StartOffset != 0 {
		n += 1 + sovServing(uint64(m.StartOffset))
	}
	if m.EndOffset != 0 {
		n += 1 + sovServing(uint64(m.EndOffset))
	}
	if m.SnippetStart != 0 {
		n += 1 + sovServing(uint64(m.SnippetStart))
	}
	if m.SnippetEnd != 0 {
		n += 1 + sovServing(uint64(m.SnippetEnd))
	}
	return n
}

func (m *ExpandedAnchor) Size() (n int) {
	var l int
	_ = l
	l = len(m.Ticket)
	if l > 0 {
		n += 1 + l + sovServing(uint64(l))
	}
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovServing(uint64(l))
	}
	l = len(m.Parent)
	if l > 0 {
		n += 1 + l + sovServing(uint64(l))
	}
	l = len(m.Text)
	if l > 0 {
		n += 1 + l + sovServing(uint64(l))
	}
	if m.Span != nil {
		l = m.Span.Size()
		n += 1 + l + sovServing(uint64(l))
	}
	l = len(m.Snippet)
	if l > 0 {
		n += 1 + l + sovServing(uint64(l))
	}
	if m.SnippetSpan != nil {
		l = m.SnippetSpan.Size()
		n += 1 + l + sovServing(uint64(l))
	}
	return n
}

func (m *FileDecorations) Size() (n int) {
	var l int
	_ = l
	if m.File != nil {
		l = m.File.Size()
		n += 1 + l + sovServing(uint64(l))
	}
	if len(m.Decoration) > 0 {
		for _, e := range m.Decoration {
			l = e.Size()
			n += 1 + l + sovServing(uint64(l))
		}
	}
	return n
}

func (m *FileDecorations_Decoration) Size() (n int) {
	var l int
	_ = l
	if m.Anchor != nil {
		l = m.Anchor.Size()
		n += 1 + l + sovServing(uint64(l))
	}
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovServing(uint64(l))
	}
	if m.Target != nil {
		l = m.Target.Size()
		n += 1 + l + sovServing(uint64(l))
	}
	return n
}

func (m *PagedCrossReferences) Size() (n int) {
	var l int
	_ = l
	l = len(m.SourceTicket)
	if l > 0 {
		n += 1 + l + sovServing(uint64(l))
	}
	if len(m.Group) > 0 {
		for _, e := range m.Group {
			l = e.Size()
			n += 1 + l + sovServing(uint64(l))
		}
	}
	if len(m.PageIndex) > 0 {
		for _, e := range m.PageIndex {
			l = e.Size()
			n += 1 + l + sovServing(uint64(l))
		}
	}
	if m.TotalReferences != 0 {
		n += 1 + sovServing(uint64(m.TotalReferences))
	}
	if m.Incomplete {
		n += 2
	}
	return n
}

func (m *PagedCrossReferences_Group) Size() (n int) {
	var l int
	_ = l
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovServing(uint64(l))
	}
	if len(m.Anchor) > 0 {
		for _, e := range m.Anchor {
			l = e.Size()
			n += 1 + l + sovServing(uint64(l))
		}
	}
	return n
}

func (m *PagedCrossReferences_Page) Size() (n int) {
	var l int
	_ = l
	l = len(m.PageKey)
	if l > 0 {
		n += 1 + l + sovServing(uint64(l))
	}
	l = len(m.SourceTicket)
	if l > 0 {
		n += 1 + l + sovServing(uint64(l))
	}
	if m.Group != nil {
		l = m.Group.Size()
		n += 1 + l + sovServing(uint64(l))
	}
	return n
}

func (m *PagedCrossReferences_PageIndex) Size() (n int) {
	var l int
	_ = l
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovServing(uint64(l))
	}
	if m.Count != 0 {
		n += 1 + sovServing(uint64(m.Count))
	}
	l = len(m.PageKey)
	if l > 0 {
		n += 1 + l + sovServing(uint64(l))
	}
	return n
}

func sovServing(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozServing(x uint64) (n int) {
	return sovServing(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *Node) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServing
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Node: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Node: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ticket", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ticket = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fact", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fact = append(m.Fact, &kythe_proto_common.Fact{})
			if err := m.Fact[len(m.Fact)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServing(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServing
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Edge) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServing
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Edge: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Edge: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Source == nil {
				m.Source = &Node{}
			}
			if err := m.Source.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Target == nil {
				m.Target = &Node{}
			}
			if err := m.Target.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fact", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fact = append(m.Fact, &kythe_proto_common.Fact{})
			if err := m.Fact[len(m.Fact)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ordinal", wireType)
			}
			m.Ordinal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Ordinal |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipServing(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServing
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EdgeGroup) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServing
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EdgeGroup: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EdgeGroup: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Edge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Edge = append(m.Edge, &EdgeGroup_Edge{})
			if err := m.Edge[len(m.Edge)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServing(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServing
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EdgeGroup_Edge) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServing
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Edge: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Edge: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Target == nil {
				m.Target = &Node{}
			}
			if err := m.Target.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ordinal", wireType)
			}
			m.Ordinal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Ordinal |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipServing(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServing
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PagedEdgeSet) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServing
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PagedEdgeSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PagedEdgeSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Source == nil {
				m.Source = &Node{}
			}
			if err := m.Source.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Group = append(m.Group, &EdgeGroup{})
			if err := m.Group[len(m.Group)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalEdges", wireType)
			}
			m.TotalEdges = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.TotalEdges |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageIndex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PageIndex = append(m.PageIndex, &PageIndex{})
			if err := m.PageIndex[len(m.PageIndex)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServing(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServing
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PageIndex) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServing
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PageIndex: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PageIndex: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EdgeKind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EdgeKind = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EdgeCount", wireType)
			}
			m.EdgeCount = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.EdgeCount |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PageKey = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServing(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServing
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EdgePage) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServing
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EdgePage: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EdgePage: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PageKey = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceTicket", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceTicket = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EdgesGroup", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.EdgesGroup == nil {
				m.EdgesGroup = &EdgeGroup{}
			}
			if err := m.EdgesGroup.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServing(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServing
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileDirectory) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServing
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileDirectory: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileDirectory: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Subdirectory", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Subdirectory = append(m.Subdirectory, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileTicket", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileTicket = append(m.FileTicket, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServing(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServing
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CorpusRoots) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServing
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CorpusRoots: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CorpusRoots: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Corpus", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Corpus = append(m.Corpus, &CorpusRoots_Corpus{})
			if err := m.Corpus[len(m.Corpus)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServing(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServing
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CorpusRoots_Corpus) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServing
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Corpus: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Corpus: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Corpus", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Corpus = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Root", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Root = append(m.Root, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServing(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServing
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *File) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServing
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: File: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: File: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ticket", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ticket = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = append(m.Text[:0], data[iNdEx:postIndex]...)
			if m.Text == nil {
				m.Text = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encoding", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Encoding = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServing(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServing
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *RawAnchor) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServing
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RawAnchor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RawAnchor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ticket", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ticket = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field StartOffset", wireType)
			}
			m.StartOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.StartOffset |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field EndOffset", wireType)
			}
			m.EndOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.EndOffset |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnippetStart", wireType)
			}
			m.SnippetStart = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.SnippetStart |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnippetEnd", wireType)
			}
			m.SnippetEnd = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.SnippetEnd |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipServing(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServing
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ExpandedAnchor) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServing
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ExpandedAnchor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ExpandedAnchor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ticket", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ticket = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parent", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Parent = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Span", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Span == nil {
				m.Span = &kythe_proto_common.Span{}
			}
			if err := m.Span.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Snippet", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Snippet = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnippetSpan", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SnippetSpan == nil {
				m.SnippetSpan = &kythe_proto_common.Span{}
			}
			if err := m.SnippetSpan.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServing(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServing
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileDecorations) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServing
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileDecorations: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileDecorations: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field File", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.File == nil {
				m.File = &File{}
			}
			if err := m.File.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Decoration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Decoration = append(m.Decoration, &FileDecorations_Decoration{})
			if err := m.Decoration[len(m.Decoration)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServing(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServing
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileDecorations_Decoration) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServing
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Decoration: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Decoration: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Anchor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Anchor == nil {
				m.Anchor = &RawAnchor{}
			}
			if err := m.Anchor.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Target == nil {
				m.Target = &Node{}
			}
			if err := m.Target.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServing(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServing
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PagedCrossReferences) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServing
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PagedCrossReferences: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PagedCrossReferences: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceTicket", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceTicket = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Group = append(m.Group, &PagedCrossReferences_Group{})
			if err := m.Group[len(m.Group)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageIndex", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PageIndex = append(m.PageIndex, &PagedCrossReferences_PageIndex{})
			if err := m.PageIndex[len(m.PageIndex)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalReferences", wireType)
			}
			m.TotalReferences = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.TotalReferences |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Incomplete", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Incomplete = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipServing(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServing
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PagedCrossReferences_Group) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServing
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Group: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Group: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Anchor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Anchor = append(m.Anchor, &ExpandedAnchor{})
			if err := m.Anchor[len(m.Anchor)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServing(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServing
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PagedCrossReferences_Page) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServing
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Page: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Page: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PageKey = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceTicket", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceTicket = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Group", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Group == nil {
				m.Group = &PagedCrossReferences_Group{}
			}
			if err := m.Group.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServing(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServing
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *PagedCrossReferences_PageIndex) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowServing
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: PageIndex: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: PageIndex: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Count", wireType)
			}
			m.Count = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Count |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowServing
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthServing
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PageKey = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipServing(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthServing
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipServing(data []byte) (n int, err error) {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowServing
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowServing
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if data[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowServing
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthServing
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowServing
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipServing(data[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthServing = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowServing   = fmt.Errorf("proto: integer overflow")
)

var fileDescriptorServing = []byte{
	// 778 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x9c, 0x54, 0xcb, 0x6e, 0xd3, 0x5a,
	0x14, 0xbd, 0x6e, 0x9c, 0xb4, 0xd9, 0x49, 0x1f, 0xd7, 0xed, 0x95, 0x5c, 0x0f, 0xaa, 0xca, 0x57,
	0x6a, 0x7b, 0x07, 0xd7, 0x11, 0x89, 0x04, 0x52, 0x07, 0x95, 0xe8, 0x53, 0x30, 0x40, 0xa8, 0xfd,
	0x00, 0xcb, 0xb5, 0x4f, 0x52, 0x2b, 0xa9, 0x8f, 0x39, 0x3e, 0x81, 0xf6, 0x2f, 0x18, 0x32, 0xe7,
	0x0b, 0x18, 0xf0, 0x0f, 0x0c, 0xf9, 0x01, 0x24, 0x04, 0xff, 0xc0, 0x98, 0x7d, 0x1e, 0x7e, 0x84,
	0x26, 0x29, 0x65, 0x60, 0xc9, 0xe7, 0xb1, 0xd7, 0x5a, 0x7b, 0x9d, 0xbd, 0x37, 0x6c, 0x0e, 0x6f,
	0xf9, 0x15, 0xe9, 0xa4, 0x8c, 0x72, 0xda, 0xc9, 0x08, 0x7b, 0x1d, 0x27, 0x03, 0x4f, 0xae, 0xac,
	0x75, 0x79, 0xa4, 0x16, 0x9e, 0x3e, 0x72, 0xec, 0xea, 0xfd, 0x90, 0x5e, 0x5f, 0xd3, 0x44, 0xdd,
	0x70, 0x0f, 0xc0, 0x7c, 0x41, 0x23, 0x62, 0xad, 0x40, 0x83, 0xc7, 0xe1, 0x90, 0x70, 0xdb, 0xd8,
	0x36, 0xf6, 0x9a, 0xd6, 0x0e, 0x98, 0xfd, 0x20, 0xe4, 0xf6, 0xc2, 0x76, 0x6d, 0xaf, 0xd5, 0xb5,
	0xbd, 0x2a, 0xaa, 0x06, 0x38, 0xc5, 0x73, 0xf7, 0xbd, 0x01, 0xe6, 0x49, 0x34, 0x20, 0xd6, 0x7f,
	0xd0, 0xc8, 0xe8, 0x98, 0x85, 0x44, 0x02, 0xb4, 0xba, 0x9b, 0xde, 0x14, 0x21, 0x9e, 0xe4, 0x6a,
	0x83, 0x39, 0x8c, 0x93, 0x08, 0xb1, 0x05, 0x13, 0x06, 0xf2, 0x80, 0x0d, 0x90, 0xb9, 0x76, 0x5f,
	0x60, 0x2e, 0xca, 0x9c, 0x2f, 0xca, 0x5a, 0x85, 0x45, 0xca, 0xa2, 0x38, 0x09, 0x46, 0x76, 0x1d,
	0x31, 0xeb, 0xee, 0x5b, 0x03, 0x9a, 0x42, 0xe5, 0x19, 0xa3, 0xe3, 0xb4, 0xe0, 0x57, 0x99, 0x3e,
	0x02, 0x93, 0xe0, 0x91, 0xce, 0xf4, 0xdf, 0xa9, 0xec, 0x45, 0xac, 0xfc, 0x73, 0x0e, 0xcb, 0x9c,
	0xb5, 0xf4, 0x7b, 0x73, 0xae, 0x48, 0x5a, 0x90, 0x92, 0x3e, 0x18, 0xd0, 0x7e, 0x19, 0x0c, 0x48,
	0x24, 0x90, 0x2e, 0x08, 0x7f, 0x88, 0x81, 0xff, 0x43, 0x7d, 0x20, 0xd4, 0x68, 0xcd, 0x5b, 0xf3,
	0x35, 0x5b, 0xeb, 0xd0, 0xe2, 0x94, 0x07, 0x23, 0x5f, 0xe4, 0x99, 0x49, 0x9b, 0xeb, 0x56, 0x17,
	0x20, 0x45, 0x7a, 0x1f, 0x8d, 0x20, 0x37, 0xda, 0xd1, 0xe9, 0x40, 0x42, 0xe5, 0x33, 0x71, 0xcb,
	0x3d, 0x86, 0x66, 0xb1, 0xb0, 0xfe, 0x86, 0xa6, 0xc0, 0xf3, 0x2b, 0x56, 0x5a, 0x00, 0x72, 0x2b,
	0xa4, 0xe3, 0x84, 0xab, 0x3c, 0xad, 0x35, 0x58, 0x92, 0x3c, 0x43, 0x72, 0x2b, 0x99, 0x9b, 0xee,
	0x15, 0x2c, 0x09, 0x6d, 0x02, 0x69, 0xe2, 0x54, 0x61, 0xfc, 0x03, 0xcb, 0xca, 0x06, 0x5f, 0xd7,
	0xa3, 0xaa, 0x92, 0x1e, 0xb4, 0xa4, 0x7a, 0x5f, 0x25, 0xae, 0x4a, 0xe5, 0x9e, 0xc4, 0xdd, 0x7d,
	0x58, 0x3e, 0x8d, 0x47, 0xe4, 0x38, 0x66, 0x24, 0xe4, 0x94, 0xdd, 0x5a, 0x1b, 0xd0, 0xce, 0xc6,
	0x97, 0x51, 0xbe, 0x46, 0xca, 0x1a, 0x62, 0xa3, 0x3f, 0x7d, 0xbc, 0x56, 0x12, 0xe2, 0xa6, 0x9b,
	0x40, 0xeb, 0x88, 0xb2, 0x74, 0x9c, 0x9d, 0x53, 0xca, 0x33, 0xeb, 0x09, 0x34, 0x42, 0xb9, 0x94,
	0x31, 0xad, 0xee, 0xee, 0x54, 0xea, 0x4a, 0x84, 0xfe, 0x77, 0x76, 0xa0, 0xa1, 0xfe, 0x44, 0x8b,
	0x15, 0x10, 0x22, 0x25, 0x2c, 0x43, 0x86, 0x37, 0x35, 0xdf, 0x63, 0x30, 0x85, 0xd6, 0x3b, 0x8d,
	0x88, 0xb7, 0x38, 0xb9, 0x51, 0x36, 0xb4, 0x85, 0x5f, 0x24, 0x09, 0x29, 0x16, 0xd2, 0x40, 0xbb,
	0xf9, 0x0a, 0x9a, 0xe7, 0xc1, 0x9b, 0xa7, 0x49, 0x78, 0x45, 0xd9, 0x9d, 0x60, 0x91, 0x2f, 0x56,
	0x28, 0xf7, 0x69, 0xbf, 0x9f, 0x91, 0xfc, 0x49, 0xc4, 0x33, 0x25, 0x51, 0xbe, 0xa7, 0xca, 0x41,
	0xd8, 0x9e, 0xc4, 0x69, 0x4a, 0xb8, 0x2f, 0x23, 0xb0, 0x22, 0xc4, 0x36, 0x5a, 0x93, 0x6f, 0x63,
	0x88, 0xee, 0xa6, 0x8f, 0x06, 0xac, 0x9c, 0xdc, 0xa4, 0x01, 0x96, 0x41, 0x34, 0x83, 0x78, 0xb2,
	0xc5, 0xf1, 0x34, 0x0d, 0x18, 0x49, 0x14, 0x59, 0x99, 0x93, 0x99, 0x8f, 0x9a, 0x0c, 0xc1, 0x24,
	0xf8, 0x8c, 0xae, 0xbe, 0xc0, 0x73, 0xd1, 0x42, 0x5a, 0x8b, 0xdd, 0x90, 0x81, 0x1e, 0x66, 0x97,
	0x6b, 0x16, 0x00, 0x8b, 0xf3, 0x01, 0xdc, 0x1f, 0x06, 0xac, 0xca, 0x7a, 0x20, 0xf8, 0x0e, 0x01,
	0x8f, 0x69, 0x92, 0x59, 0xbb, 0x38, 0x52, 0x70, 0x6b, 0x6e, 0xcf, 0xc9, 0x77, 0x39, 0x02, 0x88,
	0x8a, 0x38, 0xdd, 0x78, 0x9d, 0x99, 0xd7, 0x2b, 0x14, 0x5e, 0xf9, 0xef, 0x8c, 0x01, 0xca, 0x15,
	0xea, 0x6f, 0x04, 0xd2, 0x3e, 0xcd, 0x3e, 0xbd, 0x9c, 0xcb, 0xd7, 0xfd, 0xd3, 0xb9, 0xe9, 0x7e,
	0xa9, 0xc1, 0x86, 0x9c, 0x35, 0x47, 0x8c, 0x66, 0xd9, 0x39, 0xe9, 0x13, 0x7c, 0x8c, 0x90, 0x64,
	0x77, 0x9b, 0x4d, 0xbd, 0xde, 0xc1, 0xe4, 0x7c, 0xe9, 0xcc, 0x1c, 0x0b, 0xbf, 0x02, 0x7a, 0x6a,
	0xe0, 0x9c, 0x4d, 0xcc, 0x96, 0x9a, 0x04, 0xe9, 0xfd, 0x3e, 0x48, 0x39, 0x63, 0x6c, 0x58, 0x53,
	0x93, 0x8b, 0x15, 0xa7, 0xba, 0x30, 0xb1, 0x86, 0x63, 0x6c, 0x84, 0xeb, 0x74, 0x44, 0x38, 0x91,
	0xa5, 0xb3, 0xe4, 0x3c, 0x87, 0xfa, 0xb4, 0x01, 0xdf, 0x2b, 0x6c, 0x9e, 0x3b, 0xe2, 0x27, 0x0a,
	0xda, 0xa1, 0x60, 0x3e, 0x6c, 0x40, 0x15, 0x9e, 0xa9, 0xd7, 0x78, 0xa8, 0x67, 0xce, 0x7e, 0x75,
	0xb6, 0x4e, 0x26, 0xb0, 0x0c, 0xf5, 0xb9, 0x13, 0xf5, 0x70, 0xed, 0xd3, 0xb7, 0x2d, 0xe3, 0x33,
	0x7e, 0x5f, 0xf1, 0x7b, 0xf7, 0x7d, 0xeb, 0xaf, 0xcb, 0x86, 0xe4, 0xed, 0xfd, 0x0c, 0x00, 0x00,
	0xff, 0xff, 0xda, 0x3a, 0x1d, 0xb3, 0x29, 0x08, 0x00, 0x00,
}
