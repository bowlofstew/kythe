// Code generated by protoc-gen-gogo.
// source: kythe/proto/xref.proto
// DO NOT EDIT!

/*
	Package xref_proto is a generated protocol buffer package.

	It is generated from these files:
		kythe/proto/xref.proto

	It has these top-level messages:
		NodesRequest
		NodeInfo
		NodesReply
		EdgesRequest
		EdgeSet
		EdgesReply
		Location
		DecorationsRequest
		DecorationsReply
		CrossReferencesRequest
		Anchor
		CrossReferencesReply
		CallersRequest
		CallersReply
		DocumentationRequest
		DocumentationReply
*/
package xref_proto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import errors "errors"

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
const _ = proto.ProtoPackageIsVersion1

type Location_Kind int32

const (
	// The entire file; the start and end fields are ignored.
	Location_FILE Location_Kind = 0
	// The point or span of file subtended by start and end.
	Location_SPAN Location_Kind = 1
)

var Location_Kind_name = map[int32]string{
	0: "FILE",
	1: "SPAN",
}
var Location_Kind_value = map[string]int32{
	"FILE": 0,
	"SPAN": 1,
}

func (x Location_Kind) String() string {
	return proto.EnumName(Location_Kind_name, int32(x))
}
func (Location_Kind) EnumDescriptor() ([]byte, []int) { return fileDescriptorXref, []int{6, 0} }

type DecorationsRequest_SpanKind int32

const (
	// If the location is a SPAN, only decorations contained within the
	// specified window of the file are returned.  This is the default behavior.
	DecorationsRequest_WITHIN_SPAN DecorationsRequest_SpanKind = 0
	// If the location is a SPAN, any decorations that surround it are returned.
	DecorationsRequest_AROUND_SPAN DecorationsRequest_SpanKind = 1
)

var DecorationsRequest_SpanKind_name = map[int32]string{
	0: "WITHIN_SPAN",
	1: "AROUND_SPAN",
}
var DecorationsRequest_SpanKind_value = map[string]int32{
	"WITHIN_SPAN": 0,
	"AROUND_SPAN": 1,
}

func (x DecorationsRequest_SpanKind) String() string {
	return proto.EnumName(DecorationsRequest_SpanKind_name, int32(x))
}
func (DecorationsRequest_SpanKind) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorXref, []int{7, 0}
}

type CrossReferencesRequest_DefinitionKind int32

const (
	// No definitions will be populated in the CrossReferencesReply.
	CrossReferencesRequest_NO_DEFINITIONS CrossReferencesRequest_DefinitionKind = 0
	// All known definition anchors reached by the "/kythe/edge/defines" edge
	// kind (or its variants) will be populated in the CrossReferencesReply.
	CrossReferencesRequest_ALL_DEFINITIONS CrossReferencesRequest_DefinitionKind = 1
	// Only definition anchors reached by the "/kythe/edge/defines" edge kind
	// will be populated in the CrossReferencesReply.
	CrossReferencesRequest_FULL_DEFINITIONS CrossReferencesRequest_DefinitionKind = 2
	// Only definition anchors reached by the "/kythe/edge/defines/binding" edge
	// kind will be populated in the CrossReferencesReply.
	CrossReferencesRequest_BINDING_DEFINITIONS CrossReferencesRequest_DefinitionKind = 3
)

var CrossReferencesRequest_DefinitionKind_name = map[int32]string{
	0: "NO_DEFINITIONS",
	1: "ALL_DEFINITIONS",
	2: "FULL_DEFINITIONS",
	3: "BINDING_DEFINITIONS",
}
var CrossReferencesRequest_DefinitionKind_value = map[string]int32{
	"NO_DEFINITIONS":      0,
	"ALL_DEFINITIONS":     1,
	"FULL_DEFINITIONS":    2,
	"BINDING_DEFINITIONS": 3,
}

func (x CrossReferencesRequest_DefinitionKind) String() string {
	return proto.EnumName(CrossReferencesRequest_DefinitionKind_name, int32(x))
}
func (CrossReferencesRequest_DefinitionKind) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorXref, []int{9, 0}
}

type CrossReferencesRequest_DeclarationKind int32

const (
	// No declarations will be populated in the CrossDeclarationsReply.
	CrossReferencesRequest_NO_DECLARATIONS CrossReferencesRequest_DeclarationKind = 0
	// When the source node is incomplete, all known declaration anchors reached
	// by the "/kythe/edge/defines" edge kind (or its variants) will be
	// populated in the CrossDeclarationsReply.
	CrossReferencesRequest_ALL_DECLARATIONS CrossReferencesRequest_DeclarationKind = 1
)

var CrossReferencesRequest_DeclarationKind_name = map[int32]string{
	0: "NO_DECLARATIONS",
	1: "ALL_DECLARATIONS",
}
var CrossReferencesRequest_DeclarationKind_value = map[string]int32{
	"NO_DECLARATIONS":  0,
	"ALL_DECLARATIONS": 1,
}

func (x CrossReferencesRequest_DeclarationKind) String() string {
	return proto.EnumName(CrossReferencesRequest_DeclarationKind_name, int32(x))
}
func (CrossReferencesRequest_DeclarationKind) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorXref, []int{9, 1}
}

type CrossReferencesRequest_ReferenceKind int32

const (
	// No references will be populated in the CrossReferencesReply.
	CrossReferencesRequest_NO_REFERENCES CrossReferencesRequest_ReferenceKind = 0
	// All known reference anchors reached by the "/kythe/edge/ref" edge kind
	// (or its variants) will be populated in the CrossReferencesReply.
	CrossReferencesRequest_ALL_REFERENCES CrossReferencesRequest_ReferenceKind = 1
)

var CrossReferencesRequest_ReferenceKind_name = map[int32]string{
	0: "NO_REFERENCES",
	1: "ALL_REFERENCES",
}
var CrossReferencesRequest_ReferenceKind_value = map[string]int32{
	"NO_REFERENCES":  0,
	"ALL_REFERENCES": 1,
}

func (x CrossReferencesRequest_ReferenceKind) String() string {
	return proto.EnumName(CrossReferencesRequest_ReferenceKind_name, int32(x))
}
func (CrossReferencesRequest_ReferenceKind) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorXref, []int{9, 2}
}

type CrossReferencesRequest_DocumentationKind int32

const (
	// No documentation will be populated in the CrossReferencesReply.
	CrossReferencesRequest_NO_DOCUMENTATION CrossReferencesRequest_DocumentationKind = 0
	// All known documentation reached by the "/kythe/edge/documentation" edge
	// kind (or its variants) will be populated in the CrossReferencesReply.
	CrossReferencesRequest_ALL_DOCUMENTATION CrossReferencesRequest_DocumentationKind = 1
)

var CrossReferencesRequest_DocumentationKind_name = map[int32]string{
	0: "NO_DOCUMENTATION",
	1: "ALL_DOCUMENTATION",
}
var CrossReferencesRequest_DocumentationKind_value = map[string]int32{
	"NO_DOCUMENTATION":  0,
	"ALL_DOCUMENTATION": 1,
}

func (x CrossReferencesRequest_DocumentationKind) String() string {
	return proto.EnumName(CrossReferencesRequest_DocumentationKind_name, int32(x))
}
func (CrossReferencesRequest_DocumentationKind) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorXref, []int{9, 3}
}

type CallersReply_CallableDetail_Parameter_Kind int32

const (
	// A term-level binding (like the `x` in `void foo(int x)`).
	CallersReply_CallableDetail_Parameter_TERM CallersReply_CallableDetail_Parameter_Kind = 0
	// A type-level binding (like the `T` in
	// `template <typename T> void foo()`).
	CallersReply_CallableDetail_Parameter_TYPE CallersReply_CallableDetail_Parameter_Kind = 1
)

var CallersReply_CallableDetail_Parameter_Kind_name = map[int32]string{
	0: "TERM",
	1: "TYPE",
}
var CallersReply_CallableDetail_Parameter_Kind_value = map[string]int32{
	"TERM": 0,
	"TYPE": 1,
}

func (x CallersReply_CallableDetail_Parameter_Kind) String() string {
	return proto.EnumName(CallersReply_CallableDetail_Parameter_Kind_name, int32(x))
}
func (CallersReply_CallableDetail_Parameter_Kind) EnumDescriptor() ([]byte, []int) {
	return fileDescriptorXref, []int{13, 0, 0, 0}
}

type NodesRequest struct {
	// The tickets of the nodes to be looked up.
	Ticket []string `protobuf:"bytes,1,rep,name=ticket" json:"ticket,omitempty"`
	// A collection of filter globs that specify which facts (by name) should be
	// returned for each node.  If filter is empty or unset, all available facts
	// are returned for each matching node.  The filter applies to ALL requested
	// nodes.  For different filters per node, the client must issue separate
	// requests.  See EdgesRequest for the format of the filter globs.
	Filter []string `protobuf:"bytes,2,rep,name=filter" json:"filter,omitempty"`
}

func (m *NodesRequest) Reset()                    { *m = NodesRequest{} }
func (m *NodesRequest) String() string            { return proto.CompactTextString(m) }
func (*NodesRequest) ProtoMessage()               {}
func (*NodesRequest) Descriptor() ([]byte, []int) { return fileDescriptorXref, []int{0} }

type NodeInfo struct {
	// The matching facts known for that node, a map from fact name to value.
	Facts map[string][]byte `protobuf:"bytes,2,rep,name=facts" json:"facts,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// If known and unambiguous, an anchor ticket for this node's definition
	// location.
	Definition string `protobuf:"bytes,5,opt,name=definition,proto3" json:"definition,omitempty"`
}

func (m *NodeInfo) Reset()                    { *m = NodeInfo{} }
func (m *NodeInfo) String() string            { return proto.CompactTextString(m) }
func (*NodeInfo) ProtoMessage()               {}
func (*NodeInfo) Descriptor() ([]byte, []int) { return fileDescriptorXref, []int{1} }

func (m *NodeInfo) GetFacts() map[string][]byte {
	if m != nil {
		return m.Facts
	}
	return nil
}

type NodesReply struct {
	// One NodeInfo, keyed by its ticket, is returned for each requested node
	// that had a non-zero number of matching facts.  Each NodeInfo will not have
	// its ticket set since it would just be a copy of the map keys.
	Nodes map[string]*NodeInfo `protobuf:"bytes,1,rep,name=nodes" json:"nodes,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *NodesReply) Reset()                    { *m = NodesReply{} }
func (m *NodesReply) String() string            { return proto.CompactTextString(m) }
func (*NodesReply) ProtoMessage()               {}
func (*NodesReply) Descriptor() ([]byte, []int) { return fileDescriptorXref, []int{2} }

func (m *NodesReply) GetNodes() map[string]*NodeInfo {
	if m != nil {
		return m.Nodes
	}
	return nil
}

type EdgesRequest struct {
	// The tickets of the source nodes for which edges are requested.
	// The service will return an error if no tickets are specified.
	Ticket []string `protobuf:"bytes,1,rep,name=ticket" json:"ticket,omitempty"`
	// The kinds of outbound edges that should be returned for each matching
	// source node.  If empty, all available edge kinds are returned.
	Kind []string `protobuf:"bytes,2,rep,name=kind" json:"kind,omitempty"`
	// A collection of filter globs that specify which facts (by name) should be
	// returned for the target node of each matching edge.  If filter is empty,
	// no facts are returned.
	//
	// The supported glob operators are:
	//   *   zero or more non-slash characters ([^/]*)
	//   ?   any single non-slash character ([^/])
	//   **  zero or more of any character (.*)
	//
	// All other characters match literally, and the glob must consume the entire
	// name in order to match.  The facts returned are the union of those matched
	// by all the globs provided.
	Filter []string `protobuf:"bytes,3,rep,name=filter" json:"filter,omitempty"`
	// The edges matching a request are organized into logical pages.  The size
	// of each page is a number of distinct edges.  Notionally: All the matching
	// edges are ordered lexicographically by (start_ticket, kind, end_ticket);
	// the page_token determines where in the ordering to start, and page_size
	// determines how many edges should be returned.
	//
	// If page_token is empty, edges will be returned starting at the beginning
	// of the sequence; otherwise the starting point named by the page_token will
	// be used.  Legal values of page_token are returned by the server in the
	// next_page_token field of the EdgesReply.  A page token should be treated
	// as an opaque value by the client, and is valid only relative to a
	// particular set of tickets and kinds.  If an invalid page token is
	// requested, the server will return an error.
	//
	// If page_size > 0, at most that number of edges will be returned by the
	// service for this request (see EdgeSet and EdgesReply below).
	// If page_size = 0, the default, the server will assume a reasonable default
	// page size.  The server will return an error if page_size < 0.
	//
	// The server is allowed to return fewer edges than the requested page_size,
	// even if more are available, save that it must return at least 1 edge if
	// any are available at all.
	PageSize  int32  `protobuf:"varint,8,opt,name=page_size,proto3" json:"page_size,omitempty"`
	PageToken string `protobuf:"bytes,9,opt,name=page_token,proto3" json:"page_token,omitempty"`
}

func (m *EdgesRequest) Reset()                    { *m = EdgesRequest{} }
func (m *EdgesRequest) String() string            { return proto.CompactTextString(m) }
func (*EdgesRequest) ProtoMessage()               {}
func (*EdgesRequest) Descriptor() ([]byte, []int) { return fileDescriptorXref, []int{3} }

// An EdgeSet represents a collection of edges outbound from a single node.  The
// edges are organized into groups, each sharing a common edge kind.
//
// The number of edges represented by an EdgeSet es, denoted len(es), is the sum
// of the lengths of the repeated edge fields for all the groups in the EdgeSet.
// This count is used to determine page size in a request.
type EdgeSet struct {
	// Each group is a collection of outbound edges from source node sharing a
	// given kind, the map's keys.  In a given EdgeSet, the server will not send
	// more than one group with the same kind label.
	Groups map[string]*EdgeSet_Group `protobuf:"bytes,2,rep,name=groups" json:"groups,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *EdgeSet) Reset()                    { *m = EdgeSet{} }
func (m *EdgeSet) String() string            { return proto.CompactTextString(m) }
func (*EdgeSet) ProtoMessage()               {}
func (*EdgeSet) Descriptor() ([]byte, []int) { return fileDescriptorXref, []int{4} }

func (m *EdgeSet) GetGroups() map[string]*EdgeSet_Group {
	if m != nil {
		return m.Groups
	}
	return nil
}

type EdgeSet_Group struct {
	Edge []*EdgeSet_Group_Edge `protobuf:"bytes,2,rep,name=edge" json:"edge,omitempty"`
}

func (m *EdgeSet_Group) Reset()                    { *m = EdgeSet_Group{} }
func (m *EdgeSet_Group) String() string            { return proto.CompactTextString(m) }
func (*EdgeSet_Group) ProtoMessage()               {}
func (*EdgeSet_Group) Descriptor() ([]byte, []int) { return fileDescriptorXref, []int{4, 0} }

func (m *EdgeSet_Group) GetEdge() []*EdgeSet_Group_Edge {
	if m != nil {
		return m.Edge
	}
	return nil
}

type EdgeSet_Group_Edge struct {
	TargetTicket string `protobuf:"bytes,1,opt,name=target_ticket,proto3" json:"target_ticket,omitempty"`
	// An optional integer to give an ordering between multiple edges of same
	// source and kind to one or more targets.  See https://kythe.io/schema
	// for when ordinals are used for a given edge kind.
	Ordinal int32 `protobuf:"varint,2,opt,name=ordinal,proto3" json:"ordinal,omitempty"`
}

func (m *EdgeSet_Group_Edge) Reset()                    { *m = EdgeSet_Group_Edge{} }
func (m *EdgeSet_Group_Edge) String() string            { return proto.CompactTextString(m) }
func (*EdgeSet_Group_Edge) ProtoMessage()               {}
func (*EdgeSet_Group_Edge) Descriptor() ([]byte, []int) { return fileDescriptorXref, []int{4, 0, 0} }

type EdgesReply struct {
	// This field will contain one EdgeSet for each source node with one or more
	// matching outbound edges, keyed by the source node's ticket.  The number of
	// edges represented by an EdgesReply er, denoted len(er), is the sum of
	// len(es) for each es in edge_sets.  This count is used to determine the page
	// size.
	EdgeSets map[string]*EdgeSet `protobuf:"bytes,1,rep,name=edge_sets" json:"edge_sets,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	// This field will contain one entry, keyed by ticket, for each distinct node
	// referenced by some edge in edgesets, for which there is one or more
	// matching facts.
	//
	// Rationale: This prevents us from having to copy the data to all the end
	// nodes, but allows the client to have that information without making
	// additional requests.
	Nodes map[string]*NodeInfo `protobuf:"bytes,2,rep,name=nodes" json:"nodes,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	// Total number of edges on all pages matching requested kinds.
	TotalEdges int64 `protobuf:"varint,3,opt,name=total_edges,proto3" json:"total_edges,omitempty"`
	// If there are additional pages of edges after the ones returned in this
	// reply, next_page_token is the page token that may be passed to fetch the
	// next page in sequence after this one.  If there are no additional edges,
	// this field will be empty.
	NextPageToken string `protobuf:"bytes,9,opt,name=next_page_token,proto3" json:"next_page_token,omitempty"`
}

func (m *EdgesReply) Reset()                    { *m = EdgesReply{} }
func (m *EdgesReply) String() string            { return proto.CompactTextString(m) }
func (*EdgesReply) ProtoMessage()               {}
func (*EdgesReply) Descriptor() ([]byte, []int) { return fileDescriptorXref, []int{5} }

func (m *EdgesReply) GetEdgeSets() map[string]*EdgeSet {
	if m != nil {
		return m.EdgeSets
	}
	return nil
}

func (m *EdgesReply) GetNodes() map[string]*NodeInfo {
	if m != nil {
		return m.Nodes
	}
	return nil
}

// A Location represents a single span of zero or more contiguous bytes of a
// file or buffer.  An empty LOCATION denotes the entirety of the referenced
// file or buffer.
//
type Location struct {
	// The ticket of the file this location belongs to.  If the location
	// represents a memory buffer, the ticket should be omitted.
	Ticket string `protobuf:"bytes,1,opt,name=ticket,proto3" json:"ticket,omitempty"`
	// What kind of location this is.
	Kind Location_Kind `protobuf:"varint,2,opt,name=kind,proto3,enum=kythe.proto.Location_Kind" json:"kind,omitempty"`
	// The starting point of the location.
	Start *Location_Point `protobuf:"bytes,3,opt,name=start" json:"start,omitempty"`
	// The ending point of the location.
	End *Location_Point `protobuf:"bytes,4,opt,name=end" json:"end,omitempty"`
}

func (m *Location) Reset()                    { *m = Location{} }
func (m *Location) String() string            { return proto.CompactTextString(m) }
func (*Location) ProtoMessage()               {}
func (*Location) Descriptor() ([]byte, []int) { return fileDescriptorXref, []int{6} }

func (m *Location) GetStart() *Location_Point {
	if m != nil {
		return m.Start
	}
	return nil
}

func (m *Location) GetEnd() *Location_Point {
	if m != nil {
		return m.End
	}
	return nil
}

// A Point represents a location within a file or buffer.
//
// If line_number ≤ 0, the line number and column offset are considered
// unknown and will be ignored.
//
// A point with line_number > 0 is said to be _normalized_ if it satisfies
// the constraint 0 ≤ column_offset ≤ bytelen(line_number); that is, if the
// column_offset is within the actual range of the corresponding line.  A
// point can be normalized by adjusting line_number and column_offset so that
// this constraint is satisfied.  This may be impossible if the column offset
// exceeds the bounds of the file.
type Location_Point struct {
	// The offset in bytes from the beginning of the file.
	// Requires 0 ≤ byte_offset ≤ len(file).
	ByteOffset int32 `protobuf:"varint,1,opt,name=byte_offset,proto3" json:"byte_offset,omitempty"`
	// The line number containing the point, 1-based.
	LineNumber int32 `protobuf:"varint,2,opt,name=line_number,proto3" json:"line_number,omitempty"`
	// The byte offset of the point within its line.
	ColumnOffset int32 `protobuf:"varint,3,opt,name=column_offset,proto3" json:"column_offset,omitempty"`
}

func (m *Location_Point) Reset()                    { *m = Location_Point{} }
func (m *Location_Point) String() string            { return proto.CompactTextString(m) }
func (*Location_Point) ProtoMessage()               {}
func (*Location_Point) Descriptor() ([]byte, []int) { return fileDescriptorXref, []int{6, 0} }

type DecorationsRequest struct {
	// The location of the file to fetch decorations for.  The ticket of location
	// must be non-empty.  It is an error in any case if location is invalid.
	Location *Location `protobuf:"bytes,1,opt,name=location" json:"location,omitempty"`
	// How to treat SPAN locations.
	SpanKind DecorationsRequest_SpanKind `protobuf:"varint,10,opt,name=span_kind,proto3,enum=kythe.proto.DecorationsRequest_SpanKind" json:"span_kind,omitempty"`
	// If dirty_buffer is non-empty, the results will be adjusted (patched) to
	// account for the regions of the specified file differing from the contents
	// of the dirty buffer.
	DirtyBuffer []byte `protobuf:"bytes,2,opt,name=dirty_buffer,proto3" json:"dirty_buffer,omitempty"`
	// If true, return the encoded source text for the selected window.  Source
	// text is not affected by patching.
	SourceText bool `protobuf:"varint,3,opt,name=source_text,proto3" json:"source_text,omitempty"`
	// If true, return reference edges whose source nodes are located in the
	// selected window.  References are affected by patching.
	References bool `protobuf:"varint,4,opt,name=references,proto3" json:"references,omitempty"`
	// If true, return definition locations, if possible, for each returned
	// reference target in the DecorationsReply.
	TargetDefinitions bool `protobuf:"varint,6,opt,name=target_definitions,proto3" json:"target_definitions,omitempty"`
	// A collection of filter globs that specify which facts (by name) should be
	// returned for each node.  If filter is empty or unset, no node facts are
	// returned.  The filter applies to ALL referenced nodes.  See EdgesRequest
	// for the format of the filter globs.
	Filter []string `protobuf:"bytes,5,rep,name=filter" json:"filter,omitempty"`
}

func (m *DecorationsRequest) Reset()                    { *m = DecorationsRequest{} }
func (m *DecorationsRequest) String() string            { return proto.CompactTextString(m) }
func (*DecorationsRequest) ProtoMessage()               {}
func (*DecorationsRequest) Descriptor() ([]byte, []int) { return fileDescriptorXref, []int{7} }

func (m *DecorationsRequest) GetLocation() *Location {
	if m != nil {
		return m.Location
	}
	return nil
}

type DecorationsReply struct {
	// The normalized location for which decorations are returned.
	Location *Location `protobuf:"bytes,1,opt,name=location" json:"location,omitempty"`
	// The encoded source text for the selected window.
	SourceText []byte `protobuf:"bytes,2,opt,name=source_text,proto3" json:"source_text,omitempty"`
	Encoding   string `protobuf:"bytes,3,opt,name=encoding,proto3" json:"encoding,omitempty"`
	// The reference edges located in the specified window.
	Reference []*DecorationsReply_Reference `protobuf:"bytes,4,rep,name=reference" json:"reference,omitempty"`
	// This field will contain one entry, keyed by ticket, for each distinct node
	// referenced by a reference edge that has at least 1 non-filtered fact.
	Nodes map[string]*NodeInfo `protobuf:"bytes,15,rep,name=nodes" json:"nodes,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	// Each anchor cited as a target definition in the references.  The map is
	// keyed by each anchor's ticket.
	DefinitionLocations map[string]*Anchor `protobuf:"bytes,16,rep,name=definition_locations" json:"definition_locations,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
}

func (m *DecorationsReply) Reset()                    { *m = DecorationsReply{} }
func (m *DecorationsReply) String() string            { return proto.CompactTextString(m) }
func (*DecorationsReply) ProtoMessage()               {}
func (*DecorationsReply) Descriptor() ([]byte, []int) { return fileDescriptorXref, []int{8} }

func (m *DecorationsReply) GetLocation() *Location {
	if m != nil {
		return m.Location
	}
	return nil
}

func (m *DecorationsReply) GetReference() []*DecorationsReply_Reference {
	if m != nil {
		return m.Reference
	}
	return nil
}

func (m *DecorationsReply) GetNodes() map[string]*NodeInfo {
	if m != nil {
		return m.Nodes
	}
	return nil
}

func (m *DecorationsReply) GetDefinitionLocations() map[string]*Anchor {
	if m != nil {
		return m.DefinitionLocations
	}
	return nil
}

// Represents a reference edge source ---KIND---> target.  Each source is an
// anchor within the requested source location.
type DecorationsReply_Reference struct {
	SourceTicket string `protobuf:"bytes,1,opt,name=source_ticket,proto3" json:"source_ticket,omitempty"`
	TargetTicket string `protobuf:"bytes,2,opt,name=target_ticket,proto3" json:"target_ticket,omitempty"`
	Kind         string `protobuf:"bytes,3,opt,name=kind,proto3" json:"kind,omitempty"`
	// Starting byte offset of this references's anchor (source_ticket) span.
	AnchorStart *Location_Point `protobuf:"bytes,10,opt,name=anchor_start" json:"anchor_start,omitempty"`
	// Ending byte offset of this references's anchor (source_ticket) span.
	AnchorEnd *Location_Point `protobuf:"bytes,11,opt,name=anchor_end" json:"anchor_end,omitempty"`
	// Anchor ticket of the target's definition.  Populated only if
	// target_definitions is true in the DecorationsRequest and the target has
	// a single unambiguous definition.  For each ticket, an Anchor will be
	// populated in the top-level definition_locations map.
	TargetDefinition string `protobuf:"bytes,4,opt,name=target_definition,proto3" json:"target_definition,omitempty"`
}

func (m *DecorationsReply_Reference) Reset()         { *m = DecorationsReply_Reference{} }
func (m *DecorationsReply_Reference) String() string { return proto.CompactTextString(m) }
func (*DecorationsReply_Reference) ProtoMessage()    {}
func (*DecorationsReply_Reference) Descriptor() ([]byte, []int) {
	return fileDescriptorXref, []int{8, 0}
}

func (m *DecorationsReply_Reference) GetAnchorStart() *Location_Point {
	if m != nil {
		return m.AnchorStart
	}
	return nil
}

func (m *DecorationsReply_Reference) GetAnchorEnd() *Location_Point {
	if m != nil {
		return m.AnchorEnd
	}
	return nil
}

type CrossReferencesRequest struct {
	// Set of nodes for which to return their cross-references.  Must be
	// non-empty.
	Ticket []string `protobuf:"bytes,1,rep,name=ticket" json:"ticket,omitempty"`
	// Determines what kind of definition anchors, if any, should be returned in
	// the response.  See the documentation for each DefinitionKind for more
	// information.
	DefinitionKind CrossReferencesRequest_DefinitionKind `protobuf:"varint,2,opt,name=definition_kind,proto3,enum=kythe.proto.CrossReferencesRequest_DefinitionKind" json:"definition_kind,omitempty"`
	// Determines what kind of declaration anchors, if any, should be returned in
	// the response.  See the documentation for each DeclarationKind for more
	// information.
	DeclarationKind CrossReferencesRequest_DeclarationKind `protobuf:"varint,7,opt,name=declaration_kind,proto3,enum=kythe.proto.CrossReferencesRequest_DeclarationKind" json:"declaration_kind,omitempty"`
	// Determines what kind of reference anchors, if any, should be returned in
	// the response.  See the documentation for each ReferenceKind for more
	// information.
	ReferenceKind CrossReferencesRequest_ReferenceKind `protobuf:"varint,3,opt,name=reference_kind,proto3,enum=kythe.proto.CrossReferencesRequest_ReferenceKind" json:"reference_kind,omitempty"`
	// Determines what kind of documentation anchors, if any, should be returned
	// in the response.  See the documentation for each DocumentationKind for more
	// information.
	DocumentationKind CrossReferencesRequest_DocumentationKind `protobuf:"varint,4,opt,name=documentation_kind,proto3,enum=kythe.proto.CrossReferencesRequest_DocumentationKind" json:"documentation_kind,omitempty"`
	// Collection of filter globs that determines which facts will be returned for
	// the related nodes of each requested node.  If filter is empty or unset, no
	// node facts or related nodes are returned.  See EdgesRequest for the format
	// of the filter globs.
	Filter []string `protobuf:"bytes,5,rep,name=filter" json:"filter,omitempty"`
	// Determines whether each Anchor in the response should have its text field
	// populated.
	AnchorText bool `protobuf:"varint,6,opt,name=anchor_text,proto3" json:"anchor_text,omitempty"`
	// Determines whether each NodeInfo matching the above filters will have its
	// definition location populated, if known.
	NodeDefinitions bool `protobuf:"varint,8,opt,name=node_definitions,proto3" json:"node_definitions,omitempty"`
	// The cross-references matching a request are organized into logical pages.
	// The size of each page is a number of distinct cross-references
	// (definitions, references, documentation, and related nodes).
	//
	// If page_token is empty, cross-references will be returned starting at the
	// beginning of the sequence; otherwise the starting point named by the
	// page_token will be used.  Legal values of page_token are returned by the
	// server in the next_page_token field of the CrossReferencesReply.  A page
	// token should be treated as an opaque value by the client, and is valid only
	// relative to a particular CrossReferencesRequest.  If an invalid page token
	// is requested, the server will return an error.
	//
	// If page_size > 0, at most that number of cross-references will be returned
	// by the service for this request (see ReferenceSet and CrossReferencesReply
	// below).  If page_size = 0, the default, the server will assume a reasonable
	// default page size.  The server will return an error if page_size < 0.
	//
	// The server is allowed to return fewer cross-references than the requested
	// page_size, even if more are available, save that it must return at least 1
	// edge if any are available at all.
	PageSize  int32  `protobuf:"varint,10,opt,name=page_size,proto3" json:"page_size,omitempty"`
	PageToken string `protobuf:"bytes,11,opt,name=page_token,proto3" json:"page_token,omitempty"`
}

func (m *CrossReferencesRequest) Reset()                    { *m = CrossReferencesRequest{} }
func (m *CrossReferencesRequest) String() string            { return proto.CompactTextString(m) }
func (*CrossReferencesRequest) ProtoMessage()               {}
func (*CrossReferencesRequest) Descriptor() ([]byte, []int) { return fileDescriptorXref, []int{9} }

type Anchor struct {
	// Ticket of the anchor node
	Ticket string `protobuf:"bytes,1,opt,name=ticket,proto3" json:"ticket,omitempty"`
	// Edge kind describing the anchor's relationship with its referenced node
	Kind string `protobuf:"bytes,2,opt,name=kind,proto3" json:"kind,omitempty"`
	// Parent ticket of the anchor; this is the file containing the anchor
	Parent string `protobuf:"bytes,3,opt,name=parent,proto3" json:"parent,omitempty"`
	// Starting location of the anchor within its parent's text
	Start *Location_Point `protobuf:"bytes,4,opt,name=start" json:"start,omitempty"`
	// Ending location of the anchor within its parent's text
	End *Location_Point `protobuf:"bytes,5,opt,name=end" json:"end,omitempty"`
	// The anchor's spanning text within the anchor parent's text
	Text string `protobuf:"bytes,6,opt,name=text,proto3" json:"text,omitempty"`
	// User-readable snippet of the anchor parent's text at the location of this
	// anchor
	Snippet string `protobuf:"bytes,7,opt,name=snippet,proto3" json:"snippet,omitempty"`
	// Starting location of the anchor's snippet within its parent's text
	SnippetStart *Location_Point `protobuf:"bytes,8,opt,name=snippet_start" json:"snippet_start,omitempty"`
	// Ending location of the anchor's snippet within its parent's text
	SnippetEnd *Location_Point `protobuf:"bytes,9,opt,name=snippet_end" json:"snippet_end,omitempty"`
}

func (m *Anchor) Reset()                    { *m = Anchor{} }
func (m *Anchor) String() string            { return proto.CompactTextString(m) }
func (*Anchor) ProtoMessage()               {}
func (*Anchor) Descriptor() ([]byte, []int) { return fileDescriptorXref, []int{10} }

func (m *Anchor) GetStart() *Location_Point {
	if m != nil {
		return m.Start
	}
	return nil
}

func (m *Anchor) GetEnd() *Location_Point {
	if m != nil {
		return m.End
	}
	return nil
}

func (m *Anchor) GetSnippetStart() *Location_Point {
	if m != nil {
		return m.SnippetStart
	}
	return nil
}

func (m *Anchor) GetSnippetEnd() *Location_Point {
	if m != nil {
		return m.SnippetEnd
	}
	return nil
}

type CrossReferencesReply struct {
	// Total number of cross-references on all pages matching requested filters.
	TotalReferences int64 `protobuf:"varint,4,opt,name=total_references,proto3" json:"total_references,omitempty"`
	// Sets of cross-references for each requested node
	CrossReferences map[string]*CrossReferencesReply_CrossReferenceSet `protobuf:"bytes,1,rep,name=cross_references" json:"cross_references,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	// The facts left from the requested filters of the related node facts
	Nodes map[string]*NodeInfo `protobuf:"bytes,2,rep,name=nodes" json:"nodes,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	// Map from the definition tickets referred to in each NodeInfo to their
	// Anchor.  This map will only be returned if the
	// CrossReferencesRequest.node_definitions switch is true.
	DefinitionLocations map[string]*Anchor `protobuf:"bytes,3,rep,name=definition_locations" json:"definition_locations,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value"`
	// If there are additional pages of cross-references after the ones returned
	// in this reply, next_page_token is the page token that may be passed to
	// fetch the next page in sequence after this one.  If there are no additional
	// cross-references, this field will be empty.
	NextPageToken string `protobuf:"bytes,10,opt,name=next_page_token,proto3" json:"next_page_token,omitempty"`
}

func (m *CrossReferencesReply) Reset()                    { *m = CrossReferencesReply{} }
func (m *CrossReferencesReply) String() string            { return proto.CompactTextString(m) }
func (*CrossReferencesReply) ProtoMessage()               {}
func (*CrossReferencesReply) Descriptor() ([]byte, []int) { return fileDescriptorXref, []int{11} }

func (m *CrossReferencesReply) GetCrossReferences() map[string]*CrossReferencesReply_CrossReferenceSet {
	if m != nil {
		return m.CrossReferences
	}
	return nil
}

func (m *CrossReferencesReply) GetNodes() map[string]*NodeInfo {
	if m != nil {
		return m.Nodes
	}
	return nil
}

func (m *CrossReferencesReply) GetDefinitionLocations() map[string]*Anchor {
	if m != nil {
		return m.DefinitionLocations
	}
	return nil
}

type CrossReferencesReply_RelatedNode struct {
	// Ticket of the node
	Ticket string `protobuf:"bytes,1,opt,name=ticket,proto3" json:"ticket,omitempty"`
	// Edge kind describing the node's relation
	RelationKind string `protobuf:"bytes,2,opt,name=relation_kind,proto3" json:"relation_kind,omitempty"`
	// Optional ordinal for edges of the same relation_kind.
	Ordinal int32 `protobuf:"varint,3,opt,name=ordinal,proto3" json:"ordinal,omitempty"`
}

func (m *CrossReferencesReply_RelatedNode) Reset()         { *m = CrossReferencesReply_RelatedNode{} }
func (m *CrossReferencesReply_RelatedNode) String() string { return proto.CompactTextString(m) }
func (*CrossReferencesReply_RelatedNode) ProtoMessage()    {}
func (*CrossReferencesReply_RelatedNode) Descriptor() ([]byte, []int) {
	return fileDescriptorXref, []int{11, 0}
}

type CrossReferencesReply_CrossReferenceSet struct {
	Ticket string `protobuf:"bytes,1,opt,name=ticket,proto3" json:"ticket,omitempty"`
	// The set of definitions for the given node.
	Definition []*Anchor `protobuf:"bytes,2,rep,name=definition" json:"definition,omitempty"`
	// The set of declarations for the given node.
	Declaration []*Anchor `protobuf:"bytes,5,rep,name=declaration" json:"declaration,omitempty"`
	// The set of simple references for the given node.
	Reference []*Anchor `protobuf:"bytes,3,rep,name=reference" json:"reference,omitempty"`
	// The set of documentation for the given node.
	Documentation []*Anchor `protobuf:"bytes,4,rep,name=documentation" json:"documentation,omitempty"`
	// The set of related nodes to the given node.
	RelatedNode []*CrossReferencesReply_RelatedNode `protobuf:"bytes,10,rep,name=related_node" json:"related_node,omitempty"`
}

func (m *CrossReferencesReply_CrossReferenceSet) Reset() {
	*m = CrossReferencesReply_CrossReferenceSet{}
}
func (m *CrossReferencesReply_CrossReferenceSet) String() string { return proto.CompactTextString(m) }
func (*CrossReferencesReply_CrossReferenceSet) ProtoMessage()    {}
func (*CrossReferencesReply_CrossReferenceSet) Descriptor() ([]byte, []int) {
	return fileDescriptorXref, []int{11, 1}
}

func (m *CrossReferencesReply_CrossReferenceSet) GetDefinition() []*Anchor {
	if m != nil {
		return m.Definition
	}
	return nil
}

func (m *CrossReferencesReply_CrossReferenceSet) GetDeclaration() []*Anchor {
	if m != nil {
		return m.Declaration
	}
	return nil
}

func (m *CrossReferencesReply_CrossReferenceSet) GetReference() []*Anchor {
	if m != nil {
		return m.Reference
	}
	return nil
}

func (m *CrossReferencesReply_CrossReferenceSet) GetDocumentation() []*Anchor {
	if m != nil {
		return m.Documentation
	}
	return nil
}

func (m *CrossReferencesReply_CrossReferenceSet) GetRelatedNode() []*CrossReferencesReply_RelatedNode {
	if m != nil {
		return m.RelatedNode
	}
	return nil
}

type CallersRequest struct {
	// A set of semantic tickets. These may refer to nodes that are `callableas`
	// other nodes or they may refer to those specific `callable` nodes. This
	// means that you can use both the target nodes of `ref/call` edges and
	// more common reference or definition edges (like `ref` or
	// `defines/binding`).
	//
	// The Kythe data model defines a `callable` as something that can be the
	// target of a `ref/call` edge. A `callable` has its own identity in the
	// graph and is connected to the nodes it can be called through by a
	// `callableas` edge. A `function` is the most typical node kind that
	// participates in this `callableas` relationship. Other language-level
	// objects that may be sources of `callableas` edges include C++
	// struct/class types that define an operator(), Python classes that
	// define __call__, and so forth.
	//
	// A given node may be `callableas` several different `callable` nodes.
	// For example, if a struct S defines multiple overrides for
	// operator(), it will be `callableas` multiple nodes C0...CN. These
	// nodes will be distinguished by their type signatures. It's better to
	// use `callable` nodes in this set because they make the query more
	// specific.
	SemanticObject []string `protobuf:"bytes,1,rep,name=semantic_object" json:"semantic_object,omitempty"`
	// Expand the semantic_object set by including nodes that participate in
	// an `overrides` relationship (in either direction) with nodes in the set.
	//
	// In the program:
	//   struct A { virtual void f(); };
	//   struct B : public A { void f() override; };
	//   struct C : public B { void f() override; };
	//   void g(B* b) { b->f(); }
	//
	// we would return the following results (for queries on the singleton
	// semantic_object set containing A::f, B::f, or C::f):
	//
	// include_overrides  A::f  B::f  C::f
	//             false    {}   {g}    {}
	//              true   {g}   {g}   {g}
	IncludeOverrides bool `protobuf:"varint,2,opt,name=include_overrides,proto3" json:"include_overrides,omitempty"`
}

func (m *CallersRequest) Reset()                    { *m = CallersRequest{} }
func (m *CallersRequest) String() string            { return proto.CompactTextString(m) }
func (*CallersRequest) ProtoMessage()               {}
func (*CallersRequest) Descriptor() ([]byte, []int) { return fileDescriptorXref, []int{12} }

type CallersReply struct {
	// All objects that were blamed for making calls.
	Caller []*CallersReply_Caller `protobuf:"bytes,1,rep,name=caller" json:"caller,omitempty"`
	// Details for the semantic objects that were passed via a CallersRequest.
	Callee []*CallersReply_CallableDetail `protobuf:"bytes,2,rep,name=callee" json:"callee,omitempty"`
}

func (m *CallersReply) Reset()                    { *m = CallersReply{} }
func (m *CallersReply) String() string            { return proto.CompactTextString(m) }
func (*CallersReply) ProtoMessage()               {}
func (*CallersReply) Descriptor() ([]byte, []int) { return fileDescriptorXref, []int{13} }

func (m *CallersReply) GetCaller() []*CallersReply_Caller {
	if m != nil {
		return m.Caller
	}
	return nil
}

func (m *CallersReply) GetCallee() []*CallersReply_CallableDetail {
	if m != nil {
		return m.Callee
	}
	return nil
}

// Details common to all objects that participate in the call graph.
type CallersReply_CallableDetail struct {
	// The definition site of the object called or being blamed for a call.
	// This would be the "bar" in "void bar()" for calls blamed on bar above
	// and the "foo" in "void foo()" if it refers to foo as a callee.
	Definition *Anchor `protobuf:"bytes,1,opt,name=definition" json:"definition,omitempty"`
	// The ticket of the object that is `callableas` some C. This would refer
	// to the function node for "bar" or "foo". This object may be the target
	// of a `completes` edge (e.g., if the call was made to a definition
	// rather than a declaration).
	SemanticObject string `protobuf:"bytes,2,opt,name=semantic_object,proto3" json:"semantic_object,omitempty"`
	// The ticket of the callable C for semantic_object that was used to service
	// the query.
	SemanticObjectCallable string `protobuf:"bytes,3,opt,name=semantic_object_callable,proto3" json:"semantic_object_callable,omitempty"`
	// The unqualified identifier for this object ("bar" or "foo" above,
	// even if they were defined in some namespace or record). This field
	// should be human-readable and can be displayed in a UI.
	Identifier string `protobuf:"bytes,4,opt,name=identifier,proto3" json:"identifier,omitempty"`
	// An unambiguous (as possible) identifier for this object ("bar()" or
	// "foo()" above; if it was defined in a namespace, "ns::bar()";
	// if it took arguments, "ns::bar(int *, void *)"). This field should
	// be human-readable and can be displayed in a UI.
	DisplayName string `protobuf:"bytes,5,opt,name=display_name,proto3" json:"display_name,omitempty"`
	// The parameters bound by the object referred to by `definition` above.
	// There is no semantic meaning to the order of this array, but it should
	// be reasonable to surface the ordering in a UI (for example, term-level
	// parameters will not be capriciously reordered).
	Parameter []*CallersReply_CallableDetail_Parameter `protobuf:"bytes,6,rep,name=parameter" json:"parameter,omitempty"`
}

func (m *CallersReply_CallableDetail) Reset()         { *m = CallersReply_CallableDetail{} }
func (m *CallersReply_CallableDetail) String() string { return proto.CompactTextString(m) }
func (*CallersReply_CallableDetail) ProtoMessage()    {}
func (*CallersReply_CallableDetail) Descriptor() ([]byte, []int) {
	return fileDescriptorXref, []int{13, 0}
}

func (m *CallersReply_CallableDetail) GetDefinition() *Anchor {
	if m != nil {
		return m.Definition
	}
	return nil
}

func (m *CallersReply_CallableDetail) GetParameter() []*CallersReply_CallableDetail_Parameter {
	if m != nil {
		return m.Parameter
	}
	return nil
}

// A parameter bound by the object referred to by `definition` above.
type CallersReply_CallableDetail_Parameter struct {
	// The parameter's kind.
	Kind CallersReply_CallableDetail_Parameter_Kind `protobuf:"varint,1,opt,name=kind,proto3,enum=kythe.proto.CallersReply_CallableDetail_Parameter_Kind" json:"kind,omitempty"`
	// The parameter's (unqualified) human-readable and displayable name.
	// May be empty. May also be non-unique; for example, the identifiers for
	// the (unnamed in the source language) parameters for the function
	// `void ignore_pair(int, int)` may be "int" and "int".
	Identifier string `protobuf:"bytes,2,opt,name=identifier,proto3" json:"identifier,omitempty"`
	// The ticket that refers to the parameter.
	Ticket string `protobuf:"bytes,3,opt,name=ticket,proto3" json:"ticket,omitempty"`
}

func (m *CallersReply_CallableDetail_Parameter) Reset()         { *m = CallersReply_CallableDetail_Parameter{} }
func (m *CallersReply_CallableDetail_Parameter) String() string { return proto.CompactTextString(m) }
func (*CallersReply_CallableDetail_Parameter) ProtoMessage()    {}
func (*CallersReply_CallableDetail_Parameter) Descriptor() ([]byte, []int) {
	return fileDescriptorXref, []int{13, 0, 0}
}

// An object that was blamed for making a call to an object in the set passed
// to Callers, along with the syntactic locations that caused that blame to
// be cast.
type CallersReply_Caller struct {
	// The object (e.g., a function) responsible for making a call.
	Detail   *CallersReply_CallableDetail    `protobuf:"bytes,1,opt,name=detail" json:"detail,omitempty"`
	CallSite []*CallersReply_Caller_CallSite `protobuf:"bytes,2,rep,name=call_site" json:"call_site,omitempty"`
}

func (m *CallersReply_Caller) Reset()                    { *m = CallersReply_Caller{} }
func (m *CallersReply_Caller) String() string            { return proto.CompactTextString(m) }
func (*CallersReply_Caller) ProtoMessage()               {}
func (*CallersReply_Caller) Descriptor() ([]byte, []int) { return fileDescriptorXref, []int{13, 1} }

func (m *CallersReply_Caller) GetDetail() *CallersReply_CallableDetail {
	if m != nil {
		return m.Detail
	}
	return nil
}

func (m *CallersReply_Caller) GetCallSite() []*CallersReply_Caller_CallSite {
	if m != nil {
		return m.CallSite
	}
	return nil
}

type CallersReply_Caller_CallSite struct {
	// The location where a call was found inside the blamed object.
	Anchor *Anchor `protobuf:"bytes,1,opt,name=anchor" json:"anchor,omitempty"`
	// This field will be set to true iff this call site was included in the
	// results because include_overrides was true in CallersRequest.
	CallToOverride bool `protobuf:"varint,2,opt,name=call_to_override,proto3" json:"call_to_override,omitempty"`
}

func (m *CallersReply_Caller_CallSite) Reset()         { *m = CallersReply_Caller_CallSite{} }
func (m *CallersReply_Caller_CallSite) String() string { return proto.CompactTextString(m) }
func (*CallersReply_Caller_CallSite) ProtoMessage()    {}
func (*CallersReply_Caller_CallSite) Descriptor() ([]byte, []int) {
	return fileDescriptorXref, []int{13, 1, 0}
}

func (m *CallersReply_Caller_CallSite) GetAnchor() *Anchor {
	if m != nil {
		return m.Anchor
	}
	return nil
}

type DocumentationRequest struct {
	// Semantic tickets about which documentation is sought.
	Ticket []string `protobuf:"bytes,1,rep,name=ticket" json:"ticket,omitempty"`
}

func (m *DocumentationRequest) Reset()                    { *m = DocumentationRequest{} }
func (m *DocumentationRequest) String() string            { return proto.CompactTextString(m) }
func (*DocumentationRequest) ProtoMessage()               {}
func (*DocumentationRequest) Descriptor() ([]byte, []int) { return fileDescriptorXref, []int{14} }

type DocumentationReply struct {
	Document []*DocumentationReply_Document `protobuf:"bytes,1,rep,name=document" json:"document,omitempty"`
}

func (m *DocumentationReply) Reset()                    { *m = DocumentationReply{} }
func (m *DocumentationReply) String() string            { return proto.CompactTextString(m) }
func (*DocumentationReply) ProtoMessage()               {}
func (*DocumentationReply) Descriptor() ([]byte, []int) { return fileDescriptorXref, []int{15} }

func (m *DocumentationReply) GetDocument() []*DocumentationReply_Document {
	if m != nil {
		return m.Document
	}
	return nil
}

type DocumentationReply_Link struct {
	// Definition sites found for some ticket.
	Definition []*Anchor `protobuf:"bytes,1,rep,name=definition" json:"definition,omitempty"`
}

func (m *DocumentationReply_Link) Reset()                    { *m = DocumentationReply_Link{} }
func (m *DocumentationReply_Link) String() string            { return proto.CompactTextString(m) }
func (*DocumentationReply_Link) ProtoMessage()               {}
func (*DocumentationReply_Link) Descriptor() ([]byte, []int) { return fileDescriptorXref, []int{15, 0} }

func (m *DocumentationReply_Link) GetDefinition() []*Anchor {
	if m != nil {
		return m.Definition
	}
	return nil
}

type DocumentationReply_Printable struct {
	// Raw text that can be displayed to the user (but may also contain
	// markup that can be interpreted, like Doxygen comments). Links are
	// marked using []. \ is an escape character (where possible escape
	// sequences are \[, \], and \\).
	RawText string `protobuf:"bytes,1,opt,name=raw_text,proto3" json:"raw_text,omitempty"`
	// Destinations for links in raw_text. The ith Link corresponds to the link
	// starting at the ith [.
	Link []*DocumentationReply_Link `protobuf:"bytes,2,rep,name=link" json:"link,omitempty"`
}

func (m *DocumentationReply_Printable) Reset()         { *m = DocumentationReply_Printable{} }
func (m *DocumentationReply_Printable) String() string { return proto.CompactTextString(m) }
func (*DocumentationReply_Printable) ProtoMessage()    {}
func (*DocumentationReply_Printable) Descriptor() ([]byte, []int) {
	return fileDescriptorXref, []int{15, 1}
}

func (m *DocumentationReply_Printable) GetLink() []*DocumentationReply_Link {
	if m != nil {
		return m.Link
	}
	return nil
}

type DocumentationReply_Document struct {
	// The ticket to which this Document refers.
	Ticket string `protobuf:"bytes,1,opt,name=ticket,proto3" json:"ticket,omitempty"`
	// Documentation that can be displayed to the user.
	Text *DocumentationReply_Printable `protobuf:"bytes,2,opt,name=text" json:"text,omitempty"`
	// A signature that can be displayed to the user. For variables, this
	// may just be the variable name; for functions, this may be some version
	// of the function prototype.
	Signature *DocumentationReply_Printable `protobuf:"bytes,3,opt,name=signature" json:"signature,omitempty"`
	// The type as a signature that can be displayed to the user.
	Type *DocumentationReply_Printable `protobuf:"bytes,4,opt,name=type" json:"type,omitempty"`
	// The initialization value, if any.
	Initializer *DocumentationReply_Printable `protobuf:"bytes,5,opt,name=initializer" json:"initializer,omitempty"`
	// The semantic parent of this value.
	DefinedBy *DocumentationReply_Printable `protobuf:"bytes,6,opt,name=defined_by" json:"defined_by,omitempty"`
	// The node kind being defined.
	Kind string `protobuf:"bytes,7,opt,name=kind,proto3" json:"kind,omitempty"`
}

func (m *DocumentationReply_Document) Reset()         { *m = DocumentationReply_Document{} }
func (m *DocumentationReply_Document) String() string { return proto.CompactTextString(m) }
func (*DocumentationReply_Document) ProtoMessage()    {}
func (*DocumentationReply_Document) Descriptor() ([]byte, []int) {
	return fileDescriptorXref, []int{15, 2}
}

func (m *DocumentationReply_Document) GetText() *DocumentationReply_Printable {
	if m != nil {
		return m.Text
	}
	return nil
}

func (m *DocumentationReply_Document) GetSignature() *DocumentationReply_Printable {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *DocumentationReply_Document) GetType() *DocumentationReply_Printable {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *DocumentationReply_Document) GetInitializer() *DocumentationReply_Printable {
	if m != nil {
		return m.Initializer
	}
	return nil
}

func (m *DocumentationReply_Document) GetDefinedBy() *DocumentationReply_Printable {
	if m != nil {
		return m.DefinedBy
	}
	return nil
}

func init() {
	proto.RegisterType((*NodesRequest)(nil), "kythe.proto.NodesRequest")
	proto.RegisterType((*NodeInfo)(nil), "kythe.proto.NodeInfo")
	proto.RegisterType((*NodesReply)(nil), "kythe.proto.NodesReply")
	proto.RegisterType((*EdgesRequest)(nil), "kythe.proto.EdgesRequest")
	proto.RegisterType((*EdgeSet)(nil), "kythe.proto.EdgeSet")
	proto.RegisterType((*EdgeSet_Group)(nil), "kythe.proto.EdgeSet.Group")
	proto.RegisterType((*EdgeSet_Group_Edge)(nil), "kythe.proto.EdgeSet.Group.Edge")
	proto.RegisterType((*EdgesReply)(nil), "kythe.proto.EdgesReply")
	proto.RegisterType((*Location)(nil), "kythe.proto.Location")
	proto.RegisterType((*Location_Point)(nil), "kythe.proto.Location.Point")
	proto.RegisterType((*DecorationsRequest)(nil), "kythe.proto.DecorationsRequest")
	proto.RegisterType((*DecorationsReply)(nil), "kythe.proto.DecorationsReply")
	proto.RegisterType((*DecorationsReply_Reference)(nil), "kythe.proto.DecorationsReply.Reference")
	proto.RegisterType((*CrossReferencesRequest)(nil), "kythe.proto.CrossReferencesRequest")
	proto.RegisterType((*Anchor)(nil), "kythe.proto.Anchor")
	proto.RegisterType((*CrossReferencesReply)(nil), "kythe.proto.CrossReferencesReply")
	proto.RegisterType((*CrossReferencesReply_RelatedNode)(nil), "kythe.proto.CrossReferencesReply.RelatedNode")
	proto.RegisterType((*CrossReferencesReply_CrossReferenceSet)(nil), "kythe.proto.CrossReferencesReply.CrossReferenceSet")
	proto.RegisterType((*CallersRequest)(nil), "kythe.proto.CallersRequest")
	proto.RegisterType((*CallersReply)(nil), "kythe.proto.CallersReply")
	proto.RegisterType((*CallersReply_CallableDetail)(nil), "kythe.proto.CallersReply.CallableDetail")
	proto.RegisterType((*CallersReply_CallableDetail_Parameter)(nil), "kythe.proto.CallersReply.CallableDetail.Parameter")
	proto.RegisterType((*CallersReply_Caller)(nil), "kythe.proto.CallersReply.Caller")
	proto.RegisterType((*CallersReply_Caller_CallSite)(nil), "kythe.proto.CallersReply.Caller.CallSite")
	proto.RegisterType((*DocumentationRequest)(nil), "kythe.proto.DocumentationRequest")
	proto.RegisterType((*DocumentationReply)(nil), "kythe.proto.DocumentationReply")
	proto.RegisterType((*DocumentationReply_Link)(nil), "kythe.proto.DocumentationReply.Link")
	proto.RegisterType((*DocumentationReply_Printable)(nil), "kythe.proto.DocumentationReply.Printable")
	proto.RegisterType((*DocumentationReply_Document)(nil), "kythe.proto.DocumentationReply.Document")
	proto.RegisterEnum("kythe.proto.Location_Kind", Location_Kind_name, Location_Kind_value)
	proto.RegisterEnum("kythe.proto.DecorationsRequest_SpanKind", DecorationsRequest_SpanKind_name, DecorationsRequest_SpanKind_value)
	proto.RegisterEnum("kythe.proto.CrossReferencesRequest_DefinitionKind", CrossReferencesRequest_DefinitionKind_name, CrossReferencesRequest_DefinitionKind_value)
	proto.RegisterEnum("kythe.proto.CrossReferencesRequest_DeclarationKind", CrossReferencesRequest_DeclarationKind_name, CrossReferencesRequest_DeclarationKind_value)
	proto.RegisterEnum("kythe.proto.CrossReferencesRequest_ReferenceKind", CrossReferencesRequest_ReferenceKind_name, CrossReferencesRequest_ReferenceKind_value)
	proto.RegisterEnum("kythe.proto.CrossReferencesRequest_DocumentationKind", CrossReferencesRequest_DocumentationKind_name, CrossReferencesRequest_DocumentationKind_value)
	proto.RegisterEnum("kythe.proto.CallersReply_CallableDetail_Parameter_Kind", CallersReply_CallableDetail_Parameter_Kind_name, CallersReply_CallableDetail_Parameter_Kind_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion2

// Client API for XRefService service

type XRefServiceClient interface {
	// Nodes returns a subset of the facts for each of the requested nodes.
	Nodes(ctx context.Context, in *NodesRequest, opts ...grpc.CallOption) (*NodesReply, error)
	// Edges returns a subset of the outbound edges for each of a set of
	// requested nodes.
	Edges(ctx context.Context, in *EdgesRequest, opts ...grpc.CallOption) (*EdgesReply, error)
	// Decorations returns an index of the nodes and edges associated with a
	// particular file node.
	Decorations(ctx context.Context, in *DecorationsRequest, opts ...grpc.CallOption) (*DecorationsReply, error)
	// CrossReferences returns the global references, definitions, and
	// documentation of a set of requested nodes.
	CrossReferences(ctx context.Context, in *CrossReferencesRequest, opts ...grpc.CallOption) (*CrossReferencesReply, error)
	// Callers takes a set of tickets for semantic objects and returns the set
	// of places where those objects were called. For example, in the program
	//   void bar() { foo(); foo(); } void baz() { foo(); } void foo() { }
	// `Callers({foo})` would return:
	//   {(bar, {first-call-anchor, second-call-anchor}),
	//    (baz, {first-call-anchor})}
	// To walk further up the call graph, you can project the first field of
	// each tuple in the result set ({bar, baz}) and feed that set back in
	// to a new Callers request.
	//
	// The core of this query is specified in terms of graph operations in the
	// Kythe repository at //kythe/docs/schema/callgraph.txt.
	Callers(ctx context.Context, in *CallersRequest, opts ...grpc.CallOption) (*CallersReply, error)
	// Documentation takes a set of tickets for semantic objects and returns
	// documentation about them, including generated signatures and
	// user-provided text. The documentation may refer to tickets for other
	// nodes in the graph.
	Documentation(ctx context.Context, in *DocumentationRequest, opts ...grpc.CallOption) (*DocumentationReply, error)
}

type xRefServiceClient struct {
	cc *grpc.ClientConn
}

func NewXRefServiceClient(cc *grpc.ClientConn) XRefServiceClient {
	return &xRefServiceClient{cc}
}

func (c *xRefServiceClient) Nodes(ctx context.Context, in *NodesRequest, opts ...grpc.CallOption) (*NodesReply, error) {
	out := new(NodesReply)
	err := grpc.Invoke(ctx, "/kythe.proto.XRefService/Nodes", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xRefServiceClient) Edges(ctx context.Context, in *EdgesRequest, opts ...grpc.CallOption) (*EdgesReply, error) {
	out := new(EdgesReply)
	err := grpc.Invoke(ctx, "/kythe.proto.XRefService/Edges", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xRefServiceClient) Decorations(ctx context.Context, in *DecorationsRequest, opts ...grpc.CallOption) (*DecorationsReply, error) {
	out := new(DecorationsReply)
	err := grpc.Invoke(ctx, "/kythe.proto.XRefService/Decorations", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xRefServiceClient) CrossReferences(ctx context.Context, in *CrossReferencesRequest, opts ...grpc.CallOption) (*CrossReferencesReply, error) {
	out := new(CrossReferencesReply)
	err := grpc.Invoke(ctx, "/kythe.proto.XRefService/CrossReferences", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xRefServiceClient) Callers(ctx context.Context, in *CallersRequest, opts ...grpc.CallOption) (*CallersReply, error) {
	out := new(CallersReply)
	err := grpc.Invoke(ctx, "/kythe.proto.XRefService/Callers", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *xRefServiceClient) Documentation(ctx context.Context, in *DocumentationRequest, opts ...grpc.CallOption) (*DocumentationReply, error) {
	out := new(DocumentationReply)
	err := grpc.Invoke(ctx, "/kythe.proto.XRefService/Documentation", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for XRefService service

type XRefServiceServer interface {
	// Nodes returns a subset of the facts for each of the requested nodes.
	Nodes(context.Context, *NodesRequest) (*NodesReply, error)
	// Edges returns a subset of the outbound edges for each of a set of
	// requested nodes.
	Edges(context.Context, *EdgesRequest) (*EdgesReply, error)
	// Decorations returns an index of the nodes and edges associated with a
	// particular file node.
	Decorations(context.Context, *DecorationsRequest) (*DecorationsReply, error)
	// CrossReferences returns the global references, definitions, and
	// documentation of a set of requested nodes.
	CrossReferences(context.Context, *CrossReferencesRequest) (*CrossReferencesReply, error)
	// Callers takes a set of tickets for semantic objects and returns the set
	// of places where those objects were called. For example, in the program
	//   void bar() { foo(); foo(); } void baz() { foo(); } void foo() { }
	// `Callers({foo})` would return:
	//   {(bar, {first-call-anchor, second-call-anchor}),
	//    (baz, {first-call-anchor})}
	// To walk further up the call graph, you can project the first field of
	// each tuple in the result set ({bar, baz}) and feed that set back in
	// to a new Callers request.
	//
	// The core of this query is specified in terms of graph operations in the
	// Kythe repository at //kythe/docs/schema/callgraph.txt.
	Callers(context.Context, *CallersRequest) (*CallersReply, error)
	// Documentation takes a set of tickets for semantic objects and returns
	// documentation about them, including generated signatures and
	// user-provided text. The documentation may refer to tickets for other
	// nodes in the graph.
	Documentation(context.Context, *DocumentationRequest) (*DocumentationReply, error)
}

func RegisterXRefServiceServer(s *grpc.Server, srv XRefServiceServer) {
	s.RegisterService(&_XRefService_serviceDesc, srv)
}

func _XRefService_Nodes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NodesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XRefServiceServer).Nodes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kythe.proto.XRefService/Nodes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XRefServiceServer).Nodes(ctx, req.(*NodesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _XRefService_Edges_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(EdgesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XRefServiceServer).Edges(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kythe.proto.XRefService/Edges",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XRefServiceServer).Edges(ctx, req.(*EdgesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _XRefService_Decorations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DecorationsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XRefServiceServer).Decorations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kythe.proto.XRefService/Decorations",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XRefServiceServer).Decorations(ctx, req.(*DecorationsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _XRefService_CrossReferences_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CrossReferencesRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XRefServiceServer).CrossReferences(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kythe.proto.XRefService/CrossReferences",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XRefServiceServer).CrossReferences(ctx, req.(*CrossReferencesRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _XRefService_Callers_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CallersRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XRefServiceServer).Callers(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kythe.proto.XRefService/Callers",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XRefServiceServer).Callers(ctx, req.(*CallersRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _XRefService_Documentation_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(DocumentationRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(XRefServiceServer).Documentation(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kythe.proto.XRefService/Documentation",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(XRefServiceServer).Documentation(ctx, req.(*DocumentationRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _XRefService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "kythe.proto.XRefService",
	HandlerType: (*XRefServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Nodes",
			Handler:    _XRefService_Nodes_Handler,
		},
		{
			MethodName: "Edges",
			Handler:    _XRefService_Edges_Handler,
		},
		{
			MethodName: "Decorations",
			Handler:    _XRefService_Decorations_Handler,
		},
		{
			MethodName: "CrossReferences",
			Handler:    _XRefService_CrossReferences_Handler,
		},
		{
			MethodName: "Callers",
			Handler:    _XRefService_Callers_Handler,
		},
		{
			MethodName: "Documentation",
			Handler:    _XRefService_Documentation_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

func (m *NodesRequest) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *NodesRequest) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ticket) > 0 {
		for _, s := range m.Ticket {
			data[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if len(m.Filter) > 0 {
		for _, s := range m.Filter {
			data[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	return i, nil
}

func (m *NodeInfo) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *NodeInfo) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Facts) > 0 {
		for k, _ := range m.Facts {
			data[i] = 0x12
			i++
			v := m.Facts[k]
			mapSize := 1 + len(k) + sovXref(uint64(len(k))) + 1 + len(v) + sovXref(uint64(len(v)))
			i = encodeVarintXref(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintXref(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			data[i] = 0x12
			i++
			i = encodeVarintXref(data, i, uint64(len(v)))
			i += copy(data[i:], v)
		}
	}
	if len(m.Definition) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintXref(data, i, uint64(len(m.Definition)))
		i += copy(data[i:], m.Definition)
	}
	return i, nil
}

func (m *NodesReply) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *NodesReply) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Nodes) > 0 {
		for k, _ := range m.Nodes {
			data[i] = 0xa
			i++
			v := m.Nodes[k]
			if v == nil {
				return 0, errors.New("proto: map has nil element")
			}
			msgSize := v.Size()
			mapSize := 1 + len(k) + sovXref(uint64(len(k))) + 1 + msgSize + sovXref(uint64(msgSize))
			i = encodeVarintXref(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintXref(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			data[i] = 0x12
			i++
			i = encodeVarintXref(data, i, uint64(v.Size()))
			n1, err := v.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n1
		}
	}
	return i, nil
}

func (m *EdgesRequest) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *EdgesRequest) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ticket) > 0 {
		for _, s := range m.Ticket {
			data[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if len(m.Kind) > 0 {
		for _, s := range m.Kind {
			data[i] = 0x12
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if len(m.Filter) > 0 {
		for _, s := range m.Filter {
			data[i] = 0x1a
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if m.PageSize != 0 {
		data[i] = 0x40
		i++
		i = encodeVarintXref(data, i, uint64(m.PageSize))
	}
	if len(m.PageToken) > 0 {
		data[i] = 0x4a
		i++
		i = encodeVarintXref(data, i, uint64(len(m.PageToken)))
		i += copy(data[i:], m.PageToken)
	}
	return i, nil
}

func (m *EdgeSet) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *EdgeSet) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Groups) > 0 {
		for k, _ := range m.Groups {
			data[i] = 0x12
			i++
			v := m.Groups[k]
			if v == nil {
				return 0, errors.New("proto: map has nil element")
			}
			msgSize := v.Size()
			mapSize := 1 + len(k) + sovXref(uint64(len(k))) + 1 + msgSize + sovXref(uint64(msgSize))
			i = encodeVarintXref(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintXref(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			data[i] = 0x12
			i++
			i = encodeVarintXref(data, i, uint64(v.Size()))
			n2, err := v.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n2
		}
	}
	return i, nil
}

func (m *EdgeSet_Group) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *EdgeSet_Group) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Edge) > 0 {
		for _, msg := range m.Edge {
			data[i] = 0x12
			i++
			i = encodeVarintXref(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *EdgeSet_Group_Edge) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *EdgeSet_Group_Edge) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.TargetTicket) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintXref(data, i, uint64(len(m.TargetTicket)))
		i += copy(data[i:], m.TargetTicket)
	}
	if m.Ordinal != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintXref(data, i, uint64(m.Ordinal))
	}
	return i, nil
}

func (m *EdgesReply) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *EdgesReply) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.EdgeSets) > 0 {
		for k, _ := range m.EdgeSets {
			data[i] = 0xa
			i++
			v := m.EdgeSets[k]
			if v == nil {
				return 0, errors.New("proto: map has nil element")
			}
			msgSize := v.Size()
			mapSize := 1 + len(k) + sovXref(uint64(len(k))) + 1 + msgSize + sovXref(uint64(msgSize))
			i = encodeVarintXref(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintXref(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			data[i] = 0x12
			i++
			i = encodeVarintXref(data, i, uint64(v.Size()))
			n3, err := v.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n3
		}
	}
	if len(m.Nodes) > 0 {
		for k, _ := range m.Nodes {
			data[i] = 0x12
			i++
			v := m.Nodes[k]
			if v == nil {
				return 0, errors.New("proto: map has nil element")
			}
			msgSize := v.Size()
			mapSize := 1 + len(k) + sovXref(uint64(len(k))) + 1 + msgSize + sovXref(uint64(msgSize))
			i = encodeVarintXref(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintXref(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			data[i] = 0x12
			i++
			i = encodeVarintXref(data, i, uint64(v.Size()))
			n4, err := v.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n4
		}
	}
	if m.TotalEdges != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintXref(data, i, uint64(m.TotalEdges))
	}
	if len(m.NextPageToken) > 0 {
		data[i] = 0x4a
		i++
		i = encodeVarintXref(data, i, uint64(len(m.NextPageToken)))
		i += copy(data[i:], m.NextPageToken)
	}
	return i, nil
}

func (m *Location) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Location) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ticket) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintXref(data, i, uint64(len(m.Ticket)))
		i += copy(data[i:], m.Ticket)
	}
	if m.Kind != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintXref(data, i, uint64(m.Kind))
	}
	if m.Start != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintXref(data, i, uint64(m.Start.Size()))
		n5, err := m.Start.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.End != nil {
		data[i] = 0x22
		i++
		i = encodeVarintXref(data, i, uint64(m.End.Size()))
		n6, err := m.End.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	return i, nil
}

func (m *Location_Point) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Location_Point) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.ByteOffset != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintXref(data, i, uint64(m.ByteOffset))
	}
	if m.LineNumber != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintXref(data, i, uint64(m.LineNumber))
	}
	if m.ColumnOffset != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintXref(data, i, uint64(m.ColumnOffset))
	}
	return i, nil
}

func (m *DecorationsRequest) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DecorationsRequest) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Location != nil {
		data[i] = 0xa
		i++
		i = encodeVarintXref(data, i, uint64(m.Location.Size()))
		n7, err := m.Location.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if len(m.DirtyBuffer) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintXref(data, i, uint64(len(m.DirtyBuffer)))
		i += copy(data[i:], m.DirtyBuffer)
	}
	if m.SourceText {
		data[i] = 0x18
		i++
		if m.SourceText {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.References {
		data[i] = 0x20
		i++
		if m.References {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if len(m.Filter) > 0 {
		for _, s := range m.Filter {
			data[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if m.TargetDefinitions {
		data[i] = 0x30
		i++
		if m.TargetDefinitions {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.SpanKind != 0 {
		data[i] = 0x50
		i++
		i = encodeVarintXref(data, i, uint64(m.SpanKind))
	}
	return i, nil
}

func (m *DecorationsReply) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DecorationsReply) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Location != nil {
		data[i] = 0xa
		i++
		i = encodeVarintXref(data, i, uint64(m.Location.Size()))
		n8, err := m.Location.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	if len(m.SourceText) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintXref(data, i, uint64(len(m.SourceText)))
		i += copy(data[i:], m.SourceText)
	}
	if len(m.Encoding) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintXref(data, i, uint64(len(m.Encoding)))
		i += copy(data[i:], m.Encoding)
	}
	if len(m.Reference) > 0 {
		for _, msg := range m.Reference {
			data[i] = 0x22
			i++
			i = encodeVarintXref(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Nodes) > 0 {
		for k, _ := range m.Nodes {
			data[i] = 0x7a
			i++
			v := m.Nodes[k]
			if v == nil {
				return 0, errors.New("proto: map has nil element")
			}
			msgSize := v.Size()
			mapSize := 1 + len(k) + sovXref(uint64(len(k))) + 1 + msgSize + sovXref(uint64(msgSize))
			i = encodeVarintXref(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintXref(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			data[i] = 0x12
			i++
			i = encodeVarintXref(data, i, uint64(v.Size()))
			n9, err := v.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n9
		}
	}
	if len(m.DefinitionLocations) > 0 {
		for k, _ := range m.DefinitionLocations {
			data[i] = 0x82
			i++
			data[i] = 0x1
			i++
			v := m.DefinitionLocations[k]
			if v == nil {
				return 0, errors.New("proto: map has nil element")
			}
			msgSize := v.Size()
			mapSize := 1 + len(k) + sovXref(uint64(len(k))) + 1 + msgSize + sovXref(uint64(msgSize))
			i = encodeVarintXref(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintXref(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			data[i] = 0x12
			i++
			i = encodeVarintXref(data, i, uint64(v.Size()))
			n10, err := v.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n10
		}
	}
	return i, nil
}

func (m *DecorationsReply_Reference) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DecorationsReply_Reference) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SourceTicket) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintXref(data, i, uint64(len(m.SourceTicket)))
		i += copy(data[i:], m.SourceTicket)
	}
	if len(m.TargetTicket) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintXref(data, i, uint64(len(m.TargetTicket)))
		i += copy(data[i:], m.TargetTicket)
	}
	if len(m.Kind) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintXref(data, i, uint64(len(m.Kind)))
		i += copy(data[i:], m.Kind)
	}
	if len(m.TargetDefinition) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintXref(data, i, uint64(len(m.TargetDefinition)))
		i += copy(data[i:], m.TargetDefinition)
	}
	if m.AnchorStart != nil {
		data[i] = 0x52
		i++
		i = encodeVarintXref(data, i, uint64(m.AnchorStart.Size()))
		n11, err := m.AnchorStart.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n11
	}
	if m.AnchorEnd != nil {
		data[i] = 0x5a
		i++
		i = encodeVarintXref(data, i, uint64(m.AnchorEnd.Size()))
		n12, err := m.AnchorEnd.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n12
	}
	return i, nil
}

func (m *CrossReferencesRequest) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CrossReferencesRequest) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ticket) > 0 {
		for _, s := range m.Ticket {
			data[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if m.DefinitionKind != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintXref(data, i, uint64(m.DefinitionKind))
	}
	if m.ReferenceKind != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintXref(data, i, uint64(m.ReferenceKind))
	}
	if m.DocumentationKind != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintXref(data, i, uint64(m.DocumentationKind))
	}
	if len(m.Filter) > 0 {
		for _, s := range m.Filter {
			data[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if m.AnchorText {
		data[i] = 0x30
		i++
		if m.AnchorText {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.DeclarationKind != 0 {
		data[i] = 0x38
		i++
		i = encodeVarintXref(data, i, uint64(m.DeclarationKind))
	}
	if m.NodeDefinitions {
		data[i] = 0x40
		i++
		if m.NodeDefinitions {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.PageSize != 0 {
		data[i] = 0x50
		i++
		i = encodeVarintXref(data, i, uint64(m.PageSize))
	}
	if len(m.PageToken) > 0 {
		data[i] = 0x5a
		i++
		i = encodeVarintXref(data, i, uint64(len(m.PageToken)))
		i += copy(data[i:], m.PageToken)
	}
	return i, nil
}

func (m *Anchor) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Anchor) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ticket) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintXref(data, i, uint64(len(m.Ticket)))
		i += copy(data[i:], m.Ticket)
	}
	if len(m.Kind) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintXref(data, i, uint64(len(m.Kind)))
		i += copy(data[i:], m.Kind)
	}
	if len(m.Parent) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintXref(data, i, uint64(len(m.Parent)))
		i += copy(data[i:], m.Parent)
	}
	if m.Start != nil {
		data[i] = 0x22
		i++
		i = encodeVarintXref(data, i, uint64(m.Start.Size()))
		n13, err := m.Start.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n13
	}
	if m.End != nil {
		data[i] = 0x2a
		i++
		i = encodeVarintXref(data, i, uint64(m.End.Size()))
		n14, err := m.End.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n14
	}
	if len(m.Text) > 0 {
		data[i] = 0x32
		i++
		i = encodeVarintXref(data, i, uint64(len(m.Text)))
		i += copy(data[i:], m.Text)
	}
	if len(m.Snippet) > 0 {
		data[i] = 0x3a
		i++
		i = encodeVarintXref(data, i, uint64(len(m.Snippet)))
		i += copy(data[i:], m.Snippet)
	}
	if m.SnippetStart != nil {
		data[i] = 0x42
		i++
		i = encodeVarintXref(data, i, uint64(m.SnippetStart.Size()))
		n15, err := m.SnippetStart.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n15
	}
	if m.SnippetEnd != nil {
		data[i] = 0x4a
		i++
		i = encodeVarintXref(data, i, uint64(m.SnippetEnd.Size()))
		n16, err := m.SnippetEnd.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n16
	}
	return i, nil
}

func (m *CrossReferencesReply) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CrossReferencesReply) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.CrossReferences) > 0 {
		for k, _ := range m.CrossReferences {
			data[i] = 0xa
			i++
			v := m.CrossReferences[k]
			if v == nil {
				return 0, errors.New("proto: map has nil element")
			}
			msgSize := v.Size()
			mapSize := 1 + len(k) + sovXref(uint64(len(k))) + 1 + msgSize + sovXref(uint64(msgSize))
			i = encodeVarintXref(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintXref(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			data[i] = 0x12
			i++
			i = encodeVarintXref(data, i, uint64(v.Size()))
			n17, err := v.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n17
		}
	}
	if len(m.Nodes) > 0 {
		for k, _ := range m.Nodes {
			data[i] = 0x12
			i++
			v := m.Nodes[k]
			if v == nil {
				return 0, errors.New("proto: map has nil element")
			}
			msgSize := v.Size()
			mapSize := 1 + len(k) + sovXref(uint64(len(k))) + 1 + msgSize + sovXref(uint64(msgSize))
			i = encodeVarintXref(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintXref(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			data[i] = 0x12
			i++
			i = encodeVarintXref(data, i, uint64(v.Size()))
			n18, err := v.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n18
		}
	}
	if len(m.DefinitionLocations) > 0 {
		for k, _ := range m.DefinitionLocations {
			data[i] = 0x1a
			i++
			v := m.DefinitionLocations[k]
			if v == nil {
				return 0, errors.New("proto: map has nil element")
			}
			msgSize := v.Size()
			mapSize := 1 + len(k) + sovXref(uint64(len(k))) + 1 + msgSize + sovXref(uint64(msgSize))
			i = encodeVarintXref(data, i, uint64(mapSize))
			data[i] = 0xa
			i++
			i = encodeVarintXref(data, i, uint64(len(k)))
			i += copy(data[i:], k)
			data[i] = 0x12
			i++
			i = encodeVarintXref(data, i, uint64(v.Size()))
			n19, err := v.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n19
		}
	}
	if m.TotalReferences != 0 {
		data[i] = 0x20
		i++
		i = encodeVarintXref(data, i, uint64(m.TotalReferences))
	}
	if len(m.NextPageToken) > 0 {
		data[i] = 0x52
		i++
		i = encodeVarintXref(data, i, uint64(len(m.NextPageToken)))
		i += copy(data[i:], m.NextPageToken)
	}
	return i, nil
}

func (m *CrossReferencesReply_RelatedNode) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CrossReferencesReply_RelatedNode) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ticket) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintXref(data, i, uint64(len(m.Ticket)))
		i += copy(data[i:], m.Ticket)
	}
	if len(m.RelationKind) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintXref(data, i, uint64(len(m.RelationKind)))
		i += copy(data[i:], m.RelationKind)
	}
	if m.Ordinal != 0 {
		data[i] = 0x18
		i++
		i = encodeVarintXref(data, i, uint64(m.Ordinal))
	}
	return i, nil
}

func (m *CrossReferencesReply_CrossReferenceSet) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CrossReferencesReply_CrossReferenceSet) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ticket) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintXref(data, i, uint64(len(m.Ticket)))
		i += copy(data[i:], m.Ticket)
	}
	if len(m.Definition) > 0 {
		for _, msg := range m.Definition {
			data[i] = 0x12
			i++
			i = encodeVarintXref(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Reference) > 0 {
		for _, msg := range m.Reference {
			data[i] = 0x1a
			i++
			i = encodeVarintXref(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Documentation) > 0 {
		for _, msg := range m.Documentation {
			data[i] = 0x22
			i++
			i = encodeVarintXref(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Declaration) > 0 {
		for _, msg := range m.Declaration {
			data[i] = 0x2a
			i++
			i = encodeVarintXref(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.RelatedNode) > 0 {
		for _, msg := range m.RelatedNode {
			data[i] = 0x52
			i++
			i = encodeVarintXref(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CallersRequest) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CallersRequest) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SemanticObject) > 0 {
		for _, s := range m.SemanticObject {
			data[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if m.IncludeOverrides {
		data[i] = 0x10
		i++
		if m.IncludeOverrides {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *CallersReply) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CallersReply) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Caller) > 0 {
		for _, msg := range m.Caller {
			data[i] = 0xa
			i++
			i = encodeVarintXref(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Callee) > 0 {
		for _, msg := range m.Callee {
			data[i] = 0x12
			i++
			i = encodeVarintXref(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CallersReply_CallableDetail) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CallersReply_CallableDetail) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Definition != nil {
		data[i] = 0xa
		i++
		i = encodeVarintXref(data, i, uint64(m.Definition.Size()))
		n20, err := m.Definition.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n20
	}
	if len(m.SemanticObject) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintXref(data, i, uint64(len(m.SemanticObject)))
		i += copy(data[i:], m.SemanticObject)
	}
	if len(m.SemanticObjectCallable) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintXref(data, i, uint64(len(m.SemanticObjectCallable)))
		i += copy(data[i:], m.SemanticObjectCallable)
	}
	if len(m.Identifier) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintXref(data, i, uint64(len(m.Identifier)))
		i += copy(data[i:], m.Identifier)
	}
	if len(m.DisplayName) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintXref(data, i, uint64(len(m.DisplayName)))
		i += copy(data[i:], m.DisplayName)
	}
	if len(m.Parameter) > 0 {
		for _, msg := range m.Parameter {
			data[i] = 0x32
			i++
			i = encodeVarintXref(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CallersReply_CallableDetail_Parameter) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CallersReply_CallableDetail_Parameter) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Kind != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintXref(data, i, uint64(m.Kind))
	}
	if len(m.Identifier) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintXref(data, i, uint64(len(m.Identifier)))
		i += copy(data[i:], m.Identifier)
	}
	if len(m.Ticket) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintXref(data, i, uint64(len(m.Ticket)))
		i += copy(data[i:], m.Ticket)
	}
	return i, nil
}

func (m *CallersReply_Caller) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CallersReply_Caller) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Detail != nil {
		data[i] = 0xa
		i++
		i = encodeVarintXref(data, i, uint64(m.Detail.Size()))
		n21, err := m.Detail.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n21
	}
	if len(m.CallSite) > 0 {
		for _, msg := range m.CallSite {
			data[i] = 0x12
			i++
			i = encodeVarintXref(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CallersReply_Caller_CallSite) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CallersReply_Caller_CallSite) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Anchor != nil {
		data[i] = 0xa
		i++
		i = encodeVarintXref(data, i, uint64(m.Anchor.Size()))
		n22, err := m.Anchor.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n22
	}
	if m.CallToOverride {
		data[i] = 0x10
		i++
		if m.CallToOverride {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *DocumentationRequest) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DocumentationRequest) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ticket) > 0 {
		for _, s := range m.Ticket {
			data[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	return i, nil
}

func (m *DocumentationReply) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DocumentationReply) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Document) > 0 {
		for _, msg := range m.Document {
			data[i] = 0xa
			i++
			i = encodeVarintXref(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *DocumentationReply_Link) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DocumentationReply_Link) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Definition) > 0 {
		for _, msg := range m.Definition {
			data[i] = 0xa
			i++
			i = encodeVarintXref(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *DocumentationReply_Printable) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DocumentationReply_Printable) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.RawText) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintXref(data, i, uint64(len(m.RawText)))
		i += copy(data[i:], m.RawText)
	}
	if len(m.Link) > 0 {
		for _, msg := range m.Link {
			data[i] = 0x12
			i++
			i = encodeVarintXref(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *DocumentationReply_Document) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *DocumentationReply_Document) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ticket) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintXref(data, i, uint64(len(m.Ticket)))
		i += copy(data[i:], m.Ticket)
	}
	if m.Text != nil {
		data[i] = 0x12
		i++
		i = encodeVarintXref(data, i, uint64(m.Text.Size()))
		n23, err := m.Text.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n23
	}
	if m.Signature != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintXref(data, i, uint64(m.Signature.Size()))
		n24, err := m.Signature.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n24
	}
	if m.Type != nil {
		data[i] = 0x22
		i++
		i = encodeVarintXref(data, i, uint64(m.Type.Size()))
		n25, err := m.Type.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n25
	}
	if m.Initializer != nil {
		data[i] = 0x2a
		i++
		i = encodeVarintXref(data, i, uint64(m.Initializer.Size()))
		n26, err := m.Initializer.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n26
	}
	if m.DefinedBy != nil {
		data[i] = 0x32
		i++
		i = encodeVarintXref(data, i, uint64(m.DefinedBy.Size()))
		n27, err := m.DefinedBy.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n27
	}
	if len(m.Kind) > 0 {
		data[i] = 0x3a
		i++
		i = encodeVarintXref(data, i, uint64(len(m.Kind)))
		i += copy(data[i:], m.Kind)
	}
	return i, nil
}

func encodeFixed64Xref(data []byte, offset int, v uint64) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	data[offset+4] = uint8(v >> 32)
	data[offset+5] = uint8(v >> 40)
	data[offset+6] = uint8(v >> 48)
	data[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Xref(data []byte, offset int, v uint32) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintXref(data []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		data[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	data[offset] = uint8(v)
	return offset + 1
}
func (m *NodesRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.Ticket) > 0 {
		for _, s := range m.Ticket {
			l = len(s)
			n += 1 + l + sovXref(uint64(l))
		}
	}
	if len(m.Filter) > 0 {
		for _, s := range m.Filter {
			l = len(s)
			n += 1 + l + sovXref(uint64(l))
		}
	}
	return n
}

func (m *NodeInfo) Size() (n int) {
	var l int
	_ = l
	if len(m.Facts) > 0 {
		for k, v := range m.Facts {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovXref(uint64(len(k))) + 1 + len(v) + sovXref(uint64(len(v)))
			n += mapEntrySize + 1 + sovXref(uint64(mapEntrySize))
		}
	}
	l = len(m.Definition)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	return n
}

func (m *NodesReply) Size() (n int) {
	var l int
	_ = l
	if len(m.Nodes) > 0 {
		for k, v := range m.Nodes {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
			}
			mapEntrySize := 1 + len(k) + sovXref(uint64(len(k))) + 1 + l + sovXref(uint64(l))
			n += mapEntrySize + 1 + sovXref(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *EdgesRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.Ticket) > 0 {
		for _, s := range m.Ticket {
			l = len(s)
			n += 1 + l + sovXref(uint64(l))
		}
	}
	if len(m.Kind) > 0 {
		for _, s := range m.Kind {
			l = len(s)
			n += 1 + l + sovXref(uint64(l))
		}
	}
	if len(m.Filter) > 0 {
		for _, s := range m.Filter {
			l = len(s)
			n += 1 + l + sovXref(uint64(l))
		}
	}
	if m.PageSize != 0 {
		n += 1 + sovXref(uint64(m.PageSize))
	}
	l = len(m.PageToken)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	return n
}

func (m *EdgeSet) Size() (n int) {
	var l int
	_ = l
	if len(m.Groups) > 0 {
		for k, v := range m.Groups {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
			}
			mapEntrySize := 1 + len(k) + sovXref(uint64(len(k))) + 1 + l + sovXref(uint64(l))
			n += mapEntrySize + 1 + sovXref(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *EdgeSet_Group) Size() (n int) {
	var l int
	_ = l
	if len(m.Edge) > 0 {
		for _, e := range m.Edge {
			l = e.Size()
			n += 1 + l + sovXref(uint64(l))
		}
	}
	return n
}

func (m *EdgeSet_Group_Edge) Size() (n int) {
	var l int
	_ = l
	l = len(m.TargetTicket)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	if m.Ordinal != 0 {
		n += 1 + sovXref(uint64(m.Ordinal))
	}
	return n
}

func (m *EdgesReply) Size() (n int) {
	var l int
	_ = l
	if len(m.EdgeSets) > 0 {
		for k, v := range m.EdgeSets {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
			}
			mapEntrySize := 1 + len(k) + sovXref(uint64(len(k))) + 1 + l + sovXref(uint64(l))
			n += mapEntrySize + 1 + sovXref(uint64(mapEntrySize))
		}
	}
	if len(m.Nodes) > 0 {
		for k, v := range m.Nodes {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
			}
			mapEntrySize := 1 + len(k) + sovXref(uint64(len(k))) + 1 + l + sovXref(uint64(l))
			n += mapEntrySize + 1 + sovXref(uint64(mapEntrySize))
		}
	}
	if m.TotalEdges != 0 {
		n += 1 + sovXref(uint64(m.TotalEdges))
	}
	l = len(m.NextPageToken)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	return n
}

func (m *Location) Size() (n int) {
	var l int
	_ = l
	l = len(m.Ticket)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	if m.Kind != 0 {
		n += 1 + sovXref(uint64(m.Kind))
	}
	if m.Start != nil {
		l = m.Start.Size()
		n += 1 + l + sovXref(uint64(l))
	}
	if m.End != nil {
		l = m.End.Size()
		n += 1 + l + sovXref(uint64(l))
	}
	return n
}

func (m *Location_Point) Size() (n int) {
	var l int
	_ = l
	if m.ByteOffset != 0 {
		n += 1 + sovXref(uint64(m.ByteOffset))
	}
	if m.LineNumber != 0 {
		n += 1 + sovXref(uint64(m.LineNumber))
	}
	if m.ColumnOffset != 0 {
		n += 1 + sovXref(uint64(m.ColumnOffset))
	}
	return n
}

func (m *DecorationsRequest) Size() (n int) {
	var l int
	_ = l
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovXref(uint64(l))
	}
	l = len(m.DirtyBuffer)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	if m.SourceText {
		n += 2
	}
	if m.References {
		n += 2
	}
	if len(m.Filter) > 0 {
		for _, s := range m.Filter {
			l = len(s)
			n += 1 + l + sovXref(uint64(l))
		}
	}
	if m.TargetDefinitions {
		n += 2
	}
	if m.SpanKind != 0 {
		n += 1 + sovXref(uint64(m.SpanKind))
	}
	return n
}

func (m *DecorationsReply) Size() (n int) {
	var l int
	_ = l
	if m.Location != nil {
		l = m.Location.Size()
		n += 1 + l + sovXref(uint64(l))
	}
	l = len(m.SourceText)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	l = len(m.Encoding)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	if len(m.Reference) > 0 {
		for _, e := range m.Reference {
			l = e.Size()
			n += 1 + l + sovXref(uint64(l))
		}
	}
	if len(m.Nodes) > 0 {
		for k, v := range m.Nodes {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
			}
			mapEntrySize := 1 + len(k) + sovXref(uint64(len(k))) + 1 + l + sovXref(uint64(l))
			n += mapEntrySize + 1 + sovXref(uint64(mapEntrySize))
		}
	}
	if len(m.DefinitionLocations) > 0 {
		for k, v := range m.DefinitionLocations {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
			}
			mapEntrySize := 1 + len(k) + sovXref(uint64(len(k))) + 1 + l + sovXref(uint64(l))
			n += mapEntrySize + 2 + sovXref(uint64(mapEntrySize))
		}
	}
	return n
}

func (m *DecorationsReply_Reference) Size() (n int) {
	var l int
	_ = l
	l = len(m.SourceTicket)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	l = len(m.TargetTicket)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	l = len(m.TargetDefinition)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	if m.AnchorStart != nil {
		l = m.AnchorStart.Size()
		n += 1 + l + sovXref(uint64(l))
	}
	if m.AnchorEnd != nil {
		l = m.AnchorEnd.Size()
		n += 1 + l + sovXref(uint64(l))
	}
	return n
}

func (m *CrossReferencesRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.Ticket) > 0 {
		for _, s := range m.Ticket {
			l = len(s)
			n += 1 + l + sovXref(uint64(l))
		}
	}
	if m.DefinitionKind != 0 {
		n += 1 + sovXref(uint64(m.DefinitionKind))
	}
	if m.ReferenceKind != 0 {
		n += 1 + sovXref(uint64(m.ReferenceKind))
	}
	if m.DocumentationKind != 0 {
		n += 1 + sovXref(uint64(m.DocumentationKind))
	}
	if len(m.Filter) > 0 {
		for _, s := range m.Filter {
			l = len(s)
			n += 1 + l + sovXref(uint64(l))
		}
	}
	if m.AnchorText {
		n += 2
	}
	if m.DeclarationKind != 0 {
		n += 1 + sovXref(uint64(m.DeclarationKind))
	}
	if m.NodeDefinitions {
		n += 2
	}
	if m.PageSize != 0 {
		n += 1 + sovXref(uint64(m.PageSize))
	}
	l = len(m.PageToken)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	return n
}

func (m *Anchor) Size() (n int) {
	var l int
	_ = l
	l = len(m.Ticket)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	l = len(m.Parent)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	if m.Start != nil {
		l = m.Start.Size()
		n += 1 + l + sovXref(uint64(l))
	}
	if m.End != nil {
		l = m.End.Size()
		n += 1 + l + sovXref(uint64(l))
	}
	l = len(m.Text)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	l = len(m.Snippet)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	if m.SnippetStart != nil {
		l = m.SnippetStart.Size()
		n += 1 + l + sovXref(uint64(l))
	}
	if m.SnippetEnd != nil {
		l = m.SnippetEnd.Size()
		n += 1 + l + sovXref(uint64(l))
	}
	return n
}

func (m *CrossReferencesReply) Size() (n int) {
	var l int
	_ = l
	if len(m.CrossReferences) > 0 {
		for k, v := range m.CrossReferences {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
			}
			mapEntrySize := 1 + len(k) + sovXref(uint64(len(k))) + 1 + l + sovXref(uint64(l))
			n += mapEntrySize + 1 + sovXref(uint64(mapEntrySize))
		}
	}
	if len(m.Nodes) > 0 {
		for k, v := range m.Nodes {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
			}
			mapEntrySize := 1 + len(k) + sovXref(uint64(len(k))) + 1 + l + sovXref(uint64(l))
			n += mapEntrySize + 1 + sovXref(uint64(mapEntrySize))
		}
	}
	if len(m.DefinitionLocations) > 0 {
		for k, v := range m.DefinitionLocations {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
			}
			mapEntrySize := 1 + len(k) + sovXref(uint64(len(k))) + 1 + l + sovXref(uint64(l))
			n += mapEntrySize + 1 + sovXref(uint64(mapEntrySize))
		}
	}
	if m.TotalReferences != 0 {
		n += 1 + sovXref(uint64(m.TotalReferences))
	}
	l = len(m.NextPageToken)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	return n
}

func (m *CrossReferencesReply_RelatedNode) Size() (n int) {
	var l int
	_ = l
	l = len(m.Ticket)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	l = len(m.RelationKind)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	if m.Ordinal != 0 {
		n += 1 + sovXref(uint64(m.Ordinal))
	}
	return n
}

func (m *CrossReferencesReply_CrossReferenceSet) Size() (n int) {
	var l int
	_ = l
	l = len(m.Ticket)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	if len(m.Definition) > 0 {
		for _, e := range m.Definition {
			l = e.Size()
			n += 1 + l + sovXref(uint64(l))
		}
	}
	if len(m.Reference) > 0 {
		for _, e := range m.Reference {
			l = e.Size()
			n += 1 + l + sovXref(uint64(l))
		}
	}
	if len(m.Documentation) > 0 {
		for _, e := range m.Documentation {
			l = e.Size()
			n += 1 + l + sovXref(uint64(l))
		}
	}
	if len(m.Declaration) > 0 {
		for _, e := range m.Declaration {
			l = e.Size()
			n += 1 + l + sovXref(uint64(l))
		}
	}
	if len(m.RelatedNode) > 0 {
		for _, e := range m.RelatedNode {
			l = e.Size()
			n += 1 + l + sovXref(uint64(l))
		}
	}
	return n
}

func (m *CallersRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.SemanticObject) > 0 {
		for _, s := range m.SemanticObject {
			l = len(s)
			n += 1 + l + sovXref(uint64(l))
		}
	}
	if m.IncludeOverrides {
		n += 2
	}
	return n
}

func (m *CallersReply) Size() (n int) {
	var l int
	_ = l
	if len(m.Caller) > 0 {
		for _, e := range m.Caller {
			l = e.Size()
			n += 1 + l + sovXref(uint64(l))
		}
	}
	if len(m.Callee) > 0 {
		for _, e := range m.Callee {
			l = e.Size()
			n += 1 + l + sovXref(uint64(l))
		}
	}
	return n
}

func (m *CallersReply_CallableDetail) Size() (n int) {
	var l int
	_ = l
	if m.Definition != nil {
		l = m.Definition.Size()
		n += 1 + l + sovXref(uint64(l))
	}
	l = len(m.SemanticObject)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	l = len(m.SemanticObjectCallable)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	l = len(m.Identifier)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	l = len(m.DisplayName)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	if len(m.Parameter) > 0 {
		for _, e := range m.Parameter {
			l = e.Size()
			n += 1 + l + sovXref(uint64(l))
		}
	}
	return n
}

func (m *CallersReply_CallableDetail_Parameter) Size() (n int) {
	var l int
	_ = l
	if m.Kind != 0 {
		n += 1 + sovXref(uint64(m.Kind))
	}
	l = len(m.Identifier)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	l = len(m.Ticket)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	return n
}

func (m *CallersReply_Caller) Size() (n int) {
	var l int
	_ = l
	if m.Detail != nil {
		l = m.Detail.Size()
		n += 1 + l + sovXref(uint64(l))
	}
	if len(m.CallSite) > 0 {
		for _, e := range m.CallSite {
			l = e.Size()
			n += 1 + l + sovXref(uint64(l))
		}
	}
	return n
}

func (m *CallersReply_Caller_CallSite) Size() (n int) {
	var l int
	_ = l
	if m.Anchor != nil {
		l = m.Anchor.Size()
		n += 1 + l + sovXref(uint64(l))
	}
	if m.CallToOverride {
		n += 2
	}
	return n
}

func (m *DocumentationRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.Ticket) > 0 {
		for _, s := range m.Ticket {
			l = len(s)
			n += 1 + l + sovXref(uint64(l))
		}
	}
	return n
}

func (m *DocumentationReply) Size() (n int) {
	var l int
	_ = l
	if len(m.Document) > 0 {
		for _, e := range m.Document {
			l = e.Size()
			n += 1 + l + sovXref(uint64(l))
		}
	}
	return n
}

func (m *DocumentationReply_Link) Size() (n int) {
	var l int
	_ = l
	if len(m.Definition) > 0 {
		for _, e := range m.Definition {
			l = e.Size()
			n += 1 + l + sovXref(uint64(l))
		}
	}
	return n
}

func (m *DocumentationReply_Printable) Size() (n int) {
	var l int
	_ = l
	l = len(m.RawText)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	if len(m.Link) > 0 {
		for _, e := range m.Link {
			l = e.Size()
			n += 1 + l + sovXref(uint64(l))
		}
	}
	return n
}

func (m *DocumentationReply_Document) Size() (n int) {
	var l int
	_ = l
	l = len(m.Ticket)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	if m.Text != nil {
		l = m.Text.Size()
		n += 1 + l + sovXref(uint64(l))
	}
	if m.Signature != nil {
		l = m.Signature.Size()
		n += 1 + l + sovXref(uint64(l))
	}
	if m.Type != nil {
		l = m.Type.Size()
		n += 1 + l + sovXref(uint64(l))
	}
	if m.Initializer != nil {
		l = m.Initializer.Size()
		n += 1 + l + sovXref(uint64(l))
	}
	if m.DefinedBy != nil {
		l = m.DefinedBy.Size()
		n += 1 + l + sovXref(uint64(l))
	}
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovXref(uint64(l))
	}
	return n
}

func sovXref(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozXref(x uint64) (n int) {
	return sovXref(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *NodesRequest) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowXref
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ticket", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ticket = append(m.Ticket, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filter = append(m.Filter, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipXref(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthXref
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodeInfo) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowXref
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodeInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodeInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Facts", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthXref
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapbyteLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapbyteLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intMapbyteLen := int(mapbyteLen)
			if intMapbyteLen < 0 {
				return ErrInvalidLengthXref
			}
			postbytesIndex := iNdEx + intMapbyteLen
			if postbytesIndex > l {
				return io.ErrUnexpectedEOF
			}
			mapvalue := make([]byte, mapbyteLen)
			copy(mapvalue, data[iNdEx:postbytesIndex])
			iNdEx = postbytesIndex
			if m.Facts == nil {
				m.Facts = make(map[string][]byte)
			}
			m.Facts[mapkey] = mapvalue
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Definition", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Definition = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipXref(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthXref
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *NodesReply) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowXref
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: NodesReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: NodesReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthXref
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapmsglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapmsglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if mapmsglen < 0 {
				return ErrInvalidLengthXref
			}
			postmsgIndex := iNdEx + mapmsglen
			if mapmsglen < 0 {
				return ErrInvalidLengthXref
			}
			if postmsgIndex > l {
				return io.ErrUnexpectedEOF
			}
			mapvalue := &NodeInfo{}
			if err := mapvalue.Unmarshal(data[iNdEx:postmsgIndex]); err != nil {
				return err
			}
			iNdEx = postmsgIndex
			if m.Nodes == nil {
				m.Nodes = make(map[string]*NodeInfo)
			}
			m.Nodes[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipXref(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthXref
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EdgesRequest) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowXref
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EdgesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EdgesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ticket", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ticket = append(m.Ticket, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = append(m.Kind, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filter = append(m.Filter, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageSize", wireType)
			}
			m.PageSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.PageSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PageToken = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipXref(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthXref
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EdgeSet) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowXref
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EdgeSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EdgeSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Groups", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthXref
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapmsglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapmsglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if mapmsglen < 0 {
				return ErrInvalidLengthXref
			}
			postmsgIndex := iNdEx + mapmsglen
			if mapmsglen < 0 {
				return ErrInvalidLengthXref
			}
			if postmsgIndex > l {
				return io.ErrUnexpectedEOF
			}
			mapvalue := &EdgeSet_Group{}
			if err := mapvalue.Unmarshal(data[iNdEx:postmsgIndex]); err != nil {
				return err
			}
			iNdEx = postmsgIndex
			if m.Groups == nil {
				m.Groups = make(map[string]*EdgeSet_Group)
			}
			m.Groups[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipXref(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthXref
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EdgeSet_Group) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowXref
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Group: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Group: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Edge", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Edge = append(m.Edge, &EdgeSet_Group_Edge{})
			if err := m.Edge[len(m.Edge)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipXref(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthXref
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EdgeSet_Group_Edge) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowXref
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Edge: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Edge: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetTicket", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TargetTicket = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ordinal", wireType)
			}
			m.Ordinal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Ordinal |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipXref(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthXref
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *EdgesReply) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowXref
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: EdgesReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: EdgesReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EdgeSets", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthXref
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapmsglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapmsglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if mapmsglen < 0 {
				return ErrInvalidLengthXref
			}
			postmsgIndex := iNdEx + mapmsglen
			if mapmsglen < 0 {
				return ErrInvalidLengthXref
			}
			if postmsgIndex > l {
				return io.ErrUnexpectedEOF
			}
			mapvalue := &EdgeSet{}
			if err := mapvalue.Unmarshal(data[iNdEx:postmsgIndex]); err != nil {
				return err
			}
			iNdEx = postmsgIndex
			if m.EdgeSets == nil {
				m.EdgeSets = make(map[string]*EdgeSet)
			}
			m.EdgeSets[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthXref
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapmsglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapmsglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if mapmsglen < 0 {
				return ErrInvalidLengthXref
			}
			postmsgIndex := iNdEx + mapmsglen
			if mapmsglen < 0 {
				return ErrInvalidLengthXref
			}
			if postmsgIndex > l {
				return io.ErrUnexpectedEOF
			}
			mapvalue := &NodeInfo{}
			if err := mapvalue.Unmarshal(data[iNdEx:postmsgIndex]); err != nil {
				return err
			}
			iNdEx = postmsgIndex
			if m.Nodes == nil {
				m.Nodes = make(map[string]*NodeInfo)
			}
			m.Nodes[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalEdges", wireType)
			}
			m.TotalEdges = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.TotalEdges |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextPageToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextPageToken = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipXref(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthXref
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Location) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowXref
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Location: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Location: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ticket", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ticket = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Kind |= (Location_Kind(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Start == nil {
				m.Start = &Location_Point{}
			}
			if err := m.Start.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.End == nil {
				m.End = &Location_Point{}
			}
			if err := m.End.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipXref(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthXref
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Location_Point) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowXref
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Point: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Point: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ByteOffset", wireType)
			}
			m.ByteOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ByteOffset |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field LineNumber", wireType)
			}
			m.LineNumber = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.LineNumber |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ColumnOffset", wireType)
			}
			m.ColumnOffset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ColumnOffset |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipXref(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthXref
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DecorationsRequest) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowXref
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DecorationsRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DecorationsRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &Location{}
			}
			if err := m.Location.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DirtyBuffer", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DirtyBuffer = append(m.DirtyBuffer[:0], data[iNdEx:postIndex]...)
			if m.DirtyBuffer == nil {
				m.DirtyBuffer = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceText", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.SourceText = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field References", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.References = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filter = append(m.Filter, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetDefinitions", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.TargetDefinitions = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field SpanKind", wireType)
			}
			m.SpanKind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.SpanKind |= (DecorationsRequest_SpanKind(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipXref(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthXref
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DecorationsReply) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowXref
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DecorationsReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DecorationsReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Location", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Location == nil {
				m.Location = &Location{}
			}
			if err := m.Location.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceText", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceText = append(m.SourceText[:0], data[iNdEx:postIndex]...)
			if m.SourceText == nil {
				m.SourceText = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Encoding", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Encoding = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reference", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reference = append(m.Reference, &DecorationsReply_Reference{})
			if err := m.Reference[len(m.Reference)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthXref
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapmsglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapmsglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if mapmsglen < 0 {
				return ErrInvalidLengthXref
			}
			postmsgIndex := iNdEx + mapmsglen
			if mapmsglen < 0 {
				return ErrInvalidLengthXref
			}
			if postmsgIndex > l {
				return io.ErrUnexpectedEOF
			}
			mapvalue := &NodeInfo{}
			if err := mapvalue.Unmarshal(data[iNdEx:postmsgIndex]); err != nil {
				return err
			}
			iNdEx = postmsgIndex
			if m.Nodes == nil {
				m.Nodes = make(map[string]*NodeInfo)
			}
			m.Nodes[mapkey] = mapvalue
			iNdEx = postIndex
		case 16:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefinitionLocations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthXref
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapmsglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapmsglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if mapmsglen < 0 {
				return ErrInvalidLengthXref
			}
			postmsgIndex := iNdEx + mapmsglen
			if mapmsglen < 0 {
				return ErrInvalidLengthXref
			}
			if postmsgIndex > l {
				return io.ErrUnexpectedEOF
			}
			mapvalue := &Anchor{}
			if err := mapvalue.Unmarshal(data[iNdEx:postmsgIndex]); err != nil {
				return err
			}
			iNdEx = postmsgIndex
			if m.DefinitionLocations == nil {
				m.DefinitionLocations = make(map[string]*Anchor)
			}
			m.DefinitionLocations[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipXref(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthXref
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DecorationsReply_Reference) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowXref
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Reference: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Reference: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceTicket", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceTicket = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetTicket", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TargetTicket = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TargetDefinition", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TargetDefinition = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnchorStart", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AnchorStart == nil {
				m.AnchorStart = &Location_Point{}
			}
			if err := m.AnchorStart.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnchorEnd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AnchorEnd == nil {
				m.AnchorEnd = &Location_Point{}
			}
			if err := m.AnchorEnd.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipXref(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthXref
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CrossReferencesRequest) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowXref
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CrossReferencesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CrossReferencesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ticket", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ticket = append(m.Ticket, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefinitionKind", wireType)
			}
			m.DefinitionKind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.DefinitionKind |= (CrossReferencesRequest_DefinitionKind(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ReferenceKind", wireType)
			}
			m.ReferenceKind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.ReferenceKind |= (CrossReferencesRequest_ReferenceKind(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DocumentationKind", wireType)
			}
			m.DocumentationKind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.DocumentationKind |= (CrossReferencesRequest_DocumentationKind(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Filter", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Filter = append(m.Filter, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AnchorText", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AnchorText = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeclarationKind", wireType)
			}
			m.DeclarationKind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.DeclarationKind |= (CrossReferencesRequest_DeclarationKind(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeDefinitions", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.NodeDefinitions = bool(v != 0)
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageSize", wireType)
			}
			m.PageSize = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.PageSize |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PageToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PageToken = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipXref(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthXref
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Anchor) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowXref
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Anchor: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Anchor: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ticket", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ticket = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parent", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Parent = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Start", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Start == nil {
				m.Start = &Location_Point{}
			}
			if err := m.Start.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field End", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.End == nil {
				m.End = &Location_Point{}
			}
			if err := m.End.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Text = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Snippet", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Snippet = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnippetStart", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SnippetStart == nil {
				m.SnippetStart = &Location_Point{}
			}
			if err := m.SnippetStart.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SnippetEnd", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.SnippetEnd == nil {
				m.SnippetEnd = &Location_Point{}
			}
			if err := m.SnippetEnd.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipXref(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthXref
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CrossReferencesReply) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowXref
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CrossReferencesReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CrossReferencesReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CrossReferences", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthXref
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapmsglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapmsglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if mapmsglen < 0 {
				return ErrInvalidLengthXref
			}
			postmsgIndex := iNdEx + mapmsglen
			if mapmsglen < 0 {
				return ErrInvalidLengthXref
			}
			if postmsgIndex > l {
				return io.ErrUnexpectedEOF
			}
			mapvalue := &CrossReferencesReply_CrossReferenceSet{}
			if err := mapvalue.Unmarshal(data[iNdEx:postmsgIndex]); err != nil {
				return err
			}
			iNdEx = postmsgIndex
			if m.CrossReferences == nil {
				m.CrossReferences = make(map[string]*CrossReferencesReply_CrossReferenceSet)
			}
			m.CrossReferences[mapkey] = mapvalue
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nodes", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthXref
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapmsglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapmsglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if mapmsglen < 0 {
				return ErrInvalidLengthXref
			}
			postmsgIndex := iNdEx + mapmsglen
			if mapmsglen < 0 {
				return ErrInvalidLengthXref
			}
			if postmsgIndex > l {
				return io.ErrUnexpectedEOF
			}
			mapvalue := &NodeInfo{}
			if err := mapvalue.Unmarshal(data[iNdEx:postmsgIndex]); err != nil {
				return err
			}
			iNdEx = postmsgIndex
			if m.Nodes == nil {
				m.Nodes = make(map[string]*NodeInfo)
			}
			m.Nodes[mapkey] = mapvalue
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefinitionLocations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			var keykey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				keykey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var stringLenmapkey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLenmapkey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLenmapkey := int(stringLenmapkey)
			if intStringLenmapkey < 0 {
				return ErrInvalidLengthXref
			}
			postStringIndexmapkey := iNdEx + intStringLenmapkey
			if postStringIndexmapkey > l {
				return io.ErrUnexpectedEOF
			}
			mapkey := string(data[iNdEx:postStringIndexmapkey])
			iNdEx = postStringIndexmapkey
			var valuekey uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				valuekey |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			var mapmsglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				mapmsglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if mapmsglen < 0 {
				return ErrInvalidLengthXref
			}
			postmsgIndex := iNdEx + mapmsglen
			if mapmsglen < 0 {
				return ErrInvalidLengthXref
			}
			if postmsgIndex > l {
				return io.ErrUnexpectedEOF
			}
			mapvalue := &Anchor{}
			if err := mapvalue.Unmarshal(data[iNdEx:postmsgIndex]); err != nil {
				return err
			}
			iNdEx = postmsgIndex
			if m.DefinitionLocations == nil {
				m.DefinitionLocations = make(map[string]*Anchor)
			}
			m.DefinitionLocations[mapkey] = mapvalue
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TotalReferences", wireType)
			}
			m.TotalReferences = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.TotalReferences |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NextPageToken", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NextPageToken = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipXref(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthXref
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CrossReferencesReply_RelatedNode) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowXref
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: RelatedNode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: RelatedNode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ticket", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ticket = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelationKind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RelationKind = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ordinal", wireType)
			}
			m.Ordinal = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Ordinal |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipXref(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthXref
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CrossReferencesReply_CrossReferenceSet) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowXref
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CrossReferenceSet: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CrossReferenceSet: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ticket", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ticket = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Definition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Definition = append(m.Definition, &Anchor{})
			if err := m.Definition[len(m.Definition)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Reference", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Reference = append(m.Reference, &Anchor{})
			if err := m.Reference[len(m.Reference)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Documentation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Documentation = append(m.Documentation, &Anchor{})
			if err := m.Documentation[len(m.Documentation)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Declaration", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Declaration = append(m.Declaration, &Anchor{})
			if err := m.Declaration[len(m.Declaration)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RelatedNode", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RelatedNode = append(m.RelatedNode, &CrossReferencesReply_RelatedNode{})
			if err := m.RelatedNode[len(m.RelatedNode)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipXref(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthXref
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CallersRequest) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowXref
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CallersRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CallersRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SemanticObject", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SemanticObject = append(m.SemanticObject, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field IncludeOverrides", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.IncludeOverrides = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipXref(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthXref
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CallersReply) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowXref
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CallersReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CallersReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Caller", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Caller = append(m.Caller, &CallersReply_Caller{})
			if err := m.Caller[len(m.Caller)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Callee", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Callee = append(m.Callee, &CallersReply_CallableDetail{})
			if err := m.Callee[len(m.Callee)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipXref(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthXref
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CallersReply_CallableDetail) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowXref
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CallableDetail: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CallableDetail: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Definition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Definition == nil {
				m.Definition = &Anchor{}
			}
			if err := m.Definition.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SemanticObject", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SemanticObject = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SemanticObjectCallable", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SemanticObjectCallable = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Identifier", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Identifier = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DisplayName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DisplayName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Parameter", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Parameter = append(m.Parameter, &CallersReply_CallableDetail_Parameter{})
			if err := m.Parameter[len(m.Parameter)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipXref(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthXref
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CallersReply_CallableDetail_Parameter) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowXref
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Parameter: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Parameter: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			m.Kind = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Kind |= (CallersReply_CallableDetail_Parameter_Kind(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Identifier", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Identifier = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ticket", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ticket = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipXref(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthXref
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CallersReply_Caller) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowXref
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Caller: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Caller: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Detail", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Detail == nil {
				m.Detail = &CallersReply_CallableDetail{}
			}
			if err := m.Detail.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallSite", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.CallSite = append(m.CallSite, &CallersReply_Caller_CallSite{})
			if err := m.CallSite[len(m.CallSite)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipXref(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthXref
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CallersReply_Caller_CallSite) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowXref
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CallSite: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CallSite: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Anchor", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Anchor == nil {
				m.Anchor = &Anchor{}
			}
			if err := m.Anchor.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field CallToOverride", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.CallToOverride = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipXref(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthXref
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DocumentationRequest) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowXref
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DocumentationRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DocumentationRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ticket", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ticket = append(m.Ticket, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipXref(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthXref
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DocumentationReply) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowXref
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: DocumentationReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: DocumentationReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Document", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Document = append(m.Document, &DocumentationReply_Document{})
			if err := m.Document[len(m.Document)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipXref(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthXref
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DocumentationReply_Link) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowXref
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Link: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Link: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Definition", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Definition = append(m.Definition, &Anchor{})
			if err := m.Definition[len(m.Definition)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipXref(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthXref
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DocumentationReply_Printable) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowXref
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Printable: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Printable: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RawText", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RawText = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Link", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Link = append(m.Link, &DocumentationReply_Link{})
			if err := m.Link[len(m.Link)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipXref(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthXref
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *DocumentationReply_Document) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowXref
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Document: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Document: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ticket", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ticket = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Text", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Text == nil {
				m.Text = &DocumentationReply_Printable{}
			}
			if err := m.Text.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Signature == nil {
				m.Signature = &DocumentationReply_Printable{}
			}
			if err := m.Signature.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Type", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Type == nil {
				m.Type = &DocumentationReply_Printable{}
			}
			if err := m.Type.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Initializer", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Initializer == nil {
				m.Initializer = &DocumentationReply_Printable{}
			}
			if err := m.Initializer.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DefinedBy", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DefinedBy == nil {
				m.DefinedBy = &DocumentationReply_Printable{}
			}
			if err := m.DefinedBy.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowXref
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthXref
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipXref(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthXref
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipXref(data []byte) (n int, err error) {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowXref
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowXref
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if data[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowXref
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthXref
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowXref
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipXref(data[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthXref = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowXref   = fmt.Errorf("proto: integer overflow")
)

var fileDescriptorXref = []byte{
	// 1918 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0xac, 0x58, 0x4f, 0x73, 0xe3, 0x66,
	0x19, 0x8f, 0x6c, 0x2b, 0xb1, 0x1f, 0x39, 0x89, 0xa3, 0xcd, 0xb6, 0x5e, 0x75, 0xe8, 0x6e, 0xd5,
	0xd2, 0xf5, 0x76, 0xb6, 0x4e, 0xeb, 0x1d, 0xba, 0x9d, 0x6d, 0x61, 0xc8, 0x26, 0x4e, 0x6b, 0x9a,
	0x75, 0x52, 0x27, 0x3b, 0x94, 0xe1, 0xa0, 0x51, 0xe4, 0xd7, 0x59, 0x11, 0x45, 0x32, 0x92, 0xbc,
	0xd4, 0x9c, 0x38, 0x70, 0x83, 0x81, 0x01, 0x2e, 0x7c, 0x0a, 0x2e, 0x7c, 0x06, 0x18, 0x66, 0xb8,
	0x70, 0x61, 0xb8, 0x32, 0x70, 0xe3, 0x23, 0x70, 0xea, 0xf3, 0x3e, 0x7a, 0x25, 0x4b, 0xb2, 0x1c,
	0x27, 0x33, 0x7b, 0xc8, 0xc4, 0x7a, 0xf5, 0xfc, 0xfd, 0x3d, 0x7f, 0x5f, 0xc1, 0x6b, 0x17, 0xd3,
	0xf0, 0x05, 0xdb, 0x19, 0xfb, 0x5e, 0xe8, 0xed, 0x7c, 0xed, 0xb3, 0x51, 0x9b, 0x7e, 0xaa, 0x0a,
	0x9d, 0x47, 0x0f, 0x7a, 0x1b, 0xea, 0x7d, 0x6f, 0xc8, 0x82, 0x01, 0xfb, 0xe9, 0x84, 0x05, 0xa1,
	0xba, 0x01, 0xab, 0xa1, 0x6d, 0x5d, 0xb0, 0xb0, 0x29, 0xdd, 0x2b, 0xb7, 0x6a, 0xfc, 0x79, 0x64,
	0x3b, 0x21, 0xf3, 0x9b, 0x25, 0xfe, 0xac, 0xff, 0x4a, 0x82, 0x2a, 0x67, 0xe8, 0xb9, 0x23, 0x4f,
	0xdd, 0x01, 0x79, 0x64, 0x5a, 0x61, 0x40, 0xef, 0x94, 0xce, 0xbd, 0x76, 0x4a, 0x72, 0x3b, 0xa6,
	0x6a, 0x1f, 0x70, 0x92, 0xae, 0x1b, 0xfa, 0x53, 0x55, 0x05, 0x18, 0xb2, 0x91, 0xed, 0xda, 0xa1,
	0xed, 0xb9, 0x4d, 0xf9, 0x9e, 0xd4, 0xaa, 0x69, 0x0f, 0x01, 0x52, 0x14, 0x0a, 0x94, 0x2f, 0xd8,
	0x14, 0x95, 0xe3, 0x2b, 0x75, 0x1d, 0xe4, 0x97, 0xa6, 0x33, 0x61, 0x28, 0x5f, 0x6a, 0xd5, 0x9f,
	0x94, 0x3e, 0x96, 0x7e, 0x50, 0xa9, 0x4a, 0x8d, 0xd2, 0x40, 0xd8, 0xa8, 0xff, 0x52, 0x02, 0x10,
	0xe6, 0x8f, 0x9d, 0xa9, 0xfa, 0x21, 0xc8, 0x2e, 0x7f, 0x22, 0xdb, 0x95, 0x8e, 0x3e, 0x67, 0x4f,
	0x44, 0x17, 0xfd, 0x24, 0x7d, 0xda, 0x9e, 0x10, 0x50, 0xa0, 0xfd, 0x9d, 0xb4, 0x76, 0xa5, 0x73,
	0xbb, 0xd0, 0x3b, 0x6e, 0x94, 0x6e, 0x41, 0xbd, 0x3b, 0x3c, 0x5f, 0x0c, 0x62, 0x1d, 0x2a, 0x17,
	0xb6, 0x3b, 0x8c, 0x20, 0x4c, 0x41, 0x5a, 0xa6, 0xe7, 0x2d, 0xa8, 0x8d, 0xcd, 0x73, 0x66, 0x04,
	0xf6, 0xcf, 0x59, 0xb3, 0x8a, 0xba, 0x64, 0x8e, 0x13, 0x1d, 0x85, 0xde, 0x05, 0x73, 0x9b, 0x35,
	0x6e, 0x8e, 0xfe, 0xdb, 0x12, 0xac, 0x71, 0x2d, 0x27, 0x2c, 0x54, 0x3f, 0x80, 0xd5, 0x73, 0xdf,
	0x9b, 0x8c, 0x8b, 0x91, 0x17, 0x54, 0xed, 0xcf, 0x88, 0x24, 0xf2, 0xd3, 0x07, 0x99, 0x1e, 0xd5,
	0xf7, 0xa1, 0xc2, 0xf0, 0xbd, 0x60, 0xbc, 0xbb, 0x98, 0x91, 0x9e, 0xb4, 0x36, 0x54, 0xf8, 0x7f,
	0xf5, 0x36, 0xac, 0x87, 0xa6, 0x7f, 0xce, 0x42, 0x23, 0xf1, 0x8c, 0x63, 0xb4, 0x09, 0x6b, 0x9e,
	0x3f, 0xb4, 0x5d, 0xd3, 0x21, 0x94, 0x64, 0x11, 0x1f, 0x72, 0x57, 0xeb, 0x81, 0x92, 0x32, 0x21,
	0x0b, 0xee, 0x83, 0x2c, 0xb8, 0xda, 0x62, 0x3b, 0x52, 0x61, 0x5f, 0x0f, 0xbc, 0x89, 0x6f, 0x31,
	0x61, 0x82, 0xfe, 0xe7, 0x12, 0x80, 0xc0, 0x9d, 0x47, 0xff, 0x63, 0xa8, 0x71, 0xcf, 0x8c, 0x80,
	0x85, 0x71, 0x06, 0x7c, 0x7b, 0x4e, 0xac, 0xc8, 0x00, 0xa1, 0x41, 0x58, 0x96, 0xe4, 0x4d, 0xa9,
	0x20, 0x6f, 0x52, 0x5c, 0xa9, 0x4c, 0xb9, 0x05, 0x4a, 0xe8, 0x85, 0xa6, 0x63, 0x70, 0x95, 0x01,
	0x46, 0x52, 0x6a, 0x95, 0xd5, 0xd7, 0x61, 0xd3, 0x65, 0x5f, 0x87, 0x46, 0x3e, 0x76, 0x5a, 0x17,
	0xd6, 0xb3, 0x1a, 0x33, 0x58, 0xbc, 0x9d, 0xc5, 0x62, 0xbb, 0x08, 0x0b, 0x8e, 0xc2, 0xab, 0x49,
	0xd6, 0x5f, 0x94, 0xa0, 0x7a, 0xe8, 0x59, 0x26, 0x2f, 0xc1, 0x4c, 0xa6, 0x72, 0x31, 0xad, 0x24,
	0x53, 0xa5, 0xd6, 0x46, 0x2e, 0x2a, 0x31, 0x53, 0xfb, 0x0b, 0xa4, 0x50, 0xdf, 0x03, 0x39, 0xc0,
	0x8c, 0x08, 0xc9, 0x75, 0xa5, 0xf3, 0x46, 0x31, 0xe9, 0xb1, 0x67, 0xbb, 0x21, 0x4a, 0x2d, 0x33,
	0x14, 0x5a, 0x59, 0x4a, 0xa9, 0x7d, 0x0e, 0x72, 0xc4, 0x82, 0xf8, 0x9e, 0x4d, 0x43, 0x66, 0x78,
	0xa3, 0x51, 0x20, 0xac, 0x93, 0xf9, 0xa1, 0x63, 0xbb, 0xcc, 0x70, 0x27, 0x97, 0x67, 0xd4, 0x91,
	0xf8, 0x21, 0x66, 0xa6, 0xe5, 0x39, 0x93, 0x4b, 0x37, 0xa6, 0xe5, 0x06, 0xc9, 0xba, 0x06, 0x15,
	0xb2, 0xb3, 0x0a, 0x95, 0x83, 0xde, 0x61, 0xb7, 0xb1, 0xc2, 0x7f, 0x9d, 0x1c, 0xef, 0xf6, 0x1b,
	0x92, 0xfe, 0x87, 0x12, 0xa8, 0xfb, 0xcc, 0xf2, 0x7c, 0x52, 0x9d, 0x94, 0xed, 0x7d, 0xa8, 0x3a,
	0xc2, 0x1c, 0x52, 0x98, 0x87, 0x31, 0x41, 0x6d, 0x1b, 0xea, 0x43, 0xdb, 0x0f, 0xa7, 0xc6, 0xd9,
	0x64, 0x34, 0x12, 0x86, 0xd4, 0xb9, 0x75, 0x71, 0x7e, 0x62, 0x12, 0x90, 0x19, 0x55, 0x5e, 0xc9,
	0xd8, 0x79, 0x99, 0xcf, 0x5c, 0x0b, 0xd3, 0xa4, 0x42, 0x67, 0xb3, 0x06, 0x20, 0x53, 0x03, 0xd0,
	0x40, 0x15, 0xb5, 0x35, 0x6b, 0x8e, 0x41, 0x73, 0x95, 0x68, 0x3f, 0x81, 0x5a, 0x30, 0x36, 0x5d,
	0x83, 0xa2, 0x02, 0x14, 0x95, 0x56, 0xc6, 0xa8, 0x79, 0x3f, 0xda, 0x27, 0xc8, 0xc0, 0x7d, 0xd7,
	0x1f, 0x42, 0x35, 0xfe, 0x8d, 0x95, 0xaa, 0xfc, 0xb0, 0x77, 0xfa, 0x79, 0xaf, 0x6f, 0x10, 0x08,
	0x2b, 0xfc, 0x60, 0x77, 0x70, 0xf4, 0xbc, 0xbf, 0x6f, 0x08, 0x54, 0x7e, 0x2d, 0x43, 0x23, 0x23,
	0x8d, 0x17, 0xd5, 0xb5, 0x31, 0xc9, 0x79, 0x1f, 0x41, 0xd2, 0x80, 0x2a, 0x3a, 0xee, 0x61, 0x83,
	0x38, 0x27, 0x3c, 0x6a, 0xea, 0x13, 0xa8, 0x25, 0x78, 0x20, 0x1c, 0xbc, 0xdc, 0xee, 0x2f, 0xf6,
	0x87, 0x17, 0xdd, 0x20, 0x26, 0x57, 0x1f, 0xc7, 0x65, 0xba, 0x49, 0x7c, 0xad, 0xab, 0xf9, 0x52,
	0x95, 0x72, 0x0a, 0xdb, 0x33, 0x64, 0x8d, 0xd8, 0x9f, 0xa0, 0xd9, 0x20, 0x39, 0x1f, 0x5d, 0x2d,
	0x67, 0x3f, 0xe1, 0x8c, 0x7d, 0x15, 0x2d, 0xf5, 0xaf, 0x12, 0xd4, 0x66, 0xc6, 0x61, 0x1a, 0x66,
	0xba, 0x93, 0x28, 0xa8, 0xb9, 0xbe, 0x59, 0xa2, 0xe3, 0x78, 0x22, 0x44, 0xa0, 0xdc, 0x81, 0xad,
	0xb9, 0x04, 0xa0, 0x5c, 0xa9, 0x61, 0x6b, 0xaa, 0x9b, 0xae, 0xf5, 0xc2, 0xf3, 0x8d, 0xa8, 0xda,
	0x60, 0x79, 0xb5, 0xed, 0x00, 0x08, 0x16, 0x5e, 0x74, 0xca, 0xf2, 0xa2, 0x7b, 0x15, 0x6d, 0x45,
	0x3b, 0x82, 0xe6, 0x22, 0xa4, 0xb2, 0x22, 0xf5, 0xac, 0xc8, 0x5b, 0x19, 0x91, 0xbb, 0x64, 0x38,
	0xf5, 0xa9, 0xff, 0xc9, 0xf0, 0xda, 0x9e, 0xef, 0x05, 0x41, 0x82, 0xf1, 0xc2, 0xf9, 0xfa, 0x05,
	0x6c, 0xa6, 0xe2, 0x9b, 0x6a, 0x60, 0x9d, 0x8c, 0xf0, 0x62, 0x69, 0xa9, 0x00, 0x53, 0xa1, 0xf4,
	0x60, 0x23, 0xc9, 0x50, 0x23, 0x09, 0xd2, 0x46, 0xe7, 0xc3, 0xeb, 0xc8, 0x4a, 0x4e, 0x48, 0xd4,
	0x97, 0xa0, 0x0e, 0x3d, 0x6b, 0x72, 0xc9, 0xdc, 0xd0, 0x9c, 0x99, 0x56, 0x21, 0x71, 0xdf, 0xb9,
	0x96, 0x69, 0x69, 0x6e, 0x12, 0x99, 0xef, 0x1d, 0x58, 0x76, 0x22, 0xd8, 0x54, 0x76, 0x51, 0xd3,
	0x78, 0x06, 0x8d, 0x21, 0xb3, 0x1c, 0xd3, 0x4f, 0x69, 0x5d, 0x23, 0xad, 0x8f, 0xae, 0x07, 0x48,
	0xc2, 0x4b, 0x3a, 0x9b, 0xd0, 0xe0, 0x75, 0x97, 0xe9, 0x4e, 0x55, 0x52, 0x94, 0x59, 0x5d, 0xa0,
	0x60, 0x75, 0x51, 0x68, 0x75, 0x79, 0x01, 0x1b, 0x39, 0x90, 0x55, 0xd8, 0xe8, 0x1f, 0x19, 0xfb,
	0xdd, 0x83, 0x5e, 0xbf, 0x77, 0xda, 0x3b, 0xea, 0x9f, 0x60, 0x43, 0xba, 0x05, 0x9b, 0xbb, 0x87,
	0x87, 0x99, 0x43, 0x09, 0x5b, 0x6d, 0xe3, 0xe0, 0x79, 0xee, 0xb4, 0x84, 0x83, 0xf6, 0xd6, 0xd3,
	0x5e, 0x7f, 0xbf, 0xd7, 0xff, 0x2c, 0xf3, 0xa2, 0xac, 0x7f, 0x0a, 0x9b, 0x79, 0xeb, 0x51, 0x2c,
	0xa9, 0xda, 0x3b, 0xdc, 0x1d, 0xec, 0xc6, 0xba, 0x50, 0x6c, 0xa4, 0x2b, 0x75, 0x2a, 0xe9, 0x1f,
	0xc1, 0x7a, 0x36, 0x80, 0x5b, 0xb0, 0x8e, 0xbc, 0x83, 0xee, 0x41, 0x77, 0xd0, 0xed, 0xef, 0x75,
	0x39, 0x27, 0x5a, 0xce, 0x39, 0x53, 0x67, 0x92, 0xfe, 0x7d, 0xd8, 0x9a, 0x8f, 0x14, 0xaa, 0xe0,
	0x7a, 0x8f, 0xf6, 0x9e, 0x3f, 0xeb, 0xf6, 0x4f, 0x49, 0x07, 0xb2, 0xdf, 0x86, 0x2d, 0x52, 0x9c,
	0x39, 0x96, 0xf4, 0xdf, 0x95, 0x60, 0x35, 0xca, 0xfd, 0xb9, 0x91, 0x5c, 0x4f, 0x8d, 0x64, 0x5a,
	0x1e, 0xc7, 0x26, 0x1a, 0x18, 0x8a, 0xd6, 0x91, 0x8c, 0xe1, 0xca, 0xb5, 0xc7, 0xb0, 0xbc, 0x9c,
	0x12, 0x75, 0x26, 0xe9, 0x44, 0x4b, 0x5e, 0xe0, 0xda, 0xe3, 0x31, 0x9a, 0xb4, 0x46, 0x07, 0x1d,
	0xec, 0x75, 0xd1, 0x81, 0xe8, 0x4a, 0xd5, 0xe5, 0x22, 0x3f, 0xc0, 0xf9, 0x20, 0x78, 0xb8, 0x11,
	0xb5, 0xa5, 0x1c, 0xfa, 0x6f, 0xd6, 0x60, 0x7b, 0x2e, 0x43, 0xf9, 0x4c, 0x3a, 0x86, 0x86, 0xc5,
	0xcf, 0x8d, 0xd4, 0x64, 0x95, 0x0a, 0x5a, 0x79, 0x11, 0x73, 0xfe, 0x30, 0x6a, 0x50, 0x9f, 0x64,
	0x17, 0xc0, 0x87, 0xcb, 0xc5, 0xa4, 0x1a, 0xe6, 0x57, 0x0b, 0xa6, 0x4b, 0x99, 0x64, 0x3d, 0x59,
	0x2e, 0x6b, 0x61, 0xdf, 0xc4, 0xc2, 0x8b, 0x96, 0xcc, 0xdc, 0x0a, 0x51, 0xb8, 0x69, 0x82, 0xd8,
	0x34, 0x95, 0x01, 0x73, 0xcc, 0x90, 0x0d, 0xb9, 0x85, 0x73, 0xc9, 0x84, 0xe3, 0xc8, 0xe7, 0xaf,
	0x33, 0x7d, 0x32, 0xb3, 0xc6, 0xd3, 0xf6, 0xa4, 0xe1, 0x65, 0x63, 0x2b, 0x6b, 0x2b, 0xbf, 0x76,
	0xe4, 0xa5, 0xdd, 0xcf, 0x5c, 0xe7, 0x22, 0xec, 0x8a, 0xfa, 0xb9, 0xfa, 0x6e, 0x7a, 0xea, 0x97,
	0x17, 0xd3, 0xbd, 0x07, 0xeb, 0x99, 0x86, 0x29, 0x36, 0x84, 0x42, 0xda, 0x16, 0x28, 0xa9, 0x26,
	0x47, 0xed, 0x70, 0x01, 0xe5, 0x1e, 0xd4, 0xfd, 0x08, 0x13, 0x83, 0x47, 0x19, 0x91, 0xe2, 0xa4,
	0xef, 0x2f, 0x0f, 0x4c, 0x0a, 0x49, 0xed, 0x62, 0x2e, 0x19, 0x0b, 0x66, 0xdb, 0xd3, 0xec, 0x6c,
	0x7b, 0x74, 0xd3, 0x74, 0x7c, 0x95, 0x8b, 0xfe, 0xab, 0x9f, 0xc8, 0xfb, 0xb0, 0xb1, 0x67, 0x3a,
	0x0e, 0xf3, 0x93, 0x41, 0x8c, 0x69, 0x18, 0xb0, 0x4b, 0xd3, 0xc5, 0xac, 0x30, 0xbc, 0xb3, 0x9f,
	0x30, 0x2b, 0x9e, 0xc8, 0xb8, 0xd1, 0xd8, 0xae, 0xe5, 0x4c, 0x70, 0x6a, 0x78, 0x2f, 0x99, 0xef,
	0xdb, 0x51, 0x71, 0xe1, 0xcc, 0xd0, 0xff, 0x22, 0x43, 0x3d, 0x11, 0xc3, 0xcb, 0x19, 0x2f, 0xb3,
	0x16, 0x3d, 0x8b, 0x22, 0xce, 0x5e, 0x66, 0xd3, 0xa4, 0xe2, 0x01, 0x6f, 0x7a, 0x11, 0x47, 0x7c,
	0x8b, 0x6d, 0x5d, 0xcd, 0x61, 0x9e, 0x39, 0x6c, 0x9f, 0x85, 0xa6, 0xed, 0x68, 0xff, 0x2f, 0x45,
	0x3e, 0xcc, 0x8e, 0x72, 0x49, 0x2c, 0x2d, 0x84, 0xa0, 0xc8, 0xd9, 0xa8, 0x7a, 0xee, 0x41, 0x33,
	0xf7, 0xc2, 0xb0, 0x84, 0x0e, 0xd1, 0xa5, 0x71, 0x28, 0x22, 0x02, 0x48, 0x30, 0xb2, 0xd1, 0xcd,
	0x68, 0xb3, 0xa3, 0x4b, 0x44, 0x30, 0x76, 0xcc, 0xa9, 0xe1, 0x9a, 0x97, 0x2c, 0xfa, 0x1a, 0xa2,
	0x76, 0xf9, 0x44, 0xf5, 0xf1, 0x99, 0x8f, 0xf8, 0x55, 0xf2, 0xae, 0x73, 0x5d, 0xef, 0xda, 0xc7,
	0x31, 0xa7, 0xf6, 0x7b, 0xdc, 0x4d, 0x93, 0x27, 0x14, 0x1a, 0x8d, 0x10, 0x89, 0x76, 0x80, 0xc7,
	0x37, 0x97, 0xd7, 0x16, 0x43, 0x3b, 0xed, 0x45, 0x32, 0x8f, 0x44, 0x4b, 0x20, 0x4f, 0xd3, 0xd7,
	0xae, 0xd3, 0xee, 0xe0, 0x59, 0x74, 0xed, 0x3a, 0xfd, 0xd1, 0x71, 0xb7, 0x21, 0x69, 0x7f, 0x97,
	0x60, 0x75, 0x16, 0xc1, 0x21, 0xe9, 0x10, 0x80, 0x5f, 0x3b, 0x82, 0xea, 0xa7, 0x50, 0xe3, 0xe0,
	0xe2, 0xca, 0x11, 0xc6, 0xe1, 0x7f, 0xb0, 0x2c, 0x61, 0xe8, 0xdf, 0x09, 0x32, 0x68, 0x3d, 0xa8,
	0xc6, 0xbf, 0xf1, 0xda, 0xbd, 0x1a, 0xad, 0x4e, 0x57, 0x05, 0x1d, 0x5b, 0x30, 0xa9, 0x0b, 0xbd,
	0x24, 0x91, 0x45, 0x1e, 0xbf, 0x0b, 0xdb, 0x99, 0xa1, 0xbf, 0x60, 0x39, 0xd5, 0xff, 0x54, 0xc1,
	0xcb, 0x66, 0x96, 0x90, 0x67, 0xfd, 0x13, 0xa8, 0xc6, 0xad, 0x4e, 0xe4, 0x7d, 0xee, 0x3e, 0x33,
	0xc7, 0x92, 0x1c, 0x69, 0x3b, 0x50, 0x39, 0xb4, 0xdd, 0x8b, 0xb9, 0xd4, 0x5d, 0xd4, 0x01, 0xb5,
	0x2f, 0x31, 0x1b, 0x7c, 0x9c, 0xa9, 0x1c, 0x47, 0x7e, 0x29, 0xf3, 0xcd, 0x9f, 0x45, 0xfb, 0xa2,
	0x24, 0xe6, 0x79, 0x05, 0xef, 0xd5, 0x17, 0x02, 0xce, 0x77, 0x96, 0xd9, 0xc1, 0x75, 0x6b, 0xff,
	0x2a, 0x41, 0x35, 0x7e, 0x37, 0x37, 0x18, 0x1e, 0x8b, 0xfd, 0x21, 0x6a, 0x28, 0x0f, 0x96, 0x09,
	0x9c, 0xd9, 0x86, 0xd1, 0x0d, 0xec, 0x73, 0xd7, 0x0c, 0x27, 0x3e, 0x13, 0x5f, 0x16, 0x6e, 0xc0,
	0xcd, 0xd5, 0x4e, 0xc7, 0x4c, 0xec, 0x42, 0x37, 0x60, 0xfc, 0x1e, 0x28, 0x84, 0xa2, 0xe9, 0xe0,
	0x22, 0xeb, 0x8b, 0x0d, 0xe9, 0x06, 0xfc, 0xdf, 0x15, 0x81, 0xc0, 0x09, 0x73, 0x36, 0xa5, 0xad,
	0xe9, 0x46, 0xec, 0xf1, 0x8a, 0x47, 0xdb, 0x55, 0xe7, 0x9f, 0x65, 0x50, 0xbe, 0xc2, 0x91, 0x70,
	0xc2, 0xfc, 0x97, 0xb6, 0xc5, 0x85, 0xcb, 0x34, 0x0c, 0xd4, 0x3b, 0x45, 0xdf, 0x33, 0x29, 0xe9,
	0xb4, 0xd7, 0x17, 0x7c, 0xea, 0xd4, 0x57, 0x38, 0x3b, 0x7d, 0xc2, 0xca, 0xb1, 0xa7, 0x3f, 0x58,
	0xe6, 0xd8, 0x67, 0x5f, 0xbc, 0x90, 0xfd, 0x08, 0x94, 0xd4, 0x95, 0x58, 0xbd, 0xbb, 0xe4, 0xe3,
	0x83, 0xf6, 0xad, 0x2b, 0x6f, 0xd3, 0x28, 0xf0, 0xc7, 0xb0, 0x99, 0x9b, 0x84, 0xea, 0xdb, 0xd7,
	0xb8, 0x95, 0x68, 0x6f, 0x2d, 0x1d, 0xa6, 0x28, 0x7c, 0x0f, 0xd6, 0x44, 0xfd, 0xab, 0x6f, 0x14,
	0x77, 0x85, 0x48, 0xd8, 0x9d, 0x85, 0x2d, 0x03, 0x85, 0x3c, 0x87, 0xf5, 0x4c, 0xb8, 0xd4, 0xb7,
	0xae, 0x0a, 0x65, 0x24, 0xf0, 0xee, 0x92, 0x68, 0xeb, 0x2b, 0x4f, 0x1b, 0x7f, 0xfb, 0xcf, 0x9b,
	0xd2, 0x3f, 0xf0, 0xef, 0xdf, 0xf8, 0xf7, 0xc7, 0xff, 0xbe, 0xb9, 0x72, 0xb6, 0x4a, 0xd4, 0x8f,
	0xbe, 0x09, 0x00, 0x00, 0xff, 0xff, 0x67, 0x87, 0x11, 0xae, 0xaa, 0x17, 0x00, 0x00,
}
