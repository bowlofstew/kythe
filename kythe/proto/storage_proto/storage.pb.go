// Code generated by protoc-gen-gogo.
// source: kythe/proto/storage.proto
// DO NOT EDIT!

/*
	Package storage_proto is a generated protocol buffer package.

	It is generated from these files:
		kythe/proto/storage.proto

	It has these top-level messages:
		VName
		VNameMask
		Entry
		Entries
		ReadRequest
		WriteRequest
		WriteReply
		ScanRequest
		CountRequest
		CountReply
		ShardRequest
		SearchRequest
		SearchReply
*/
package storage_proto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
const _ = proto.ProtoPackageIsVersion1

// VName is a proto representation of a vector name.
//
// Rules:
//  - All fields must be optional, and must have default values.
//  - No field may ever be removed.  If a field is deprecated, it may be
//    renamed or marked with a comment, but must not be deleted.
//  - New fields are always added to the end of the message.
//  - All fields must be strings, not messages.
//
// One of the key principles is that we want as few fields as possible in a
// vname.  We're not trying to exhaust the possible dimensions along which a
// name could vary, but to find a minimal basis. Be conservative.
type VName struct {
	// A language-specific signature assigned by the analyzer.
	// e.g., "com.google.common.collect.Lists.newLinkedList<#1>()"
	Signature string `protobuf:"bytes,1,opt,name=signature,proto3" json:"signature,omitempty"`
	// The corpus this name belongs to.
	// e.g., "kythe", "chromium", "github.com/creachadair/imath", "aosp"
	// The corpus label "kythe" is reserved for internal use.
	Corpus string `protobuf:"bytes,2,opt,name=corpus,proto3" json:"corpus,omitempty"`
	// A corpus-specific root label, designating a subordinate collection within
	// the corpus.  If a corpus stores files in unrelated directory structures,
	// for example, the root can be used to distinguish them.  Or, of a corpus
	// incorporates subprojects, the root can be a project ID that it governs.
	// This may also be used to distinguish virtual subgroups of a corpus such as
	// generated files.
	Root string `protobuf:"bytes,3,opt,name=root,proto3" json:"root,omitempty"`
	// A path-structured label describing the location of this object relative to
	// the corpus and the root.  For code, this will generally be the relative
	// path to the file containing the code, e.g., "storage/service.go" in kythe.
	//
	// However, this need not be a true file path; virtual objects like figments
	// can assign an ad-hoc abstract ID, or omit it entirely.
	//
	// Examples:
	//   "devools/kythe/platform/go/datastore.go" (a file)
	//   "type/cpp/void.cc" (a type figment)
	Path string `protobuf:"bytes,4,opt,name=path,proto3" json:"path,omitempty"`
	// The language this name belongs to.
	// e.g., "c++", "python", "elisp", "haskell", "java"
	//
	// The schema will define specific labels for each supported language, so we
	// don't wind up with a confusion of names like "cxx", "cpp", "C++", etc.
	// Prototype: Official language name converted to lowercase.  If a version
	// number is necessary, include it, e.g., "python3".
	Language string `protobuf:"bytes,5,opt,name=language,proto3" json:"language,omitempty"`
}

func (m *VName) Reset()                    { *m = VName{} }
func (m *VName) String() string            { return proto.CompactTextString(m) }
func (*VName) ProtoMessage()               {}
func (*VName) Descriptor() ([]byte, []int) { return fileDescriptorStorage, []int{0} }

type VNameMask struct {
	Signature bool `protobuf:"varint,1,opt,name=signature,proto3" json:"signature,omitempty"`
	Corpus    bool `protobuf:"varint,2,opt,name=corpus,proto3" json:"corpus,omitempty"`
	Root      bool `protobuf:"varint,3,opt,name=root,proto3" json:"root,omitempty"`
	Path      bool `protobuf:"varint,4,opt,name=path,proto3" json:"path,omitempty"`
	Language  bool `protobuf:"varint,5,opt,name=language,proto3" json:"language,omitempty"`
}

func (m *VNameMask) Reset()                    { *m = VNameMask{} }
func (m *VNameMask) String() string            { return proto.CompactTextString(m) }
func (*VNameMask) ProtoMessage()               {}
func (*VNameMask) Descriptor() ([]byte, []int) { return fileDescriptorStorage, []int{1} }

// An Entry associates a fact with a graph object (node or edge).  This is the
// the primary unit of storage.
type Entry struct {
	Source *VName `protobuf:"bytes,1,opt,name=source" json:"source,omitempty"`
	// The following two fields must either be both empty, or both nonempty.
	EdgeKind string `protobuf:"bytes,2,opt,name=edge_kind,proto3" json:"edge_kind,omitempty"`
	Target   *VName `protobuf:"bytes,3,opt,name=target" json:"target,omitempty"`
	// The grammar for fact_name:
	//  name   = "/" | 1*path
	//  path   = "/" word
	//  word   = 1*{LETTER|DIGIT|PUNCT}
	//  LETTER = [A-Za-z]
	//  DIGIT  = [0-9]
	//  PUNCT  = [-.@#$%&_+:()]
	FactName  string `protobuf:"bytes,4,opt,name=fact_name,proto3" json:"fact_name,omitempty"`
	FactValue []byte `protobuf:"bytes,5,opt,name=fact_value,proto3" json:"fact_value,omitempty"`
}

func (m *Entry) Reset()                    { *m = Entry{} }
func (m *Entry) String() string            { return proto.CompactTextString(m) }
func (*Entry) ProtoMessage()               {}
func (*Entry) Descriptor() ([]byte, []int) { return fileDescriptorStorage, []int{2} }

func (m *Entry) GetSource() *VName {
	if m != nil {
		return m.Source
	}
	return nil
}

func (m *Entry) GetTarget() *VName {
	if m != nil {
		return m.Target
	}
	return nil
}

// A collection of Entry instances.
type Entries struct {
	Entries []*Entry `protobuf:"bytes,1,rep,name=entries" json:"entries,omitempty"`
}

func (m *Entries) Reset()                    { *m = Entries{} }
func (m *Entries) String() string            { return proto.CompactTextString(m) }
func (*Entries) ProtoMessage()               {}
func (*Entries) Descriptor() ([]byte, []int) { return fileDescriptorStorage, []int{3} }

func (m *Entries) GetEntries() []*Entry {
	if m != nil {
		return m.Entries
	}
	return nil
}

// Request for a stream of Entry objects from a GraphStore.  Read operations
// should be implemented with time complexity proportional to the size of the
// return set.
type ReadRequest struct {
	// Return entries having this source VName, which may not be empty.
	Source *VName `protobuf:"bytes,1,opt,name=source" json:"source,omitempty"`
	// Return entries having this edge kind; if empty, only entries with an empty
	// edge kind are returned; if "*", entries of any edge kind are returned.
	EdgeKind string `protobuf:"bytes,2,opt,name=edge_kind,proto3" json:"edge_kind,omitempty"`
}

func (m *ReadRequest) Reset()                    { *m = ReadRequest{} }
func (m *ReadRequest) String() string            { return proto.CompactTextString(m) }
func (*ReadRequest) ProtoMessage()               {}
func (*ReadRequest) Descriptor() ([]byte, []int) { return fileDescriptorStorage, []int{4} }

func (m *ReadRequest) GetSource() *VName {
	if m != nil {
		return m.Source
	}
	return nil
}

// Request to write Entry objects to a GraphStore
type WriteRequest struct {
	Source *VName                 `protobuf:"bytes,1,opt,name=source" json:"source,omitempty"`
	Update []*WriteRequest_Update `protobuf:"bytes,2,rep,name=update" json:"update,omitempty"`
}

func (m *WriteRequest) Reset()                    { *m = WriteRequest{} }
func (m *WriteRequest) String() string            { return proto.CompactTextString(m) }
func (*WriteRequest) ProtoMessage()               {}
func (*WriteRequest) Descriptor() ([]byte, []int) { return fileDescriptorStorage, []int{5} }

func (m *WriteRequest) GetSource() *VName {
	if m != nil {
		return m.Source
	}
	return nil
}

func (m *WriteRequest) GetUpdate() []*WriteRequest_Update {
	if m != nil {
		return m.Update
	}
	return nil
}

type WriteRequest_Update struct {
	EdgeKind  string `protobuf:"bytes,1,opt,name=edge_kind,proto3" json:"edge_kind,omitempty"`
	Target    *VName `protobuf:"bytes,2,opt,name=target" json:"target,omitempty"`
	FactName  string `protobuf:"bytes,3,opt,name=fact_name,proto3" json:"fact_name,omitempty"`
	FactValue []byte `protobuf:"bytes,4,opt,name=fact_value,proto3" json:"fact_value,omitempty"`
}

func (m *WriteRequest_Update) Reset()                    { *m = WriteRequest_Update{} }
func (m *WriteRequest_Update) String() string            { return proto.CompactTextString(m) }
func (*WriteRequest_Update) ProtoMessage()               {}
func (*WriteRequest_Update) Descriptor() ([]byte, []int) { return fileDescriptorStorage, []int{5, 0} }

func (m *WriteRequest_Update) GetTarget() *VName {
	if m != nil {
		return m.Target
	}
	return nil
}

// Response to a WriteRequest
type WriteReply struct {
}

func (m *WriteReply) Reset()                    { *m = WriteReply{} }
func (m *WriteReply) String() string            { return proto.CompactTextString(m) }
func (*WriteReply) ProtoMessage()               {}
func (*WriteReply) Descriptor() ([]byte, []int) { return fileDescriptorStorage, []int{6} }

// Request for a stream of Entry objects resulting from a full scan of a
// GraphStore.
type ScanRequest struct {
	// Return entries having this target VName; if empty, any target field is
	// matched, including empty.
	Target *VName `protobuf:"bytes,1,opt,name=target" json:"target,omitempty"`
	// Return entries having this kind; if empty, any kind is matched, including
	// empty.
	EdgeKind string `protobuf:"bytes,2,opt,name=edge_kind,proto3" json:"edge_kind,omitempty"`
	// Return entries having fact labels with this prefix; if empty, any fact
	// label is matched,
	FactPrefix string `protobuf:"bytes,3,opt,name=fact_prefix,proto3" json:"fact_prefix,omitempty"`
}

func (m *ScanRequest) Reset()                    { *m = ScanRequest{} }
func (m *ScanRequest) String() string            { return proto.CompactTextString(m) }
func (*ScanRequest) ProtoMessage()               {}
func (*ScanRequest) Descriptor() ([]byte, []int) { return fileDescriptorStorage, []int{7} }

func (m *ScanRequest) GetTarget() *VName {
	if m != nil {
		return m.Target
	}
	return nil
}

// Request for the size of the shard at the given index.
type CountRequest struct {
	Index  int64 `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
	Shards int64 `protobuf:"varint,2,opt,name=shards,proto3" json:"shards,omitempty"`
}

func (m *CountRequest) Reset()                    { *m = CountRequest{} }
func (m *CountRequest) String() string            { return proto.CompactTextString(m) }
func (*CountRequest) ProtoMessage()               {}
func (*CountRequest) Descriptor() ([]byte, []int) { return fileDescriptorStorage, []int{8} }

// Response for a CountRequest
type CountReply struct {
	// Total number of entries in the specified shard.
	Entries int64 `protobuf:"varint,1,opt,name=entries,proto3" json:"entries,omitempty"`
}

func (m *CountReply) Reset()                    { *m = CountReply{} }
func (m *CountReply) String() string            { return proto.CompactTextString(m) }
func (*CountReply) ProtoMessage()               {}
func (*CountReply) Descriptor() ([]byte, []int) { return fileDescriptorStorage, []int{9} }

// Request for a stream of Entry objects in the given shard.
type ShardRequest struct {
	Index  int64 `protobuf:"varint,1,opt,name=index,proto3" json:"index,omitempty"`
	Shards int64 `protobuf:"varint,2,opt,name=shards,proto3" json:"shards,omitempty"`
}

func (m *ShardRequest) Reset()                    { *m = ShardRequest{} }
func (m *ShardRequest) String() string            { return proto.CompactTextString(m) }
func (*ShardRequest) ProtoMessage()               {}
func (*ShardRequest) Descriptor() ([]byte, []int) { return fileDescriptorStorage, []int{10} }

// Request for the set of node tickets matching a partial VName and collection
// of known facts.
type SearchRequest struct {
	// Partial VName to match against nodes.  Each non-empty field becomes a
	// constraint (i.e. the signature/corpus/etc. must be exactly case-sensitively
	// equal to the given string) on the set of returned nodes.  Exact matching
	// turns into prefix matching if the corresponding field in partial_prefix is
	// set to true.
	Partial *VName `protobuf:"bytes,1,opt,name=partial" json:"partial,omitempty"`
	// Facts that a node must have to be matched.  Exact matching turns into
	// prefix matching if a Fact has its prefix field set to true.
	Fact []*SearchRequest_Fact `protobuf:"bytes,2,rep,name=fact" json:"fact,omitempty"`
	// Setting any field in this mask to true converts exact value matching to
	// prefix value matching for the corresponding VName component in partial.
	PartialPrefix *VNameMask `protobuf:"bytes,3,opt,name=partial_prefix" json:"partial_prefix,omitempty"`
}

func (m *SearchRequest) Reset()                    { *m = SearchRequest{} }
func (m *SearchRequest) String() string            { return proto.CompactTextString(m) }
func (*SearchRequest) ProtoMessage()               {}
func (*SearchRequest) Descriptor() ([]byte, []int) { return fileDescriptorStorage, []int{11} }

func (m *SearchRequest) GetPartial() *VName {
	if m != nil {
		return m.Partial
	}
	return nil
}

func (m *SearchRequest) GetFact() []*SearchRequest_Fact {
	if m != nil {
		return m.Fact
	}
	return nil
}

func (m *SearchRequest) GetPartialPrefix() *VNameMask {
	if m != nil {
		return m.PartialPrefix
	}
	return nil
}

type SearchRequest_Fact struct {
	Name   string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Value  []byte `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	Prefix bool   `protobuf:"varint,3,opt,name=prefix,proto3" json:"prefix,omitempty"`
}

func (m *SearchRequest_Fact) Reset()                    { *m = SearchRequest_Fact{} }
func (m *SearchRequest_Fact) String() string            { return proto.CompactTextString(m) }
func (*SearchRequest_Fact) ProtoMessage()               {}
func (*SearchRequest_Fact) Descriptor() ([]byte, []int) { return fileDescriptorStorage, []int{11, 0} }

// Response for a SearchRequest.
type SearchReply struct {
	// Set of node tickets matching a given SearchRequest.
	Ticket []string `protobuf:"bytes,1,rep,name=ticket" json:"ticket,omitempty"`
}

func (m *SearchReply) Reset()                    { *m = SearchReply{} }
func (m *SearchReply) String() string            { return proto.CompactTextString(m) }
func (*SearchReply) ProtoMessage()               {}
func (*SearchReply) Descriptor() ([]byte, []int) { return fileDescriptorStorage, []int{12} }

func init() {
	proto.RegisterType((*VName)(nil), "kythe.proto.VName")
	proto.RegisterType((*VNameMask)(nil), "kythe.proto.VNameMask")
	proto.RegisterType((*Entry)(nil), "kythe.proto.Entry")
	proto.RegisterType((*Entries)(nil), "kythe.proto.Entries")
	proto.RegisterType((*ReadRequest)(nil), "kythe.proto.ReadRequest")
	proto.RegisterType((*WriteRequest)(nil), "kythe.proto.WriteRequest")
	proto.RegisterType((*WriteRequest_Update)(nil), "kythe.proto.WriteRequest.Update")
	proto.RegisterType((*WriteReply)(nil), "kythe.proto.WriteReply")
	proto.RegisterType((*ScanRequest)(nil), "kythe.proto.ScanRequest")
	proto.RegisterType((*CountRequest)(nil), "kythe.proto.CountRequest")
	proto.RegisterType((*CountReply)(nil), "kythe.proto.CountReply")
	proto.RegisterType((*ShardRequest)(nil), "kythe.proto.ShardRequest")
	proto.RegisterType((*SearchRequest)(nil), "kythe.proto.SearchRequest")
	proto.RegisterType((*SearchRequest_Fact)(nil), "kythe.proto.SearchRequest.Fact")
	proto.RegisterType((*SearchReply)(nil), "kythe.proto.SearchReply")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion2

// Client API for GraphStore service

type GraphStoreClient interface {
	// Read responds with all Entry messages that match the given ReadRequest.
	// The Read operation should be implemented with time complexity proportional
	// to the size of the return set.
	Read(ctx context.Context, in *ReadRequest, opts ...grpc.CallOption) (GraphStore_ReadClient, error)
	// Scan responds with all Entry messages matching the given ScanRequest.  If a
	// ScanRequest field is empty, any entry value for that field matches and will
	// be returned.  Scan is similar to Read, but with no time complexity
	// restrictions.
	Scan(ctx context.Context, in *ScanRequest, opts ...grpc.CallOption) (GraphStore_ScanClient, error)
	// Write atomically inserts or updates a collection of entries into the store.
	// Each update is a tuple of the form (kind, target, fact, value).  For each
	// such update, an entry (source, kind, target, fact, value) is written into
	// the store, replacing any existing entry (source, kind, target, fact,
	// value') that may exist.  Note that this operation cannot delete any data
	// from the store; entries are only ever inserted or updated.  Apart from
	// acting atomically, no other constraints are placed on the implementation.
	Write(ctx context.Context, in *WriteRequest, opts ...grpc.CallOption) (*WriteReply, error)
}

type graphStoreClient struct {
	cc *grpc.ClientConn
}

func NewGraphStoreClient(cc *grpc.ClientConn) GraphStoreClient {
	return &graphStoreClient{cc}
}

func (c *graphStoreClient) Read(ctx context.Context, in *ReadRequest, opts ...grpc.CallOption) (GraphStore_ReadClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_GraphStore_serviceDesc.Streams[0], c.cc, "/kythe.proto.GraphStore/Read", opts...)
	if err != nil {
		return nil, err
	}
	x := &graphStoreReadClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type GraphStore_ReadClient interface {
	Recv() (*Entry, error)
	grpc.ClientStream
}

type graphStoreReadClient struct {
	grpc.ClientStream
}

func (x *graphStoreReadClient) Recv() (*Entry, error) {
	m := new(Entry)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *graphStoreClient) Scan(ctx context.Context, in *ScanRequest, opts ...grpc.CallOption) (GraphStore_ScanClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_GraphStore_serviceDesc.Streams[1], c.cc, "/kythe.proto.GraphStore/Scan", opts...)
	if err != nil {
		return nil, err
	}
	x := &graphStoreScanClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type GraphStore_ScanClient interface {
	Recv() (*Entry, error)
	grpc.ClientStream
}

type graphStoreScanClient struct {
	grpc.ClientStream
}

func (x *graphStoreScanClient) Recv() (*Entry, error) {
	m := new(Entry)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *graphStoreClient) Write(ctx context.Context, in *WriteRequest, opts ...grpc.CallOption) (*WriteReply, error) {
	out := new(WriteReply)
	err := grpc.Invoke(ctx, "/kythe.proto.GraphStore/Write", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for GraphStore service

type GraphStoreServer interface {
	// Read responds with all Entry messages that match the given ReadRequest.
	// The Read operation should be implemented with time complexity proportional
	// to the size of the return set.
	Read(*ReadRequest, GraphStore_ReadServer) error
	// Scan responds with all Entry messages matching the given ScanRequest.  If a
	// ScanRequest field is empty, any entry value for that field matches and will
	// be returned.  Scan is similar to Read, but with no time complexity
	// restrictions.
	Scan(*ScanRequest, GraphStore_ScanServer) error
	// Write atomically inserts or updates a collection of entries into the store.
	// Each update is a tuple of the form (kind, target, fact, value).  For each
	// such update, an entry (source, kind, target, fact, value) is written into
	// the store, replacing any existing entry (source, kind, target, fact,
	// value') that may exist.  Note that this operation cannot delete any data
	// from the store; entries are only ever inserted or updated.  Apart from
	// acting atomically, no other constraints are placed on the implementation.
	Write(context.Context, *WriteRequest) (*WriteReply, error)
}

func RegisterGraphStoreServer(s *grpc.Server, srv GraphStoreServer) {
	s.RegisterService(&_GraphStore_serviceDesc, srv)
}

func _GraphStore_Read_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ReadRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(GraphStoreServer).Read(m, &graphStoreReadServer{stream})
}

type GraphStore_ReadServer interface {
	Send(*Entry) error
	grpc.ServerStream
}

type graphStoreReadServer struct {
	grpc.ServerStream
}

func (x *graphStoreReadServer) Send(m *Entry) error {
	return x.ServerStream.SendMsg(m)
}

func _GraphStore_Scan_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ScanRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(GraphStoreServer).Scan(m, &graphStoreScanServer{stream})
}

type GraphStore_ScanServer interface {
	Send(*Entry) error
	grpc.ServerStream
}

type graphStoreScanServer struct {
	grpc.ServerStream
}

func (x *graphStoreScanServer) Send(m *Entry) error {
	return x.ServerStream.SendMsg(m)
}

func _GraphStore_Write_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(WriteRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(GraphStoreServer).Write(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kythe.proto.GraphStore/Write",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(GraphStoreServer).Write(ctx, req.(*WriteRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _GraphStore_serviceDesc = grpc.ServiceDesc{
	ServiceName: "kythe.proto.GraphStore",
	HandlerType: (*GraphStoreServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Write",
			Handler:    _GraphStore_Write_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Read",
			Handler:       _GraphStore_Read_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Scan",
			Handler:       _GraphStore_Scan_Handler,
			ServerStreams: true,
		},
	},
}

// Client API for ShardedGraphStore service

type ShardedGraphStoreClient interface {
	// Count returns the number of entries in the given shard.
	Count(ctx context.Context, in *CountRequest, opts ...grpc.CallOption) (*CountReply, error)
	// Shard responds with each Entry in the given shard.
	Shard(ctx context.Context, in *ShardRequest, opts ...grpc.CallOption) (ShardedGraphStore_ShardClient, error)
}

type shardedGraphStoreClient struct {
	cc *grpc.ClientConn
}

func NewShardedGraphStoreClient(cc *grpc.ClientConn) ShardedGraphStoreClient {
	return &shardedGraphStoreClient{cc}
}

func (c *shardedGraphStoreClient) Count(ctx context.Context, in *CountRequest, opts ...grpc.CallOption) (*CountReply, error) {
	out := new(CountReply)
	err := grpc.Invoke(ctx, "/kythe.proto.ShardedGraphStore/Count", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *shardedGraphStoreClient) Shard(ctx context.Context, in *ShardRequest, opts ...grpc.CallOption) (ShardedGraphStore_ShardClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_ShardedGraphStore_serviceDesc.Streams[0], c.cc, "/kythe.proto.ShardedGraphStore/Shard", opts...)
	if err != nil {
		return nil, err
	}
	x := &shardedGraphStoreShardClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type ShardedGraphStore_ShardClient interface {
	Recv() (*Entry, error)
	grpc.ClientStream
}

type shardedGraphStoreShardClient struct {
	grpc.ClientStream
}

func (x *shardedGraphStoreShardClient) Recv() (*Entry, error) {
	m := new(Entry)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for ShardedGraphStore service

type ShardedGraphStoreServer interface {
	// Count returns the number of entries in the given shard.
	Count(context.Context, *CountRequest) (*CountReply, error)
	// Shard responds with each Entry in the given shard.
	Shard(*ShardRequest, ShardedGraphStore_ShardServer) error
}

func RegisterShardedGraphStoreServer(s *grpc.Server, srv ShardedGraphStoreServer) {
	s.RegisterService(&_ShardedGraphStore_serviceDesc, srv)
}

func _ShardedGraphStore_Count_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(CountRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ShardedGraphStoreServer).Count(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kythe.proto.ShardedGraphStore/Count",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ShardedGraphStoreServer).Count(ctx, req.(*CountRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ShardedGraphStore_Shard_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(ShardRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(ShardedGraphStoreServer).Shard(m, &shardedGraphStoreShardServer{stream})
}

type ShardedGraphStore_ShardServer interface {
	Send(*Entry) error
	grpc.ServerStream
}

type shardedGraphStoreShardServer struct {
	grpc.ServerStream
}

func (x *shardedGraphStoreShardServer) Send(m *Entry) error {
	return x.ServerStream.SendMsg(m)
}

var _ShardedGraphStore_serviceDesc = grpc.ServiceDesc{
	ServiceName: "kythe.proto.ShardedGraphStore",
	HandlerType: (*ShardedGraphStoreServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Count",
			Handler:    _ShardedGraphStore_Count_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Shard",
			Handler:       _ShardedGraphStore_Shard_Handler,
			ServerStreams: true,
		},
	},
}

// Client API for SearchService service

type SearchServiceClient interface {
	// Search responds with the set of node tickets that match the given
	// SearchRequest.
	Search(ctx context.Context, in *SearchRequest, opts ...grpc.CallOption) (*SearchReply, error)
}

type searchServiceClient struct {
	cc *grpc.ClientConn
}

func NewSearchServiceClient(cc *grpc.ClientConn) SearchServiceClient {
	return &searchServiceClient{cc}
}

func (c *searchServiceClient) Search(ctx context.Context, in *SearchRequest, opts ...grpc.CallOption) (*SearchReply, error) {
	out := new(SearchReply)
	err := grpc.Invoke(ctx, "/kythe.proto.SearchService/Search", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for SearchService service

type SearchServiceServer interface {
	// Search responds with the set of node tickets that match the given
	// SearchRequest.
	Search(context.Context, *SearchRequest) (*SearchReply, error)
}

func RegisterSearchServiceServer(s *grpc.Server, srv SearchServiceServer) {
	s.RegisterService(&_SearchService_serviceDesc, srv)
}

func _SearchService_Search_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(SearchRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(SearchServiceServer).Search(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/kythe.proto.SearchService/Search",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(SearchServiceServer).Search(ctx, req.(*SearchRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _SearchService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "kythe.proto.SearchService",
	HandlerType: (*SearchServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Search",
			Handler:    _SearchService_Search_Handler,
		},
	},
	Streams: []grpc.StreamDesc{},
}

func (m *VName) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VName) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Signature) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintStorage(data, i, uint64(len(m.Signature)))
		i += copy(data[i:], m.Signature)
	}
	if len(m.Corpus) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintStorage(data, i, uint64(len(m.Corpus)))
		i += copy(data[i:], m.Corpus)
	}
	if len(m.Root) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintStorage(data, i, uint64(len(m.Root)))
		i += copy(data[i:], m.Root)
	}
	if len(m.Path) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintStorage(data, i, uint64(len(m.Path)))
		i += copy(data[i:], m.Path)
	}
	if len(m.Language) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintStorage(data, i, uint64(len(m.Language)))
		i += copy(data[i:], m.Language)
	}
	return i, nil
}

func (m *VNameMask) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *VNameMask) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Signature {
		data[i] = 0x8
		i++
		if m.Signature {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Corpus {
		data[i] = 0x10
		i++
		if m.Corpus {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Root {
		data[i] = 0x18
		i++
		if m.Root {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Path {
		data[i] = 0x20
		i++
		if m.Path {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if m.Language {
		data[i] = 0x28
		i++
		if m.Language {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *Entry) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Entry) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Source != nil {
		data[i] = 0xa
		i++
		i = encodeVarintStorage(data, i, uint64(m.Source.Size()))
		n1, err := m.Source.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if len(m.EdgeKind) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintStorage(data, i, uint64(len(m.EdgeKind)))
		i += copy(data[i:], m.EdgeKind)
	}
	if m.Target != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintStorage(data, i, uint64(m.Target.Size()))
		n2, err := m.Target.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if len(m.FactName) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintStorage(data, i, uint64(len(m.FactName)))
		i += copy(data[i:], m.FactName)
	}
	if len(m.FactValue) > 0 {
		data[i] = 0x2a
		i++
		i = encodeVarintStorage(data, i, uint64(len(m.FactValue)))
		i += copy(data[i:], m.FactValue)
	}
	return i, nil
}

func (m *Entries) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *Entries) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for _, msg := range m.Entries {
			data[i] = 0xa
			i++
			i = encodeVarintStorage(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *ReadRequest) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ReadRequest) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Source != nil {
		data[i] = 0xa
		i++
		i = encodeVarintStorage(data, i, uint64(m.Source.Size()))
		n3, err := m.Source.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if len(m.EdgeKind) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintStorage(data, i, uint64(len(m.EdgeKind)))
		i += copy(data[i:], m.EdgeKind)
	}
	return i, nil
}

func (m *WriteRequest) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *WriteRequest) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Source != nil {
		data[i] = 0xa
		i++
		i = encodeVarintStorage(data, i, uint64(m.Source.Size()))
		n4, err := m.Source.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if len(m.Update) > 0 {
		for _, msg := range m.Update {
			data[i] = 0x12
			i++
			i = encodeVarintStorage(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *WriteRequest_Update) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *WriteRequest_Update) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.EdgeKind) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintStorage(data, i, uint64(len(m.EdgeKind)))
		i += copy(data[i:], m.EdgeKind)
	}
	if m.Target != nil {
		data[i] = 0x12
		i++
		i = encodeVarintStorage(data, i, uint64(m.Target.Size()))
		n5, err := m.Target.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if len(m.FactName) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintStorage(data, i, uint64(len(m.FactName)))
		i += copy(data[i:], m.FactName)
	}
	if len(m.FactValue) > 0 {
		data[i] = 0x22
		i++
		i = encodeVarintStorage(data, i, uint64(len(m.FactValue)))
		i += copy(data[i:], m.FactValue)
	}
	return i, nil
}

func (m *WriteReply) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *WriteReply) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	return i, nil
}

func (m *ScanRequest) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ScanRequest) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Target != nil {
		data[i] = 0xa
		i++
		i = encodeVarintStorage(data, i, uint64(m.Target.Size()))
		n6, err := m.Target.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n6
	}
	if len(m.EdgeKind) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintStorage(data, i, uint64(len(m.EdgeKind)))
		i += copy(data[i:], m.EdgeKind)
	}
	if len(m.FactPrefix) > 0 {
		data[i] = 0x1a
		i++
		i = encodeVarintStorage(data, i, uint64(len(m.FactPrefix)))
		i += copy(data[i:], m.FactPrefix)
	}
	return i, nil
}

func (m *CountRequest) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CountRequest) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Index != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintStorage(data, i, uint64(m.Index))
	}
	if m.Shards != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintStorage(data, i, uint64(m.Shards))
	}
	return i, nil
}

func (m *CountReply) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CountReply) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Entries != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintStorage(data, i, uint64(m.Entries))
	}
	return i, nil
}

func (m *ShardRequest) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *ShardRequest) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Index != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintStorage(data, i, uint64(m.Index))
	}
	if m.Shards != 0 {
		data[i] = 0x10
		i++
		i = encodeVarintStorage(data, i, uint64(m.Shards))
	}
	return i, nil
}

func (m *SearchRequest) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SearchRequest) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Partial != nil {
		data[i] = 0xa
		i++
		i = encodeVarintStorage(data, i, uint64(m.Partial.Size()))
		n7, err := m.Partial.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n7
	}
	if len(m.Fact) > 0 {
		for _, msg := range m.Fact {
			data[i] = 0x12
			i++
			i = encodeVarintStorage(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.PartialPrefix != nil {
		data[i] = 0x1a
		i++
		i = encodeVarintStorage(data, i, uint64(m.PartialPrefix.Size()))
		n8, err := m.PartialPrefix.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n8
	}
	return i, nil
}

func (m *SearchRequest_Fact) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SearchRequest_Fact) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintStorage(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	if len(m.Value) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintStorage(data, i, uint64(len(m.Value)))
		i += copy(data[i:], m.Value)
	}
	if m.Prefix {
		data[i] = 0x18
		i++
		if m.Prefix {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *SearchReply) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *SearchReply) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Ticket) > 0 {
		for _, s := range m.Ticket {
			data[i] = 0xa
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	return i, nil
}

func encodeFixed64Storage(data []byte, offset int, v uint64) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	data[offset+4] = uint8(v >> 32)
	data[offset+5] = uint8(v >> 40)
	data[offset+6] = uint8(v >> 48)
	data[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Storage(data []byte, offset int, v uint32) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintStorage(data []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		data[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	data[offset] = uint8(v)
	return offset + 1
}
func (m *VName) Size() (n int) {
	var l int
	_ = l
	l = len(m.Signature)
	if l > 0 {
		n += 1 + l + sovStorage(uint64(l))
	}
	l = len(m.Corpus)
	if l > 0 {
		n += 1 + l + sovStorage(uint64(l))
	}
	l = len(m.Root)
	if l > 0 {
		n += 1 + l + sovStorage(uint64(l))
	}
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovStorage(uint64(l))
	}
	l = len(m.Language)
	if l > 0 {
		n += 1 + l + sovStorage(uint64(l))
	}
	return n
}

func (m *VNameMask) Size() (n int) {
	var l int
	_ = l
	if m.Signature {
		n += 2
	}
	if m.Corpus {
		n += 2
	}
	if m.Root {
		n += 2
	}
	if m.Path {
		n += 2
	}
	if m.Language {
		n += 2
	}
	return n
}

func (m *Entry) Size() (n int) {
	var l int
	_ = l
	if m.Source != nil {
		l = m.Source.Size()
		n += 1 + l + sovStorage(uint64(l))
	}
	l = len(m.EdgeKind)
	if l > 0 {
		n += 1 + l + sovStorage(uint64(l))
	}
	if m.Target != nil {
		l = m.Target.Size()
		n += 1 + l + sovStorage(uint64(l))
	}
	l = len(m.FactName)
	if l > 0 {
		n += 1 + l + sovStorage(uint64(l))
	}
	l = len(m.FactValue)
	if l > 0 {
		n += 1 + l + sovStorage(uint64(l))
	}
	return n
}

func (m *Entries) Size() (n int) {
	var l int
	_ = l
	if len(m.Entries) > 0 {
		for _, e := range m.Entries {
			l = e.Size()
			n += 1 + l + sovStorage(uint64(l))
		}
	}
	return n
}

func (m *ReadRequest) Size() (n int) {
	var l int
	_ = l
	if m.Source != nil {
		l = m.Source.Size()
		n += 1 + l + sovStorage(uint64(l))
	}
	l = len(m.EdgeKind)
	if l > 0 {
		n += 1 + l + sovStorage(uint64(l))
	}
	return n
}

func (m *WriteRequest) Size() (n int) {
	var l int
	_ = l
	if m.Source != nil {
		l = m.Source.Size()
		n += 1 + l + sovStorage(uint64(l))
	}
	if len(m.Update) > 0 {
		for _, e := range m.Update {
			l = e.Size()
			n += 1 + l + sovStorage(uint64(l))
		}
	}
	return n
}

func (m *WriteRequest_Update) Size() (n int) {
	var l int
	_ = l
	l = len(m.EdgeKind)
	if l > 0 {
		n += 1 + l + sovStorage(uint64(l))
	}
	if m.Target != nil {
		l = m.Target.Size()
		n += 1 + l + sovStorage(uint64(l))
	}
	l = len(m.FactName)
	if l > 0 {
		n += 1 + l + sovStorage(uint64(l))
	}
	l = len(m.FactValue)
	if l > 0 {
		n += 1 + l + sovStorage(uint64(l))
	}
	return n
}

func (m *WriteReply) Size() (n int) {
	var l int
	_ = l
	return n
}

func (m *ScanRequest) Size() (n int) {
	var l int
	_ = l
	if m.Target != nil {
		l = m.Target.Size()
		n += 1 + l + sovStorage(uint64(l))
	}
	l = len(m.EdgeKind)
	if l > 0 {
		n += 1 + l + sovStorage(uint64(l))
	}
	l = len(m.FactPrefix)
	if l > 0 {
		n += 1 + l + sovStorage(uint64(l))
	}
	return n
}

func (m *CountRequest) Size() (n int) {
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovStorage(uint64(m.Index))
	}
	if m.Shards != 0 {
		n += 1 + sovStorage(uint64(m.Shards))
	}
	return n
}

func (m *CountReply) Size() (n int) {
	var l int
	_ = l
	if m.Entries != 0 {
		n += 1 + sovStorage(uint64(m.Entries))
	}
	return n
}

func (m *ShardRequest) Size() (n int) {
	var l int
	_ = l
	if m.Index != 0 {
		n += 1 + sovStorage(uint64(m.Index))
	}
	if m.Shards != 0 {
		n += 1 + sovStorage(uint64(m.Shards))
	}
	return n
}

func (m *SearchRequest) Size() (n int) {
	var l int
	_ = l
	if m.Partial != nil {
		l = m.Partial.Size()
		n += 1 + l + sovStorage(uint64(l))
	}
	if len(m.Fact) > 0 {
		for _, e := range m.Fact {
			l = e.Size()
			n += 1 + l + sovStorage(uint64(l))
		}
	}
	if m.PartialPrefix != nil {
		l = m.PartialPrefix.Size()
		n += 1 + l + sovStorage(uint64(l))
	}
	return n
}

func (m *SearchRequest_Fact) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovStorage(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovStorage(uint64(l))
	}
	if m.Prefix {
		n += 2
	}
	return n
}

func (m *SearchReply) Size() (n int) {
	var l int
	_ = l
	if len(m.Ticket) > 0 {
		for _, s := range m.Ticket {
			l = len(s)
			n += 1 + l + sovStorage(uint64(l))
		}
	}
	return n
}

func sovStorage(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozStorage(x uint64) (n int) {
	return sovStorage(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *VName) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStorage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VName: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VName: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStorage
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Signature = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Corpus", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStorage
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Corpus = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Root", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStorage
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Root = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStorage
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Language", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStorage
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Language = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStorage(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStorage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *VNameMask) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStorage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: VNameMask: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: VNameMask: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Signature", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Signature = bool(v != 0)
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Corpus", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Corpus = bool(v != 0)
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Root", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Root = bool(v != 0)
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Path = bool(v != 0)
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Language", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Language = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipStorage(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStorage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Entry) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStorage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Entry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Entry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStorage
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Source == nil {
				m.Source = &VName{}
			}
			if err := m.Source.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EdgeKind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStorage
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EdgeKind = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStorage
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Target == nil {
				m.Target = &VName{}
			}
			if err := m.Target.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FactName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStorage
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FactName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FactValue", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStorage
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FactValue = append(m.FactValue[:0], data[iNdEx:postIndex]...)
			if m.FactValue == nil {
				m.FactValue = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStorage(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStorage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Entries) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStorage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Entries: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Entries: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStorage
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Entries = append(m.Entries, &Entry{})
			if err := m.Entries[len(m.Entries)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStorage(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStorage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ReadRequest) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStorage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ReadRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ReadRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStorage
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Source == nil {
				m.Source = &VName{}
			}
			if err := m.Source.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EdgeKind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStorage
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EdgeKind = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStorage(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStorage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WriteRequest) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStorage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WriteRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WriteRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Source", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStorage
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Source == nil {
				m.Source = &VName{}
			}
			if err := m.Source.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Update", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStorage
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Update = append(m.Update, &WriteRequest_Update{})
			if err := m.Update[len(m.Update)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStorage(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStorage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WriteRequest_Update) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStorage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Update: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Update: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EdgeKind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStorage
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EdgeKind = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStorage
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Target == nil {
				m.Target = &VName{}
			}
			if err := m.Target.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FactName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStorage
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FactName = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FactValue", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStorage
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FactValue = append(m.FactValue[:0], data[iNdEx:postIndex]...)
			if m.FactValue == nil {
				m.FactValue = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStorage(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStorage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *WriteReply) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStorage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: WriteReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: WriteReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipStorage(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStorage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ScanRequest) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStorage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ScanRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ScanRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Target", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStorage
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Target == nil {
				m.Target = &VName{}
			}
			if err := m.Target.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EdgeKind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStorage
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EdgeKind = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FactPrefix", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStorage
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FactPrefix = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStorage(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStorage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CountRequest) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStorage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CountRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CountRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Index |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shards", wireType)
			}
			m.Shards = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Shards |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStorage(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStorage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CountReply) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStorage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CountReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CountReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Entries", wireType)
			}
			m.Entries = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Entries |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStorage(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStorage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ShardRequest) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStorage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ShardRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ShardRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Index", wireType)
			}
			m.Index = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Index |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Shards", wireType)
			}
			m.Shards = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Shards |= (int64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipStorage(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStorage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchRequest) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStorage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Partial", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStorage
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Partial == nil {
				m.Partial = &VName{}
			}
			if err := m.Partial.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fact", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStorage
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Fact = append(m.Fact, &SearchRequest_Fact{})
			if err := m.Fact[len(m.Fact)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PartialPrefix", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthStorage
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.PartialPrefix == nil {
				m.PartialPrefix = &VNameMask{}
			}
			if err := m.PartialPrefix.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStorage(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStorage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchRequest_Fact) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStorage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Fact: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Fact: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStorage
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthStorage
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], data[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Prefix", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Prefix = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipStorage(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStorage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *SearchReply) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowStorage
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: SearchReply: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: SearchReply: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ticket", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowStorage
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthStorage
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ticket = append(m.Ticket, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipStorage(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthStorage
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipStorage(data []byte) (n int, err error) {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowStorage
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStorage
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if data[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowStorage
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthStorage
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowStorage
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipStorage(data[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthStorage = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowStorage   = fmt.Errorf("proto: integer overflow")
)

var fileDescriptorStorage = []byte{
	// 651 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x9c, 0x94, 0xcd, 0x6e, 0xd3, 0x4c,
	0x14, 0x86, 0xe3, 0x26, 0x71, 0x9d, 0x63, 0xb7, 0xdf, 0xd7, 0x41, 0x02, 0xd7, 0x12, 0x6d, 0x65,
	0x36, 0xdd, 0xd4, 0x2d, 0xe9, 0x06, 0x21, 0x21, 0x21, 0x7e, 0x57, 0x20, 0xd1, 0x88, 0x3f, 0x09,
	0xa9, 0x1a, 0xec, 0xa9, 0x63, 0xc5, 0xf5, 0x98, 0xf1, 0xb8, 0x6a, 0x2e, 0x81, 0x0d, 0x6b, 0xee,
	0x86, 0x6d, 0x17, 0x2c, 0xb8, 0x04, 0x04, 0x37, 0xc2, 0xcc, 0xd8, 0x81, 0xb1, 0x93, 0xa0, 0x96,
	0x85, 0x15, 0x8f, 0x67, 0xce, 0x73, 0xce, 0x7b, 0xce, 0x3b, 0x81, 0xcd, 0xc9, 0x94, 0x8f, 0xc9,
	0x7e, 0xce, 0x28, 0xa7, 0xfb, 0x05, 0xa7, 0x0c, 0xc7, 0x24, 0x50, 0x2b, 0x64, 0xab, 0xad, 0x6a,
	0xe1, 0xbf, 0x81, 0xfe, 0xab, 0xe7, 0xf8, 0x94, 0xa0, 0x0d, 0x18, 0x14, 0x49, 0x9c, 0x61, 0x5e,
	0x32, 0xe2, 0x1a, 0x3b, 0xc6, 0xee, 0x00, 0xad, 0x83, 0x19, 0x52, 0x96, 0x97, 0x85, 0xbb, 0xa2,
	0xd6, 0x0e, 0xf4, 0x18, 0xa5, 0xdc, 0xed, 0xce, 0x56, 0x39, 0xe6, 0x63, 0xb7, 0xa7, 0x56, 0xff,
	0x83, 0x95, 0xe2, 0x2c, 0x2e, 0x45, 0x1a, 0xb7, 0x2f, 0xbf, 0xf8, 0xef, 0x60, 0xa0, 0xc8, 0xcf,
	0x70, 0x31, 0x99, 0xa7, 0x5b, 0x2d, 0xba, 0xd5, 0xa0, 0x5b, 0x0d, 0xba, 0x35, 0x47, 0xb7, 0xfc,
	0x8f, 0x06, 0xf4, 0x1f, 0x67, 0x9c, 0x4d, 0x91, 0x0f, 0x66, 0x41, 0x4b, 0x16, 0x56, 0x5c, 0x7b,
	0x88, 0x02, 0x4d, 0x5f, 0xf0, 0x5b, 0x1c, 0x89, 0x62, 0x72, 0x3c, 0x49, 0xb2, 0xa8, 0x16, 0x23,
	0xc2, 0x38, 0x66, 0x31, 0xa9, 0x12, 0x2e, 0x0d, 0x3b, 0xc1, 0x21, 0x3f, 0xce, 0xc4, 0xa2, 0xd6,
	0x89, 0x00, 0xd4, 0xa7, 0x33, 0x9c, 0x96, 0x55, 0x2d, 0x8e, 0x1f, 0xc0, 0xaa, 0x2c, 0x25, 0x21,
	0x05, 0xba, 0x05, 0xab, 0xa4, 0x7a, 0x15, 0xd5, 0x74, 0xe7, 0xb0, 0xaa, 0x62, 0xff, 0x11, 0xd8,
	0x47, 0x04, 0x47, 0x47, 0xe4, 0x43, 0x49, 0x0a, 0xfe, 0x8f, 0x02, 0xfc, 0xaf, 0x06, 0x38, 0xaf,
	0x59, 0xc2, 0xc9, 0x55, 0x38, 0x07, 0x60, 0x96, 0x79, 0x84, 0x39, 0x11, 0x10, 0x59, 0xde, 0x4e,
	0xe3, 0x8c, 0x8e, 0x0b, 0x5e, 0xaa, 0x73, 0xde, 0x09, 0x98, 0xd5, 0x5b, 0xb3, 0x06, 0xa3, 0xd5,
	0xc4, 0x95, 0xcb, 0x35, 0xb1, 0xbb, 0xa0, 0x89, 0x3d, 0xd5, 0x44, 0x07, 0xa0, 0x4e, 0x9f, 0xa7,
	0x53, 0xff, 0x2d, 0xd8, 0xa3, 0x10, 0x67, 0x9a, 0xb4, 0x3a, 0xcf, 0x95, 0x66, 0x7c, 0x0d, 0x6c,
	0x95, 0x27, 0x67, 0xe4, 0x24, 0x39, 0xaf, 0x92, 0xfb, 0x7b, 0xe0, 0x3c, 0xa4, 0x65, 0xc6, 0x67,
	0xec, 0x35, 0xe8, 0x8b, 0x08, 0x72, 0xae, 0xd0, 0x5d, 0x69, 0xcb, 0x62, 0x8c, 0x59, 0x54, 0xd9,
	0xb2, 0xeb, 0xdf, 0x04, 0xa8, 0x8f, 0x8b, 0xba, 0xd0, 0x7f, 0xfa, 0x7c, 0xe5, 0xb6, 0xa0, 0x8d,
	0xe4, 0xf1, 0x4b, 0xd2, 0x2e, 0x0c, 0x58, 0x1b, 0x11, 0xcc, 0xc2, 0xf1, 0x2c, 0x40, 0x38, 0x26,
	0xc7, 0x8c, 0x27, 0x38, 0xfd, 0x8b, 0xb6, 0x3d, 0xe8, 0x49, 0x21, 0xf5, 0xd0, 0xb6, 0x1b, 0x27,
	0x1a, 0xb8, 0xe0, 0x89, 0x38, 0x86, 0x02, 0x58, 0xaf, 0x99, 0xba, 0x74, 0x7b, 0x78, 0x7d, 0x1e,
	0x2d, 0x6f, 0xa7, 0x77, 0x08, 0x3d, 0x15, 0x27, 0x2e, 0x9d, 0x9a, 0x52, 0x35, 0x5c, 0x21, 0xa5,
	0x1a, 0x90, 0x2c, 0xdd, 0x91, 0x52, 0x34, 0x98, 0x25, 0x1a, 0x63, 0xcf, 0x52, 0xcb, 0xce, 0x88,
	0x6d, 0x9e, 0x84, 0x13, 0x35, 0xa2, 0xee, 0xee, 0x60, 0xf8, 0xc5, 0x00, 0x78, 0xca, 0x70, 0x3e,
	0x1e, 0x89, 0x3f, 0x1f, 0x82, 0xee, 0x40, 0x4f, 0x7a, 0x1e, 0xb9, 0x8d, 0x12, 0xb4, 0x6b, 0xe0,
	0x2d, 0xba, 0x29, 0x9d, 0x03, 0x43, 0x46, 0x4a, 0x2b, 0xb4, 0x22, 0x35, 0x77, 0x2c, 0x8d, 0xbc,
	0x07, 0x7d, 0x65, 0x29, 0xb4, 0xb9, 0xd4, 0xe5, 0xde, 0x8d, 0x45, 0x5b, 0xd2, 0x81, 0x9d, 0xe1,
	0x27, 0x03, 0x36, 0xd4, 0x6c, 0x49, 0xa4, 0x09, 0x11, 0x50, 0xe5, 0x87, 0x16, 0x54, 0xb7, 0x54,
	0x0b, 0xfa, 0xc7, 0x3e, 0x7e, 0x07, 0xdd, 0x85, 0xbe, 0x62, 0xb6, 0xc2, 0x75, 0x0f, 0x2d, 0xd3,
	0x33, 0x7c, 0x31, 0xf3, 0xce, 0x88, 0xb0, 0xb3, 0x24, 0x24, 0xe8, 0x3e, 0x98, 0xd5, 0x07, 0xe4,
	0x2d, 0xb7, 0x84, 0xe7, 0x2e, 0xdc, 0x53, 0xe5, 0x3c, 0xb8, 0x7d, 0xf1, 0x63, 0xcb, 0xf8, 0x26,
	0x9e, 0xef, 0xe2, 0xf9, 0xfc, 0x73, 0xab, 0x03, 0xdb, 0x21, 0x3d, 0x0d, 0x62, 0x4a, 0xe3, 0x94,
	0x04, 0x11, 0x39, 0xe3, 0x94, 0xa6, 0x85, 0x0e, 0x78, 0x6f, 0xaa, 0x9f, 0xc3, 0x5f, 0x01, 0x00,
	0x00, 0xff, 0xff, 0x97, 0xdf, 0x8f, 0x89, 0x62, 0x06, 0x00, 0x00,
}
