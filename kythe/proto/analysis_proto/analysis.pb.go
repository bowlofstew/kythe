// Code generated by protoc-gen-gogo.
// source: kythe/proto/analysis.proto
// DO NOT EDIT!

/*
	Package analysis_proto is a generated protocol buffer package.

	It is generated from these files:
		kythe/proto/analysis.proto

	It has these top-level messages:
		AnalysisRequest
		AnalysisOutput
		CompilationUnit
		FilesRequest
		FileInfo
		FileData
*/
package analysis_proto

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf "kythe.io/third_party/proto/any_proto"
import kythe_proto "kythe.io/kythe/proto/storage_proto"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

import io "io"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
const _ = proto.ProtoPackageIsVersion1

// An AnalysisRequest instructs an analyzer to perform an analysis on a single
// CompilationUnit.
type AnalysisRequest struct {
	// The compilation to analyze.
	Compilation *CompilationUnit `protobuf:"bytes,1,opt,name=compilation" json:"compilation,omitempty"`
	// The address of a file data service to use.  If this is provided, it should
	// be used in preference to any other file data service the analyzer may know
	// about for this compilation.
	FileDataService string `protobuf:"bytes,2,opt,name=file_data_service,proto3" json:"file_data_service,omitempty"`
}

func (m *AnalysisRequest) Reset()                    { *m = AnalysisRequest{} }
func (m *AnalysisRequest) String() string            { return proto.CompactTextString(m) }
func (*AnalysisRequest) ProtoMessage()               {}
func (*AnalysisRequest) Descriptor() ([]byte, []int) { return fileDescriptorAnalysis, []int{0} }

func (m *AnalysisRequest) GetCompilation() *CompilationUnit {
	if m != nil {
		return m.Compilation
	}
	return nil
}

// AnalysisOutput contains an output artifact for the current analysis taking
// place.  A given analysis may not produce any outputs.  It is okay for an
// indexer to send an empty AnalysisOutput message if needed to keep the RPC
// channel alive; the driver must correctly handle this.
type AnalysisOutput struct {
	Value []byte `protobuf:"bytes,1,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *AnalysisOutput) Reset()                    { *m = AnalysisOutput{} }
func (m *AnalysisOutput) String() string            { return proto.CompactTextString(m) }
func (*AnalysisOutput) ProtoMessage()               {}
func (*AnalysisOutput) Descriptor() ([]byte, []int) { return fileDescriptorAnalysis, []int{1} }

// Describes a single unit of compilation.
type CompilationUnit struct {
	// The base VName for the compilation and any generated VNames from its
	// analysis. Generally, the `language` component designates the language of
	// the compilation's sources.
	VName *kythe_proto.VName `protobuf:"bytes,1,opt,name=v_name" json:"v_name,omitempty"`
	// The revision of the compilation.
	Revision string `protobuf:"bytes,2,opt,name=revision,proto3" json:"revision,omitempty"`
	// All files that might be touched in the course of this compilation.
	// Consumers of the CompilationUnit may not assume anything about the order
	// of the elements of this field.
	RequiredInput []*CompilationUnit_FileInput `protobuf:"bytes,3,rep,name=required_input" json:"required_input,omitempty"`
	// Set by the extractor to indicate that the original input had compile
	// errors. This is used to check validity of the sharded analysis.
	HasCompileErrors bool `protobuf:"varint,4,opt,name=has_compile_errors,proto3" json:"has_compile_errors,omitempty"`
	// The arguments to pass to a compiler tool for this compilation unit,
	// including the compiler executable, flags, and input files.
	Argument []string `protobuf:"bytes,5,rep,name=argument" json:"argument,omitempty"`
	// Of those files in `required_input`, the ones that this CompilationUnit
	// is intended to analyze. This is necessary to support languages like Go,
	// where a single translation unit may contain many source files that must all
	// be processed at once (while excluding source files that belong to other
	// CUs/packages, if any).
	SourceFile []string `protobuf:"bytes,6,rep,name=source_file" json:"source_file,omitempty"`
	// The output key of the CompilationUnit; for example, the object file that
	// it writes.  The output key for a compilation should match the path in the
	// FileInfo message of a dependent compilation that consumes its output.
	OutputKey string `protobuf:"bytes,7,opt,name=output_key,proto3" json:"output_key,omitempty"`
	// The absolute path of the current working directory where the build tool
	// was invoked.  During analysis, a file whose path has working_directory
	// plus a path separator as an exact prefix is considered accessible from
	// that same path without said prefix.  It is only necessary to set this
	// field if the build tool requires it.
	WorkingDirectory string `protobuf:"bytes,8,opt,name=working_directory,proto3" json:"working_directory,omitempty"`
	// For languages that make use of resource contexts (like C++), the context
	// that should be initially entered.
	// TODO(zarko): What is a "resource context"? Needs a clear definition and/or
	// a link to one.
	EntryContext string `protobuf:"bytes,9,opt,name=entry_context,proto3" json:"entry_context,omitempty"`
	// A collection of environment variables that the build environment expects
	// to be set.  As a rule, we only record variables here that must be set to
	// specific values for the build to work.  Users of this field may not assume
	// anything about the order of values; in particular the pipeline is free to
	// sort by name in order to canonicalize the message.
	Environment []*CompilationUnit_Env `protobuf:"bytes,10,rep,name=environment" json:"environment,omitempty"`
	// Per-language or per-tool details.
	Details []*google_protobuf.Any `protobuf:"bytes,11,rep,name=details" json:"details,omitempty"`
}

func (m *CompilationUnit) Reset()                    { *m = CompilationUnit{} }
func (m *CompilationUnit) String() string            { return proto.CompactTextString(m) }
func (*CompilationUnit) ProtoMessage()               {}
func (*CompilationUnit) Descriptor() ([]byte, []int) { return fileDescriptorAnalysis, []int{2} }

func (m *CompilationUnit) GetVName() *kythe_proto.VName {
	if m != nil {
		return m.VName
	}
	return nil
}

func (m *CompilationUnit) GetRequiredInput() []*CompilationUnit_FileInput {
	if m != nil {
		return m.RequiredInput
	}
	return nil
}

func (m *CompilationUnit) GetEnvironment() []*CompilationUnit_Env {
	if m != nil {
		return m.Environment
	}
	return nil
}

func (m *CompilationUnit) GetDetails() []*google_protobuf.Any {
	if m != nil {
		return m.Details
	}
	return nil
}

// ContextDependentVersionColumn and ContextDependentVersionRow
// define a table that relates input contexts (keyed by a single
// source context per row) to tuples of (byte offset * linked context).
// When a FileInput F being processed in context C refers to another
// FileInput F' at offset O (perhaps because F has an #include directive at O)
// the context in which F' should be processed is the linked context derived
// from this table.
type CompilationUnit_ContextDependentVersionColumn struct {
	// The byte offset into the file resource.
	Offset int32 `protobuf:"varint,1,opt,name=offset,proto3" json:"offset,omitempty"`
	// The signature for the resulting context.
	LinkedContext string `protobuf:"bytes,2,opt,name=linked_context,proto3" json:"linked_context,omitempty"`
}

func (m *CompilationUnit_ContextDependentVersionColumn) Reset() {
	*m = CompilationUnit_ContextDependentVersionColumn{}
}
func (m *CompilationUnit_ContextDependentVersionColumn) String() string {
	return proto.CompactTextString(m)
}
func (*CompilationUnit_ContextDependentVersionColumn) ProtoMessage() {}
func (*CompilationUnit_ContextDependentVersionColumn) Descriptor() ([]byte, []int) {
	return fileDescriptorAnalysis, []int{2, 0}
}

// See ContextDependentVersionColumn for details.
// It is valid for a ContextDependentVersionRow to have no columns. In this
// case, the associated FileInput was seen to exist in some context C, but
// did not refer to any other FileInputs while in that context.
type CompilationUnit_ContextDependentVersionRow struct {
	// The context to be applied to all columns.
	SourceContext string `protobuf:"bytes,1,opt,name=source_context,proto3" json:"source_context,omitempty"`
	// A map from byte offsets to linked contexts.
	Column []*CompilationUnit_ContextDependentVersionColumn `protobuf:"bytes,2,rep,name=column" json:"column,omitempty"`
	// If true, this version should always be processed regardless of any
	// claiming.
	AlwaysProcess bool `protobuf:"varint,3,opt,name=always_process,proto3" json:"always_process,omitempty"`
}

func (m *CompilationUnit_ContextDependentVersionRow) Reset() {
	*m = CompilationUnit_ContextDependentVersionRow{}
}
func (m *CompilationUnit_ContextDependentVersionRow) String() string {
	return proto.CompactTextString(m)
}
func (*CompilationUnit_ContextDependentVersionRow) ProtoMessage() {}
func (*CompilationUnit_ContextDependentVersionRow) Descriptor() ([]byte, []int) {
	return fileDescriptorAnalysis, []int{2, 1}
}

func (m *CompilationUnit_ContextDependentVersionRow) GetColumn() []*CompilationUnit_ContextDependentVersionColumn {
	if m != nil {
		return m.Column
	}
	return nil
}

type CompilationUnit_FileInput struct {
	// If set, overrides the `v_name` in the `CompilationUnit` for deriving
	// VNames during analysis.
	VName *kythe_proto.VName `protobuf:"bytes,1,opt,name=v_name" json:"v_name,omitempty"`
	// The file's metadata. It is invalid to provide a FileInput without both
	// the file's path and digest.
	Info *FileInfo `protobuf:"bytes,2,opt,name=info" json:"info,omitempty"`
	// The file's context-dependent versions.
	Context []*CompilationUnit_ContextDependentVersionRow `protobuf:"bytes,3,rep,name=context" json:"context,omitempty"`
}

func (m *CompilationUnit_FileInput) Reset()         { *m = CompilationUnit_FileInput{} }
func (m *CompilationUnit_FileInput) String() string { return proto.CompactTextString(m) }
func (*CompilationUnit_FileInput) ProtoMessage()    {}
func (*CompilationUnit_FileInput) Descriptor() ([]byte, []int) {
	return fileDescriptorAnalysis, []int{2, 2}
}

func (m *CompilationUnit_FileInput) GetVName() *kythe_proto.VName {
	if m != nil {
		return m.VName
	}
	return nil
}

func (m *CompilationUnit_FileInput) GetInfo() *FileInfo {
	if m != nil {
		return m.Info
	}
	return nil
}

func (m *CompilationUnit_FileInput) GetContext() []*CompilationUnit_ContextDependentVersionRow {
	if m != nil {
		return m.Context
	}
	return nil
}

// An Env message represents the name and value of a single environment
// variable in the build environment.
type CompilationUnit_Env struct {
	Name  string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Value string `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
}

func (m *CompilationUnit_Env) Reset()                    { *m = CompilationUnit_Env{} }
func (m *CompilationUnit_Env) String() string            { return proto.CompactTextString(m) }
func (*CompilationUnit_Env) ProtoMessage()               {}
func (*CompilationUnit_Env) Descriptor() ([]byte, []int) { return fileDescriptorAnalysis, []int{2, 3} }

// A FilesRequest specifies a collection of files to be fetched from a
// FileDataService.
type FilesRequest struct {
	Files []*FileInfo `protobuf:"bytes,1,rep,name=files" json:"files,omitempty"`
}

func (m *FilesRequest) Reset()                    { *m = FilesRequest{} }
func (m *FilesRequest) String() string            { return proto.CompactTextString(m) }
func (*FilesRequest) ProtoMessage()               {}
func (*FilesRequest) Descriptor() ([]byte, []int) { return fileDescriptorAnalysis, []int{3} }

func (m *FilesRequest) GetFiles() []*FileInfo {
	if m != nil {
		return m.Files
	}
	return nil
}

// A FileInfo identifies a file used for analysis.
// At least one of the path and digest fields must be non-empty.
type FileInfo struct {
	// The path of the file relative to the working directory of the compilation
	// command, which is typically the root of the build.
	// For example:
	//  file/base/file.cc
	//  ../../base/atomic_ref_count.h
	Path string `protobuf:"bytes,1,opt,name=path,proto3" json:"path,omitempty"`
	// The lowercase ascii hex SHA-256 digest of the file contents.
	Digest string `protobuf:"bytes,2,opt,name=digest,proto3" json:"digest,omitempty"`
}

func (m *FileInfo) Reset()                    { *m = FileInfo{} }
func (m *FileInfo) String() string            { return proto.CompactTextString(m) }
func (*FileInfo) ProtoMessage()               {}
func (*FileInfo) Descriptor() ([]byte, []int) { return fileDescriptorAnalysis, []int{4} }

// A FileData carries the content of a single file, as returned from the Get
// method of a FileDataService.
type FileData struct {
	// The content of the file, if known.  If missing == true, this field must be
	// empty.
	Content []byte `protobuf:"bytes,1,opt,name=content,proto3" json:"content,omitempty"`
	// A (possibly normalized) copy of the non-empty fields of the FileInfo
	// message from the Get request.  If either field from the original request
	// was empty, the server may optionally fill in that field in the reply if it
	// is known.  For example, if the client requested a file by path only and
	// the server found it, the reply MAY fill in the digest.
	Info *FileInfo `protobuf:"bytes,2,opt,name=info" json:"info,omitempty"`
	// If true, no data are available for the requested file, and the content
	// field must be empty.  If false, the content field contains the complete
	// file content (which may be empty).
	Missing bool `protobuf:"varint,3,opt,name=missing,proto3" json:"missing,omitempty"`
}

func (m *FileData) Reset()                    { *m = FileData{} }
func (m *FileData) String() string            { return proto.CompactTextString(m) }
func (*FileData) ProtoMessage()               {}
func (*FileData) Descriptor() ([]byte, []int) { return fileDescriptorAnalysis, []int{5} }

func (m *FileData) GetInfo() *FileInfo {
	if m != nil {
		return m.Info
	}
	return nil
}

func init() {
	proto.RegisterType((*AnalysisRequest)(nil), "kythe.proto.AnalysisRequest")
	proto.RegisterType((*AnalysisOutput)(nil), "kythe.proto.AnalysisOutput")
	proto.RegisterType((*CompilationUnit)(nil), "kythe.proto.CompilationUnit")
	proto.RegisterType((*CompilationUnit_ContextDependentVersionColumn)(nil), "kythe.proto.CompilationUnit.ContextDependentVersionColumn")
	proto.RegisterType((*CompilationUnit_ContextDependentVersionRow)(nil), "kythe.proto.CompilationUnit.ContextDependentVersionRow")
	proto.RegisterType((*CompilationUnit_FileInput)(nil), "kythe.proto.CompilationUnit.FileInput")
	proto.RegisterType((*CompilationUnit_Env)(nil), "kythe.proto.CompilationUnit.Env")
	proto.RegisterType((*FilesRequest)(nil), "kythe.proto.FilesRequest")
	proto.RegisterType((*FileInfo)(nil), "kythe.proto.FileInfo")
	proto.RegisterType((*FileData)(nil), "kythe.proto.FileData")
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion2

// Client API for CompilationAnalyzer service

type CompilationAnalyzerClient interface {
	// Analyze is the main entry point for the analysis driver to send work to the
	// analyzer.  The analysis may produce many outputs which will be streamed as
	// framed AnalysisOutput messages.
	//
	// A driver may choose to retry analyses that return RPC errors.  It should
	// not retry analyses that are reported as finished unless it is necessary to
	// recover from an external production issue.
	Analyze(ctx context.Context, in *AnalysisRequest, opts ...grpc.CallOption) (CompilationAnalyzer_AnalyzeClient, error)
}

type compilationAnalyzerClient struct {
	cc *grpc.ClientConn
}

func NewCompilationAnalyzerClient(cc *grpc.ClientConn) CompilationAnalyzerClient {
	return &compilationAnalyzerClient{cc}
}

func (c *compilationAnalyzerClient) Analyze(ctx context.Context, in *AnalysisRequest, opts ...grpc.CallOption) (CompilationAnalyzer_AnalyzeClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_CompilationAnalyzer_serviceDesc.Streams[0], c.cc, "/kythe.proto.CompilationAnalyzer/Analyze", opts...)
	if err != nil {
		return nil, err
	}
	x := &compilationAnalyzerAnalyzeClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type CompilationAnalyzer_AnalyzeClient interface {
	Recv() (*AnalysisOutput, error)
	grpc.ClientStream
}

type compilationAnalyzerAnalyzeClient struct {
	grpc.ClientStream
}

func (x *compilationAnalyzerAnalyzeClient) Recv() (*AnalysisOutput, error) {
	m := new(AnalysisOutput)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for CompilationAnalyzer service

type CompilationAnalyzerServer interface {
	// Analyze is the main entry point for the analysis driver to send work to the
	// analyzer.  The analysis may produce many outputs which will be streamed as
	// framed AnalysisOutput messages.
	//
	// A driver may choose to retry analyses that return RPC errors.  It should
	// not retry analyses that are reported as finished unless it is necessary to
	// recover from an external production issue.
	Analyze(*AnalysisRequest, CompilationAnalyzer_AnalyzeServer) error
}

func RegisterCompilationAnalyzerServer(s *grpc.Server, srv CompilationAnalyzerServer) {
	s.RegisterService(&_CompilationAnalyzer_serviceDesc, srv)
}

func _CompilationAnalyzer_Analyze_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(AnalysisRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(CompilationAnalyzerServer).Analyze(m, &compilationAnalyzerAnalyzeServer{stream})
}

type CompilationAnalyzer_AnalyzeServer interface {
	Send(*AnalysisOutput) error
	grpc.ServerStream
}

type compilationAnalyzerAnalyzeServer struct {
	grpc.ServerStream
}

func (x *compilationAnalyzerAnalyzeServer) Send(m *AnalysisOutput) error {
	return x.ServerStream.SendMsg(m)
}

var _CompilationAnalyzer_serviceDesc = grpc.ServiceDesc{
	ServiceName: "kythe.proto.CompilationAnalyzer",
	HandlerType: (*CompilationAnalyzerServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Analyze",
			Handler:       _CompilationAnalyzer_Analyze_Handler,
			ServerStreams: true,
		},
	},
}

// Client API for FileDataService service

type FileDataServiceClient interface {
	// Get returns the contents of one or more files needed for analysis.  It is
	// the server's responsibility to do any caching necessary to make this
	// perform well, so that an analyzer does not need to implement its own
	// caches unless it is doing something unusual.
	//
	// For each distinct path/digest pair in the request, the server must return
	// exactly one response.  The order of the responses is arbitrary.
	//
	// For each requested file, one or both of the path and digest fields must be
	// nonempty, otherwise an error is returned.  It is not an error for there to
	// be no requested files, however.
	Get(ctx context.Context, in *FilesRequest, opts ...grpc.CallOption) (FileDataService_GetClient, error)
}

type fileDataServiceClient struct {
	cc *grpc.ClientConn
}

func NewFileDataServiceClient(cc *grpc.ClientConn) FileDataServiceClient {
	return &fileDataServiceClient{cc}
}

func (c *fileDataServiceClient) Get(ctx context.Context, in *FilesRequest, opts ...grpc.CallOption) (FileDataService_GetClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_FileDataService_serviceDesc.Streams[0], c.cc, "/kythe.proto.FileDataService/Get", opts...)
	if err != nil {
		return nil, err
	}
	x := &fileDataServiceGetClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type FileDataService_GetClient interface {
	Recv() (*FileData, error)
	grpc.ClientStream
}

type fileDataServiceGetClient struct {
	grpc.ClientStream
}

func (x *fileDataServiceGetClient) Recv() (*FileData, error) {
	m := new(FileData)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

// Server API for FileDataService service

type FileDataServiceServer interface {
	// Get returns the contents of one or more files needed for analysis.  It is
	// the server's responsibility to do any caching necessary to make this
	// perform well, so that an analyzer does not need to implement its own
	// caches unless it is doing something unusual.
	//
	// For each distinct path/digest pair in the request, the server must return
	// exactly one response.  The order of the responses is arbitrary.
	//
	// For each requested file, one or both of the path and digest fields must be
	// nonempty, otherwise an error is returned.  It is not an error for there to
	// be no requested files, however.
	Get(*FilesRequest, FileDataService_GetServer) error
}

func RegisterFileDataServiceServer(s *grpc.Server, srv FileDataServiceServer) {
	s.RegisterService(&_FileDataService_serviceDesc, srv)
}

func _FileDataService_Get_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(FilesRequest)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(FileDataServiceServer).Get(m, &fileDataServiceGetServer{stream})
}

type FileDataService_GetServer interface {
	Send(*FileData) error
	grpc.ServerStream
}

type fileDataServiceGetServer struct {
	grpc.ServerStream
}

func (x *fileDataServiceGetServer) Send(m *FileData) error {
	return x.ServerStream.SendMsg(m)
}

var _FileDataService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "kythe.proto.FileDataService",
	HandlerType: (*FileDataServiceServer)(nil),
	Methods:     []grpc.MethodDesc{},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Get",
			Handler:       _FileDataService_Get_Handler,
			ServerStreams: true,
		},
	},
}

func (m *AnalysisRequest) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *AnalysisRequest) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Compilation != nil {
		data[i] = 0xa
		i++
		i = encodeVarintAnalysis(data, i, uint64(m.Compilation.Size()))
		n1, err := m.Compilation.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n1
	}
	if len(m.FileDataService) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAnalysis(data, i, uint64(len(m.FileDataService)))
		i += copy(data[i:], m.FileDataService)
	}
	return i, nil
}

func (m *AnalysisOutput) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *AnalysisOutput) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Value) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAnalysis(data, i, uint64(len(m.Value)))
		i += copy(data[i:], m.Value)
	}
	return i, nil
}

func (m *CompilationUnit) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CompilationUnit) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.VName != nil {
		data[i] = 0xa
		i++
		i = encodeVarintAnalysis(data, i, uint64(m.VName.Size()))
		n2, err := m.VName.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n2
	}
	if len(m.Revision) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAnalysis(data, i, uint64(len(m.Revision)))
		i += copy(data[i:], m.Revision)
	}
	if len(m.RequiredInput) > 0 {
		for _, msg := range m.RequiredInput {
			data[i] = 0x1a
			i++
			i = encodeVarintAnalysis(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.HasCompileErrors {
		data[i] = 0x20
		i++
		if m.HasCompileErrors {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	if len(m.Argument) > 0 {
		for _, s := range m.Argument {
			data[i] = 0x2a
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if len(m.SourceFile) > 0 {
		for _, s := range m.SourceFile {
			data[i] = 0x32
			i++
			l = len(s)
			for l >= 1<<7 {
				data[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			data[i] = uint8(l)
			i++
			i += copy(data[i:], s)
		}
	}
	if len(m.OutputKey) > 0 {
		data[i] = 0x3a
		i++
		i = encodeVarintAnalysis(data, i, uint64(len(m.OutputKey)))
		i += copy(data[i:], m.OutputKey)
	}
	if len(m.WorkingDirectory) > 0 {
		data[i] = 0x42
		i++
		i = encodeVarintAnalysis(data, i, uint64(len(m.WorkingDirectory)))
		i += copy(data[i:], m.WorkingDirectory)
	}
	if len(m.EntryContext) > 0 {
		data[i] = 0x4a
		i++
		i = encodeVarintAnalysis(data, i, uint64(len(m.EntryContext)))
		i += copy(data[i:], m.EntryContext)
	}
	if len(m.Environment) > 0 {
		for _, msg := range m.Environment {
			data[i] = 0x52
			i++
			i = encodeVarintAnalysis(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Details) > 0 {
		for _, msg := range m.Details {
			data[i] = 0x5a
			i++
			i = encodeVarintAnalysis(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CompilationUnit_ContextDependentVersionColumn) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CompilationUnit_ContextDependentVersionColumn) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Offset != 0 {
		data[i] = 0x8
		i++
		i = encodeVarintAnalysis(data, i, uint64(m.Offset))
	}
	if len(m.LinkedContext) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAnalysis(data, i, uint64(len(m.LinkedContext)))
		i += copy(data[i:], m.LinkedContext)
	}
	return i, nil
}

func (m *CompilationUnit_ContextDependentVersionRow) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CompilationUnit_ContextDependentVersionRow) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.SourceContext) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAnalysis(data, i, uint64(len(m.SourceContext)))
		i += copy(data[i:], m.SourceContext)
	}
	if len(m.Column) > 0 {
		for _, msg := range m.Column {
			data[i] = 0x12
			i++
			i = encodeVarintAnalysis(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if m.AlwaysProcess {
		data[i] = 0x18
		i++
		if m.AlwaysProcess {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	return i, nil
}

func (m *CompilationUnit_FileInput) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CompilationUnit_FileInput) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.VName != nil {
		data[i] = 0xa
		i++
		i = encodeVarintAnalysis(data, i, uint64(m.VName.Size()))
		n3, err := m.VName.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n3
	}
	if m.Info != nil {
		data[i] = 0x12
		i++
		i = encodeVarintAnalysis(data, i, uint64(m.Info.Size()))
		n4, err := m.Info.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n4
	}
	if len(m.Context) > 0 {
		for _, msg := range m.Context {
			data[i] = 0x1a
			i++
			i = encodeVarintAnalysis(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *CompilationUnit_Env) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *CompilationUnit_Env) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAnalysis(data, i, uint64(len(m.Name)))
		i += copy(data[i:], m.Name)
	}
	if len(m.Value) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAnalysis(data, i, uint64(len(m.Value)))
		i += copy(data[i:], m.Value)
	}
	return i, nil
}

func (m *FilesRequest) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *FilesRequest) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Files) > 0 {
		for _, msg := range m.Files {
			data[i] = 0xa
			i++
			i = encodeVarintAnalysis(data, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(data[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	return i, nil
}

func (m *FileInfo) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *FileInfo) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Path) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAnalysis(data, i, uint64(len(m.Path)))
		i += copy(data[i:], m.Path)
	}
	if len(m.Digest) > 0 {
		data[i] = 0x12
		i++
		i = encodeVarintAnalysis(data, i, uint64(len(m.Digest)))
		i += copy(data[i:], m.Digest)
	}
	return i, nil
}

func (m *FileData) Marshal() (data []byte, err error) {
	size := m.Size()
	data = make([]byte, size)
	n, err := m.MarshalTo(data)
	if err != nil {
		return nil, err
	}
	return data[:n], nil
}

func (m *FileData) MarshalTo(data []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Content) > 0 {
		data[i] = 0xa
		i++
		i = encodeVarintAnalysis(data, i, uint64(len(m.Content)))
		i += copy(data[i:], m.Content)
	}
	if m.Info != nil {
		data[i] = 0x12
		i++
		i = encodeVarintAnalysis(data, i, uint64(m.Info.Size()))
		n5, err := m.Info.MarshalTo(data[i:])
		if err != nil {
			return 0, err
		}
		i += n5
	}
	if m.Missing {
		data[i] = 0x18
		i++
		if m.Missing {
			data[i] = 1
		} else {
			data[i] = 0
		}
		i++
	}
	return i, nil
}

func encodeFixed64Analysis(data []byte, offset int, v uint64) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	data[offset+4] = uint8(v >> 32)
	data[offset+5] = uint8(v >> 40)
	data[offset+6] = uint8(v >> 48)
	data[offset+7] = uint8(v >> 56)
	return offset + 8
}
func encodeFixed32Analysis(data []byte, offset int, v uint32) int {
	data[offset] = uint8(v)
	data[offset+1] = uint8(v >> 8)
	data[offset+2] = uint8(v >> 16)
	data[offset+3] = uint8(v >> 24)
	return offset + 4
}
func encodeVarintAnalysis(data []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		data[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	data[offset] = uint8(v)
	return offset + 1
}
func (m *AnalysisRequest) Size() (n int) {
	var l int
	_ = l
	if m.Compilation != nil {
		l = m.Compilation.Size()
		n += 1 + l + sovAnalysis(uint64(l))
	}
	l = len(m.FileDataService)
	if l > 0 {
		n += 1 + l + sovAnalysis(uint64(l))
	}
	return n
}

func (m *AnalysisOutput) Size() (n int) {
	var l int
	_ = l
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovAnalysis(uint64(l))
	}
	return n
}

func (m *CompilationUnit) Size() (n int) {
	var l int
	_ = l
	if m.VName != nil {
		l = m.VName.Size()
		n += 1 + l + sovAnalysis(uint64(l))
	}
	l = len(m.Revision)
	if l > 0 {
		n += 1 + l + sovAnalysis(uint64(l))
	}
	if len(m.RequiredInput) > 0 {
		for _, e := range m.RequiredInput {
			l = e.Size()
			n += 1 + l + sovAnalysis(uint64(l))
		}
	}
	if m.HasCompileErrors {
		n += 2
	}
	if len(m.Argument) > 0 {
		for _, s := range m.Argument {
			l = len(s)
			n += 1 + l + sovAnalysis(uint64(l))
		}
	}
	if len(m.SourceFile) > 0 {
		for _, s := range m.SourceFile {
			l = len(s)
			n += 1 + l + sovAnalysis(uint64(l))
		}
	}
	l = len(m.OutputKey)
	if l > 0 {
		n += 1 + l + sovAnalysis(uint64(l))
	}
	l = len(m.WorkingDirectory)
	if l > 0 {
		n += 1 + l + sovAnalysis(uint64(l))
	}
	l = len(m.EntryContext)
	if l > 0 {
		n += 1 + l + sovAnalysis(uint64(l))
	}
	if len(m.Environment) > 0 {
		for _, e := range m.Environment {
			l = e.Size()
			n += 1 + l + sovAnalysis(uint64(l))
		}
	}
	if len(m.Details) > 0 {
		for _, e := range m.Details {
			l = e.Size()
			n += 1 + l + sovAnalysis(uint64(l))
		}
	}
	return n
}

func (m *CompilationUnit_ContextDependentVersionColumn) Size() (n int) {
	var l int
	_ = l
	if m.Offset != 0 {
		n += 1 + sovAnalysis(uint64(m.Offset))
	}
	l = len(m.LinkedContext)
	if l > 0 {
		n += 1 + l + sovAnalysis(uint64(l))
	}
	return n
}

func (m *CompilationUnit_ContextDependentVersionRow) Size() (n int) {
	var l int
	_ = l
	l = len(m.SourceContext)
	if l > 0 {
		n += 1 + l + sovAnalysis(uint64(l))
	}
	if len(m.Column) > 0 {
		for _, e := range m.Column {
			l = e.Size()
			n += 1 + l + sovAnalysis(uint64(l))
		}
	}
	if m.AlwaysProcess {
		n += 2
	}
	return n
}

func (m *CompilationUnit_FileInput) Size() (n int) {
	var l int
	_ = l
	if m.VName != nil {
		l = m.VName.Size()
		n += 1 + l + sovAnalysis(uint64(l))
	}
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sovAnalysis(uint64(l))
	}
	if len(m.Context) > 0 {
		for _, e := range m.Context {
			l = e.Size()
			n += 1 + l + sovAnalysis(uint64(l))
		}
	}
	return n
}

func (m *CompilationUnit_Env) Size() (n int) {
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovAnalysis(uint64(l))
	}
	l = len(m.Value)
	if l > 0 {
		n += 1 + l + sovAnalysis(uint64(l))
	}
	return n
}

func (m *FilesRequest) Size() (n int) {
	var l int
	_ = l
	if len(m.Files) > 0 {
		for _, e := range m.Files {
			l = e.Size()
			n += 1 + l + sovAnalysis(uint64(l))
		}
	}
	return n
}

func (m *FileInfo) Size() (n int) {
	var l int
	_ = l
	l = len(m.Path)
	if l > 0 {
		n += 1 + l + sovAnalysis(uint64(l))
	}
	l = len(m.Digest)
	if l > 0 {
		n += 1 + l + sovAnalysis(uint64(l))
	}
	return n
}

func (m *FileData) Size() (n int) {
	var l int
	_ = l
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovAnalysis(uint64(l))
	}
	if m.Info != nil {
		l = m.Info.Size()
		n += 1 + l + sovAnalysis(uint64(l))
	}
	if m.Missing {
		n += 2
	}
	return n
}

func sovAnalysis(x uint64) (n int) {
	for {
		n++
		x >>= 7
		if x == 0 {
			break
		}
	}
	return n
}
func sozAnalysis(x uint64) (n int) {
	return sovAnalysis(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *AnalysisRequest) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAnalysis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AnalysisRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AnalysisRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Compilation", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalysis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAnalysis
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Compilation == nil {
				m.Compilation = &CompilationUnit{}
			}
			if err := m.Compilation.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FileDataService", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalysis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAnalysis
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.FileDataService = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAnalysis(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAnalysis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AnalysisOutput) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAnalysis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AnalysisOutput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AnalysisOutput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalysis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAnalysis
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = append(m.Value[:0], data[iNdEx:postIndex]...)
			if m.Value == nil {
				m.Value = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAnalysis(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAnalysis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CompilationUnit) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAnalysis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: CompilationUnit: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: CompilationUnit: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VName", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalysis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAnalysis
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VName == nil {
				m.VName = &kythe_proto.VName{}
			}
			if err := m.VName.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Revision", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalysis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAnalysis
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Revision = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field RequiredInput", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalysis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAnalysis
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.RequiredInput = append(m.RequiredInput, &CompilationUnit_FileInput{})
			if err := m.RequiredInput[len(m.RequiredInput)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HasCompileErrors", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalysis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.HasCompileErrors = bool(v != 0)
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Argument", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalysis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAnalysis
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Argument = append(m.Argument, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceFile", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalysis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAnalysis
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceFile = append(m.SourceFile, string(data[iNdEx:postIndex]))
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OutputKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalysis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAnalysis
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OutputKey = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field WorkingDirectory", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalysis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAnalysis
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.WorkingDirectory = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EntryContext", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalysis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAnalysis
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EntryContext = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Environment", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalysis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAnalysis
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Environment = append(m.Environment, &CompilationUnit_Env{})
			if err := m.Environment[len(m.Environment)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Details", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalysis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAnalysis
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Details = append(m.Details, &google_protobuf.Any{})
			if err := m.Details[len(m.Details)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAnalysis(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAnalysis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CompilationUnit_ContextDependentVersionColumn) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAnalysis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContextDependentVersionColumn: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContextDependentVersionColumn: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Offset", wireType)
			}
			m.Offset = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalysis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				m.Offset |= (int32(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LinkedContext", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalysis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAnalysis
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LinkedContext = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAnalysis(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAnalysis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CompilationUnit_ContextDependentVersionRow) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAnalysis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ContextDependentVersionRow: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ContextDependentVersionRow: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SourceContext", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalysis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAnalysis
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SourceContext = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Column", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalysis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAnalysis
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Column = append(m.Column, &CompilationUnit_ContextDependentVersionColumn{})
			if err := m.Column[len(m.Column)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AlwaysProcess", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalysis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.AlwaysProcess = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipAnalysis(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAnalysis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CompilationUnit_FileInput) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAnalysis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileInput: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileInput: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field VName", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalysis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAnalysis
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.VName == nil {
				m.VName = &kythe_proto.VName{}
			}
			if err := m.VName.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalysis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAnalysis
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = &FileInfo{}
			}
			if err := m.Info.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Context", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalysis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAnalysis
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Context = append(m.Context, &CompilationUnit_ContextDependentVersionRow{})
			if err := m.Context[len(m.Context)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAnalysis(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAnalysis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *CompilationUnit_Env) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAnalysis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Env: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Env: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalysis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAnalysis
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Value", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalysis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAnalysis
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Value = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAnalysis(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAnalysis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FilesRequest) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAnalysis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FilesRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FilesRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Files", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalysis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAnalysis
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Files = append(m.Files, &FileInfo{})
			if err := m.Files[len(m.Files)-1].Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAnalysis(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAnalysis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileInfo) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAnalysis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Path", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalysis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAnalysis
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Path = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Digest", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalysis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				stringLen |= (uint64(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAnalysis
			}
			postIndex := iNdEx + intStringLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Digest = string(data[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAnalysis(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAnalysis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *FileData) Unmarshal(data []byte) error {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAnalysis
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: FileData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: FileData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalysis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				byteLen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAnalysis
			}
			postIndex := iNdEx + byteLen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = append(m.Content[:0], data[iNdEx:postIndex]...)
			if m.Content == nil {
				m.Content = []byte{}
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Info", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalysis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				msglen |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAnalysis
			}
			postIndex := iNdEx + msglen
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Info == nil {
				m.Info = &FileInfo{}
			}
			if err := m.Info.Unmarshal(data[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Missing", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAnalysis
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				v |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Missing = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipAnalysis(data[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthAnalysis
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAnalysis(data []byte) (n int, err error) {
	l := len(data)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAnalysis
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := data[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAnalysis
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if data[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAnalysis
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := data[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			iNdEx += length
			if length < 0 {
				return 0, ErrInvalidLengthAnalysis
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowAnalysis
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := data[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipAnalysis(data[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthAnalysis = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAnalysis   = fmt.Errorf("proto: integer overflow")
)

var fileDescriptorAnalysis = []byte{
	// 692 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x09, 0x6e, 0x88, 0x02, 0xff, 0x9c, 0x54, 0xdd, 0x6e, 0xd3, 0x4a,
	0x10, 0x6e, 0x4e, 0x9a, 0x34, 0x99, 0xa4, 0xc9, 0x39, 0xdb, 0xd3, 0x23, 0xd7, 0x07, 0xda, 0x2a,
	0xfc, 0xa8, 0x57, 0x2e, 0x0d, 0x20, 0x24, 0x90, 0x90, 0x4a, 0x0b, 0x05, 0x2e, 0x8a, 0x28, 0xa2,
	0xb7, 0xd6, 0x36, 0xde, 0xa4, 0xab, 0x38, 0xbb, 0x61, 0x77, 0xed, 0x62, 0x5e, 0x84, 0x5e, 0xf1,
	0x3c, 0x5c, 0xf2, 0x08, 0x08, 0x5e, 0x84, 0xf1, 0xda, 0x4e, 0xd3, 0x96, 0x46, 0x15, 0x17, 0x56,
	0x62, 0xef, 0xcc, 0xf7, 0x7d, 0xf3, 0xcd, 0xcc, 0x82, 0x3b, 0x4c, 0xcc, 0x31, 0xdb, 0x1c, 0x2b,
	0x69, 0xe4, 0x26, 0x15, 0x34, 0x4c, 0x34, 0xd7, 0x9e, 0x7d, 0x25, 0x0d, 0x7b, 0x96, 0xbd, 0xb8,
	0x2b, 0x03, 0x29, 0x07, 0x61, 0x1e, 0x79, 0x14, 0xf5, 0x31, 0x38, 0x29, 0x8e, 0xa6, 0x31, 0xb4,
	0x91, 0x8a, 0x0e, 0xf2, 0xac, 0x8e, 0x0f, 0xed, 0xed, 0x1c, 0xf4, 0x80, 0x7d, 0x88, 0x98, 0x36,
	0x64, 0x0b, 0x1a, 0x3d, 0x39, 0x1a, 0xf3, 0x90, 0x1a, 0x2e, 0x85, 0x53, 0x5a, 0x2f, 0x6d, 0x34,
	0xba, 0x37, 0xbc, 0x29, 0x2e, 0x6f, 0xe7, 0xec, 0xfc, 0xbd, 0xe0, 0x86, 0xac, 0xc0, 0x3f, 0x7d,
	0x1e, 0x32, 0x3f, 0xa0, 0x86, 0xfa, 0x9a, 0xa9, 0x98, 0xf7, 0x98, 0xf3, 0x17, 0x26, 0xd6, 0x3b,
	0x6b, 0xd0, 0x2a, 0x08, 0xde, 0x44, 0x66, 0x1c, 0x19, 0xb2, 0x08, 0x95, 0x98, 0x86, 0x11, 0xb3,
	0xc8, 0xcd, 0xce, 0xe7, 0x2a, 0xb4, 0x2f, 0xe2, 0x75, 0xa0, 0x1a, 0xfb, 0x82, 0x8e, 0x58, 0xce,
	0x4e, 0xce, 0xb1, 0x1f, 0xee, 0xe3, 0x09, 0xf9, 0x1b, 0x6a, 0x8a, 0xc5, 0x5c, 0xa7, 0x1a, 0x2d,
	0x15, 0x79, 0x0a, 0x2d, 0x85, 0x35, 0x70, 0xc5, 0x02, 0x9f, 0x0b, 0xa4, 0x72, 0xca, 0xeb, 0x65,
	0xcc, 0xbe, 0x3b, 0x4b, 0xbb, 0xf7, 0x02, 0x85, 0xbf, 0x4a, 0xa3, 0x89, 0x0b, 0xe4, 0x98, 0x6a,
	0x3f, 0x2b, 0x9e, 0xf9, 0x4c, 0x29, 0xa9, 0xb4, 0x33, 0x8f, 0xd8, 0xb5, 0x94, 0x8d, 0xaa, 0x41,
	0x34, 0x62, 0xc2, 0x38, 0x15, 0x44, 0xad, 0x93, 0x25, 0x68, 0x68, 0x19, 0xa9, 0x1e, 0xf3, 0xd3,
	0xd2, 0x9d, 0xaa, 0xfd, 0x48, 0x00, 0xa4, 0xad, 0xd2, 0x1f, 0xb2, 0xc4, 0x59, 0xb0, 0xb2, 0xd0,
	0x9c, 0x13, 0xa9, 0x86, 0x5c, 0x0c, 0xfc, 0x00, 0xb5, 0xf5, 0xd0, 0xff, 0xc4, 0xa9, 0xd9, 0xa3,
	0x65, 0x58, 0x44, 0x40, 0x95, 0x20, 0xa7, 0x30, 0xec, 0xa3, 0x71, 0xea, 0xf6, 0xf3, 0x43, 0x68,
	0x30, 0x11, 0x73, 0x25, 0x85, 0xe5, 0x03, 0x5b, 0xc5, 0xfa, 0xcc, 0x2a, 0x9e, 0x8b, 0x98, 0xdc,
	0x81, 0x85, 0x80, 0x19, 0xca, 0x43, 0xed, 0x34, 0x6c, 0xca, 0xbf, 0x5e, 0x36, 0x13, 0x5e, 0x31,
	0x13, 0xde, 0xb6, 0x48, 0xdc, 0x3d, 0xb8, 0xb9, 0x93, 0xd1, 0xed, 0xb2, 0x31, 0x13, 0x01, 0x52,
	0x1c, 0x32, 0x95, 0xfa, 0xb8, 0x23, 0xc3, 0x68, 0x24, 0x48, 0x0b, 0xaa, 0xb2, 0xdf, 0xd7, 0xcc,
	0x58, 0xf7, 0x2b, 0xe4, 0x3f, 0x68, 0x85, 0x5c, 0x0c, 0xd1, 0xd5, 0x42, 0xa6, 0xf5, 0xdb, 0x3d,
	0x2d, 0x81, 0x7b, 0x05, 0xd2, 0x81, 0x3c, 0x49, 0xd3, 0x72, 0x83, 0x8a, 0xb4, 0x92, 0xad, 0xee,
	0x35, 0x54, 0x7b, 0x96, 0x08, 0x61, 0x52, 0x95, 0x8f, 0x67, 0x16, 0x36, 0x5b, 0x2a, 0x72, 0xd0,
	0xf0, 0x84, 0x26, 0xda, 0xc7, 0xec, 0x1e, 0xd3, 0x1a, 0x5b, 0x8e, 0xed, 0x72, 0xbf, 0x94, 0xa0,
	0x7e, 0xd6, 0xd8, 0xeb, 0x8c, 0xd3, 0x2d, 0x98, 0xe7, 0xa2, 0x2f, 0x6d, 0x69, 0x8d, 0xee, 0xf2,
	0xb9, 0x88, 0x0c, 0xa9, 0x2f, 0xc9, 0x4b, 0x58, 0x28, 0x6a, 0xc9, 0x46, 0xeb, 0xd1, 0x9f, 0x68,
	0x47, 0x73, 0xdc, 0x0e, 0x94, 0xd3, 0x96, 0x35, 0x61, 0x7e, 0xa2, 0xab, 0x7e, 0xb6, 0x19, 0xd9,
	0xea, 0x3c, 0x80, 0x66, 0xca, 0x3c, 0x59, 0xcc, 0xdb, 0x50, 0x49, 0x47, 0x4d, 0x63, 0x74, 0xf9,
	0x4a, 0x8d, 0x9d, 0x0d, 0xa8, 0x4d, 0xf4, 0x22, 0xfc, 0x98, 0x9a, 0xe3, 0x1c, 0x1e, 0xfb, 0x1a,
	0xf0, 0x01, 0x22, 0xe5, 0xf8, 0x6f, 0xb3, 0xc8, 0x5d, 0x5c, 0x5a, 0xd2, 0xce, 0x2b, 0x13, 0x59,
	0x97, 0x9a, 0xd7, 0xf3, 0x03, 0xb3, 0x46, 0x5c, 0x6b, 0x1c, 0xed, 0xcc, 0xf7, 0xae, 0x0f, 0x4b,
	0x53, 0x26, 0xd8, 0xc5, 0xff, 0xc4, 0x54, 0xea, 0x5b, 0xfe, 0x9f, 0x9c, 0xbf, 0x48, 0x2e, 0xdc,
	0x3d, 0xee, 0xff, 0xbf, 0x3d, 0xcd, 0x2e, 0x8e, 0xce, 0xdc, 0xbd, 0x52, 0x77, 0x1f, 0xda, 0x85,
	0xe6, 0x77, 0xd9, 0x3d, 0x43, 0x9e, 0x40, 0x79, 0x8f, 0xe1, 0x1d, 0x74, 0x49, 0xe2, 0x04, 0xf5,
	0xb2, 0xfa, 0x34, 0x3f, 0xc5, 0x7b, 0xb6, 0xf5, 0xf5, 0xc7, 0x6a, 0xe9, 0x1b, 0x3e, 0xdf, 0xf1,
	0x39, 0xfd, 0xb9, 0x3a, 0x07, 0x6b, 0xb8, 0xff, 0xc5, 0xde, 0x04, 0x2c, 0x36, 0x52, 0x86, 0x7a,
	0x3a, 0xff, 0xa8, 0x6a, 0x7f, 0xee, 0xff, 0x0a, 0x00, 0x00, 0xff, 0xff, 0x91, 0x4a, 0xd6, 0x7d,
	0x9a, 0x05, 0x00, 0x00,
}
