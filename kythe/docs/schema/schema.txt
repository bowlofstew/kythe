// Copyright 2014 Google Inc. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//   http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

Kythe Schema Reference
======================
:Revision: 1.0
:toc2:
:toclevels: 3
:priority: 999

.This document is part of the Kythe test suite.
TIP: Successfully generating this document is part of the test suite for the
Kythe indexers. The assertions in the example code all verify and the
graphs provided are the graphs that are actually output. Feel free to add
examples from your own languages, but be sure to keep them up to date.

VName conventions
-----------------

By default, assume that the VNames of nodes should be chosen according to the
following rules:

  * `language`: the source language.
  * `corpus`: the node's containing corpus.
  * `root`: a root path relative to the node's corpus.
  * `path`: a path relative to the corpus *and* root of the node.
  * `signature`: a unique string (per `corpus`, `root`, `path`, and `language`)
    that should be consistently generated given the same input to the indexer,
    but that does not necessarily need to be stable across different versions of
    the input.

Additional rules govern the generation of VNames for certain kinds of nodes,
most notably <<name,names>>. These nodes are frequently used as points
for linking together the output of discrete indexer runs and may have greater
stability properties than may be derived using the preceding VName rules.

Absent additional rules, an indexer is permitted to encode the `signature` field
arbitrarily, as long as the chance of this encoding causing distinct field
values to become indistinguishable is vanishingly small. This is meant to permit
implementations to use one-way hash functions to crunch large `signature` values
down to manageable fingerprints.

Edge kinds
----------

[[aliases]]
aliases
~~~~~~~

Brief description::
  A *aliases* T if A may be used in place of T.
Commonly arises from::
  typedefs
Points from::
  <<talias>>
Points toward::
  types
Ordinals are used::
  never

[kythe,C++,"Typedefs are aliases."]
--------------------------------------------------------------------------------
//- @Counter defines/binding TAlias
//- TAlias aliases TInt
typedef int Counter;
--------------------------------------------------------------------------------

[[annotatedby]]
annotatedby
~~~~~~~~~~~

Brief description::
  A *annotatedby* B if A provides metadata for B.
Points from::
  semantic nodes
Points toward::
  semantic nodes
Ordinals are used::
  never

[kythe,Java,"Classes can be annotated."]
--------------------------------------------------------------------------------
//- @Deprecated ref Deprecated
//- @E defines/binding Class
//- Class annotatedby Deprecated
@Deprecated public class E {}
--------------------------------------------------------------------------------

[[childof]]
childof
~~~~~~~

Brief description::
  A *childof* B if A is contained in or dominated by B.
Commonly arises from::
  <<anchor>>s, block syntax, membership
Points from::
  any
Points toward::
  semantic nodes
Ordinals are used::
  never

[kythe,C++,"Enumerators are children of enumerations."]
--------------------------------------------------------------------------------
//- @Enum defines/binding Enumeration
enum class Enum {
//- @Etor defines/binding Enumerator
  Etor
};
//- Enumerator childof Enumeration
--------------------------------------------------------------------------------

[[childofcontext]]
childof/context
~~~~~~~~~~~~~~~

Brief description::
  A *childof/context* T if anchor A is associated with some instantiation T.
Commonly arises from::
  template instantiations
Points from::
  <<anchor>>s
Points toward::
  semantic nodes
Ordinals are used::
  never

[kythe,C++,"Template instantiations create new anchor contexts."]
--------------------------------------------------------------------------------
//- @C defines/binding CTemplate
//- CTemplateBody childof CTemplate
template <typename T> struct C {
//- @x=AnchorX defines/binding XBinding
//- XBinding childof CTemplateBody
//- @x=AnchorCX defines/binding CXBinding
  int x;
};
//- @C defines/binding CInst
//- AnchorCX childof/context CInst
//- CXBinding childof CInst
//- !{ AnchorX childof/context CInst }
template struct C<int>;
--------------------------------------------------------------------------------

[[completes]]
completes
~~~~~~~~~

Brief description::
  Definition A *completes* declaration B if A fully specifies B, but
  there may exist other definitions that may also fully specify B.
Commonly arises from::
  definitions of forward declarations
Points from::
  anchors
Points toward::
  semantic nodes with `complete` facts set to `incomplete` or `complete`
See also::
  <<record>>, <<sum>>, <<completesuniquely,[completes/uniquely]>>

[kythe,C++,"Definitions complete forward declarations in headers."]
--------------------------------------------------------------------------------
#include "test.h"
//- @C completes Decl1
//- @C completes Decl2
//- @C defines/binding Defn
class C { };

#example test.h
//- @C defines/binding Decl1
class C;
//- @C defines/binding Decl2
class C;
--------------------------------------------------------------------------------

[[completesuniquely]]
completes/uniquely
~~~~~~~~~~~~~~~~~~

Brief description::
  Definition A *completes/uniquely* declaration B if A fully specifies B
  and there is no other definition that could possibly do so.
Commonly arises from::
  definitions of forward declarations
Points from::
  anchors
Points toward::
  semantic nodes with `complete` facts set to `incomplete` or `complete`
See also::
  <<completes>>, <<record>>, <<sum>>

[kythe,C++,"Definitions uniquely complete same-file forward declarations."]
--------------------------------------------------------------------------------
//- @C defines/binding Decl1
class C;
//- @C defines/binding Decl2
class C;
//- @C completes/uniquely Decl1
//- @C completes/uniquely Decl2
//- @C defines/binding Defn
class C { };
--------------------------------------------------------------------------------

[kythe,C++,"Completeness links abs nodes for function templates."]
--------------------------------------------------------------------------------
//- @id defines/binding Decl
template <typename T> T id(T x);
//- @id defines/binding Defn
//- @id completes/uniquely Decl
template <typename T> T id(T x) { return x; }
//- Defn.node/kind abs
//- Decl.node/kind abs
--------------------------------------------------------------------------------

[[defines]]
defines
~~~~~~~

Brief description::
  A *defines* B if A generates the semantic object B.
Commonly arises from::
  definitions and declarations
Points from::
  anchors
Points toward::
  semantic nodes
Ordinals are used::
  never
See also::
  <<definesbinding,[defines/binding]>>
Notes::
  It is valid for multiple anchors to define the same semantic object. These
  anchors may even overlap.


[kythe,Java,"Class definitions span their entire body."]
--------------------------------------------------------------------------------
//- ClassEDef defines ClassE
//- ClassEDef.node/kind anchor
//- ClassEDef.loc/start @^public
//- ClassEDef.loc/end @$+3"}"
public class E {
  // class contents here...
}
--------------------------------------------------------------------------------

[kythe,Java,"Method definitions span their entire body."]
--------------------------------------------------------------------------------
public class E {
  //- MethodDef defines Method
  //- MethodDef.node/kind anchor
  //- MethodDef.loc/start @^public
  //- MethodDef.loc/end @$+3"}"
  public int methodName(int param) {
    return 42;
  }
}
--------------------------------------------------------------------------------

[[definesbinding]]
defines/binding
~~~~~~~~~~~~~~~

Brief description::
  A *defines/binding* B when A covers an identifier bound to B when that binding is established.
Commonly arises from::
  definitions
Points from::
  anchors
Points toward::
  semantic nodes
Ordinals are used::
  never
See also::
  <<defines>>
Notes::
  Source anchors are not necessarily identifiers. For example, the $$C++$$
  indexer will start a *defines/binding* edge from an anchor spanning
  the text `operator()`.

[kythe,Java,"Class names bind their definitions."]
--------------------------------------------------------------------------------
//- @E defines/binding ClassE
public class E {}
--------------------------------------------------------------------------------

[kythe,Java,"Method names bind their definitions."]
--------------------------------------------------------------------------------
public class E {
  //- @main defines/binding MethodMain
  public static void main(String[] args) {}
}
--------------------------------------------------------------------------------

[kythe,C++,"Variable definitions define bindings for variables."]
--------------------------------------------------------------------------------
//- @x defines/binding VariableX
int x;
--------------------------------------------------------------------------------

[[documents]]
documents
~~~~~~~~~

Brief description::
  A *documents* B if A describes (in possibly marked up natural language) the
  semantic object B.
Commonly arises from::
  documentation comments
Points from::
  anchors and <<doc>>s
Points toward::
  semantic nodes
Ordinals are used::
  never
Notes::
  Kythe does not specify a particular flavor of markup. Documentation comment
  anchors include all of the characters of the comment, including (e.g.) the
  $$///$$s. It is up to the language indexer to determine which comments to
  treat as documentation comments.
See also::
  <<doc,refdoc,ref/doc>>

In the $$C++$$ example below, there are really two documentation blocks: the
first comes from merging together the verification annotations; the second is
the Doxygen-style $$///$$ line. The Doxygen line is not merged with the verifier
lines owing to heuristics in Clang's comment parser.

[kythe,C++,"Comments document objects."]
--------------------------------------------------------------------------------
int v;   //- @"/// An empty class." documents ClassC
         //- ClassC.node/kind record
/// An empty class.
class C { };
--------------------------------------------------------------------------------

[[extends]]
extends
~~~~~~~

Brief description::
  A *extends* B if A is a direct nominal subtype of B.
Commonly arises from::
  inheritance
Points from::
  semantic nodes
Points toward::
  type/semantic nodes
Ordinals are used::
  never
Notes::
  An indexer may emit more descriptive edges with the *extends* prefix.
  For example, $$C++$$ will emit *extends/public*, *extends/public/virtual*,
  *extends/protected*, *extends/protected/virtual*, *extends/private*,
  *extends/private/virtual*, and *extends/virtual*.

[kythe,Java,"Classes extend classes."]
--------------------------------------------------------------------------------
package pkg;
public class E {
  //- @A defines/binding ClassA
  static class A { }
  //- @B defines/binding ClassB
  //- ClassB extends ClassA
  static class B extends A { }
}
--------------------------------------------------------------------------------

[kythe,C++,"Classes extend classes."]
--------------------------------------------------------------------------------
//- @A defines/binding ClassA
class A { };
//- @B defines/binding ClassB
//- ClassB extends/public ClassA
class B : public A { };
--------------------------------------------------------------------------------


[[generates]]
generates
~~~~~~~~~
Brief description::
  A *generates* B if A is related to B through some extralingual process.
Commonly arises from::
  code generation
Points from::
  semantic nodes
Points toward::
  semantic nodes
Ordinals are used::
  never
See also::
  <<replacement>>, <<replaces>>

Tools like RPC interface generators read specification languages and emit
code in one or more target languages. Although the specification language
and target languages do not share Kythe indexers, it is still semantically
useful to connect the nodes they emit. For example, one might want to list
all the $$C++$$ and Java uses of a particular service call, starting at the
specification of that service. The specification and its generated artifacts
may be joined by the *generates* edge.


[[instantiates]]
instantiates
~~~~~~~~~~~~

Brief description::
  A *instantiates* B if A is the result of monomorphizing B.
Commonly arises from::
  implicit template application
Points from::
  semantic nodes
Points toward::
  semantic nodes (<<tapp>>)
Ordinals are used::
  never
See also::
  <<instantiatesspeculative,[instantiates/speculative]>>, <<specializes>>

In $$C++$$, *specialization* and *instantiation* capture distinct relationships.
Every template `T` has a primary template, which defines the number and kind
of template parameters that are written down whenever `T` is (normally)
expressed. Other templates *specialize* `T` by specifying alternate bodies
for the template depending on the values bound to the template parameters.
This *specializes* relationship is always between a more-specific (or implicit)
template and its primary template (applied to one or more arguments). We do not
attempt to model a subtyping relationship between template specializations.

When `T<...>` is written down, an element from the set of *T* and its
specializations must be chosen for manifestation. This element may have free
type parameters. These are deduced during the process of *instantiating* the
chosen specialization of *T*. Some $$C++$$ _total specializations_ do not bind
any template parameters. Other $$C++$$ _partial specializations_ do, and may
bind different numbers of type parameters than the primary template. The
*instantiates* relationship records which total or partial specialization was
chosen (or if the primary template was chosen), and the template arguments that
were matched to that specialization's parameters. In contrast, the *specializes*
relationship for `T<...>` records the primary template for T, as well as which
template arguments were substituted for the primary template's parameters.

When the primary template is chosen for the *instantiates* relationship, the
*specializes* edge points to the same node:

[kythe,C++,"Instantiating the primary template"]
--------------------------------------------------------------------------------
//- @t_equals_float defines/binding PrimaryTemplate
template<typename T, typename S> bool t_equals_float = false;

//- @t_equals_float ref TEqualsFloatForLongLong
//- TEqualsFloatForLongLong instantiates TAppLongLong
//- TEqualsFloatForLongLong specializes TAppLongLong
//- TAppLongLong param.0 PrimaryTemplate
bool is_false = t_equals_float<long, long>;
--------------------------------------------------------------------------------

When a specialization of a template is chosen for *instantiates*, the
*specializes* edge still points to the primary template applied to the correct
number of arguments. The *instantiates* edge points to the specialization that
was used. It is applied to the template arguments appropriate for that
specialization. Note in the below example how we *specialize*
`PrimaryTemplate<float, long>` but *instantiate* `SpecificTemplate<long>`:

[kythe,C++,"Instantiating a partial specialization"]
--------------------------------------------------------------------------------
//- @t_equals_float defines/binding PrimaryTemplate
template<typename T, typename S> bool t_equals_float = false;
//- @int ref IntType @long ref LongType
int i; long l;

//- @t_equals_float defines/binding SpecificTemplate
template <typename S> bool t_equals_float<float, S> = true;
//- @t_equals_float ref TEqualsFloatForFloatLong
//- TEqualsFloatForFloatLong instantiates TAppSpecificFloatLong
//- TAppSpecificFloatLong param.0 SpecificTemplate
//- TAppSpecificFloatLong param.1 LongType
//- TEqualsFloatForLongLong specializes TAppPrimaryFloatLong
//- TAppPrimaryFloatLong param.0 PrimaryTemplate
//- TAppPrimaryFloatLong param.1 FloatType
//- TAppPrimaryFloatLong param.2 LongType
bool is_true = t_equals_float<float, long>;
--------------------------------------------------------------------------------

Here is another similar example:

[kythe,C++,"Instantiation versus specialization."]
--------------------------------------------------------------------------------
//- @v defines/binding PrimaryTemplate
template <typename T, typename S, typename V> T v;
template <typename U>
//- @v defines/binding PartialSpecialization
U v<int, U, long>;
//- @v ref ImplicitSpecialization
float w = v<int, float, long>;
//- ImplicitSpecialization specializes TAppPrimaryTemplate
//- ImplicitSpecialization instantiates TAppPartialSpecialization
//- TAppPrimaryTemplate param.0 PrimaryTemplate
//- TAppPrimaryTemplate param.1 vname("int#builtin",_,_,_,_)
//- TAppPrimaryTemplate param.2 vname("float#builtin",_,_,_,_)
//- TAppPrimaryTemplate param.3 vname("long#builtin",_,_,_,_)
//- TAppPartialSpecialization param.0 PartialSpecialization
//- TAppPartialSpecialization param.1 vname("float#builtin",_,_,_,_)
--------------------------------------------------------------------------------

[[instantiatesspeculative]]
instantiates/speculative
~~~~~~~~~~~~~~~~~~~~~~~~

Brief description::
  A *instantiates/speculative* B if A could be the result of monomorphizing B.
Commonly arises from::
  implicit template application
Points from::
  semantic nodes
Points toward::
  semantic nodes (<<tapp>>)
Ordinals are used::
  never
See also::
  <<instantiates>>, <<specializes>>

It may not be possible to decide whether a type instantiation actually occurs,
especially when dependent types are involved. The *instantiates/speculative*
and *specializes/speculative* edges are like the *instantiates* and
*specializes* edges, but they also record the fact that the instantiation
(specialization) did not occur when the code was indexed.

[kythe,C++,"Speculative instantiation and specialization."]
--------------------------------------------------------------------------------
// Checks indexing refs and defs of dependent function specializations.
//- @f defines/binding AbsF1
template <typename S> long f(S s) { return 0; }
//- @f defines/binding AbsF2
template <typename S> int f(S s) { return 0; }
template <typename T> struct S {
  // Note that C++ doesn't even check the kindedness of these type applications.
  friend
  //- @f defines/binding DepSpecFT
  //- DepSpecFT instantiates/speculative TAppAbsF1T
  //- DepSpecFT specializes/speculative TAppAbsF1T
  //- TAppAbsF1T param.0 AbsF1
  //- DepSpecFT instantiates/speculative TAppAbsF2T
  //- DepSpecFT specializes/speculative TAppAbsF2T
  //- TAppAbsF2T param.0 AbsF2
  long f<int, short>(T t) { return 1; }
};
--------------------------------------------------------------------------------

[[named]]
named
~~~~~

Brief description::
  A *named* B if B identifies A.
Commonly arises from::
  definitions and declarations
Points from::
  semantic nodes
Points toward::
  names
Ordinals are used::
  never
See also::
  <<name>>

[kythe,C++,"Variables have names."]
--------------------------------------------------------------------------------
//- @x defines/binding VariableX
//- VariableX named NameX
int x;
--------------------------------------------------------------------------------

[kythe,Java,"Classes have names."]
--------------------------------------------------------------------------------
package pkg;
//- @E defines/binding ClassE
//- ClassE named vname("pkg.E","","","","java")
public class E {
}
--------------------------------------------------------------------------------

[[overrides]]
overrides
~~~~~~~~~

Brief description::
  A *overrides* B if A directly overrides B in an inheritance-based relationship.
Points from::
  semantic nodes
Points toward::
  semantic nodes
Ordinals are used::
  never
See also::
  <<overridestransitive,[overrides/transitive]>>

[kythe,Java,"Methods have overrides edges."]
--------------------------------------------------------------------------------
package pkg;
public class E {
  static class A implements I {
    //- @method defines/binding AMethod
    //- AMethod overrides IMethod
    public void method() {}
  }
  static class B extends A implements I {
    //- @method defines/binding BMethod
    //- BMethod overrides AMethod
    //- BMethod overrides IMethod
    public void method() {}
  }
  static interface I {
    //- @method defines/binding IMethod
    public void method();
  }
}
--------------------------------------------------------------------------------

[[overridestransitive]]
overrides/transitive
~~~~~~~~~~~~~~~~~~~~

Brief description::
  A *overrides/transitive* B if A transitively overrides B, but the relationship
  A <<overrides>> B doesn't exist.
Points from::
  semantic nodes
Points toward::
  semantic nodes
Ordinals are used::
  never
See also::
  <<overrides>>

[kythe,Java,"Methods have overrides/transitive edges."]
--------------------------------------------------------------------------------
package pkg;
public class E {
  static class A {
    //- @method defines/binding AMethod
    public void method() {}
  }
  static class B extends A {
    //- @method defines/binding BMethod
    //- !{ BMethod overrides/transitive AMethod }
    public void method() {}
  }
  static class C extends B {
    //- @method defines/binding CMethod
    //- !{ CMethod overrides/transitive BMethod }
    //- CMethod overrides/transitive AMethod
    public void method() {}
  }
}
--------------------------------------------------------------------------------

[[param]]
param
~~~~~

Brief description::
  A *param.N* B if B is the Nth parameter of A.
Commonly arises from::
  ordered lists
Points from::
  semantic nodes
Points toward::
  semantic nodes
Ordinals are used::
  always

[kythe,C++,"Type applications have parameters."]
--------------------------------------------------------------------------------
//- @"int*" ref PtrInt
//- PtrInt param.0 PointerConstructor
//- PtrInt param.1 IntType
using T = int*;
--------------------------------------------------------------------------------

[[ref]]
ref
~~~

Brief description::
  A *ref* B if A refers to some previously-defined B.
Commonly arises from::
  expressions, spelled-out types
Points from::
  anchors
Points toward::
  semantic nodes

[kythe,C++,"Mentions of variables are refs."]
--------------------------------------------------------------------------------
//- @x defines/binding VariableX
int x;
//- @y defines/binding VariableY
//- @x ref VariableX
int y = x;
--------------------------------------------------------------------------------

[[refcall]]
ref/call
~~~~~~~~

Brief description::
  A *ref/call* F if A is an anchor that calls F.
Points from::
  anchors
Points toward::
  <<function,functions>>
Ordinals are used::
  never

[kythe,C++,"Anchors inside functions call functions."]
--------------------------------------------------------------------------------
//- @A defines/binding FnA
void A() { }
//- @B defines/binding FnB
//- ACall childof FnB
//- ACall.node/kind anchor
//- ACall ref/call FnA
void B() { A(); }
--------------------------------------------------------------------------------

[[refdoc]]
ref/doc
~~~~~~~

Brief description::
  A *ref/doc* C if A is an anchor inside a block of documentation that refers
  to C.
Points from::
  anchors
Points toward::
  semantic nodes
Ordinals are used::
  never
See also::
  <<documents,documents>>

[kythe,C++,"Anchors in documentation can refer to semantic nodes."]
--------------------------------------------------------------------------------
//- @param_a ref/doc FooParamA
//- FnFoo param.0 FooParamA
//- FnFoo.node/kind function
/// `param_a` is the first parameter.
void foo(int param_a) { }
--------------------------------------------------------------------------------

[[refexpands]]
ref/expands
~~~~~~~~~~~

Brief description::
  A *ref/expands* M if A is an anchor that expands macro M.
Points from::
  anchors
Points toward::
  <<macro,macros>>
Ordinals are used::
  never
Notes::
  This edge is used only for first-level macro expansions (where the macro
  being expanded is spelled out in the source file). Subsequent expansions are
  recorded using the <<refexpandstransitive,[ref/expands/transitive]>> edge.

[kythe,C++,"Uttering the name of a macro expands it."]
--------------------------------------------------------------------------------
//- @FOO defines/binding MacroFoo
#define FOO BAR
//- @FOO ref/expands MacroFoo
int FOO;
--------------------------------------------------------------------------------

[[refexpandstransitive]]
ref/expands/transitive
~~~~~~~~~~~~~~~~~~~~~~

Brief description::
  A *ref/expands/transitive* M if A is an anchor that expands macro M', which
  (after one or more additional expansions) expands macro M.
Points from::
  anchors
Points toward::
  <<macro,macros>>
Ordinals are used::
  never
Notes::
  First-level macro expansions (like those written down in the source file)
  are recorded with the <<refexpands,[ref/expands]>> edge.

[kythe,C++,"Macros can expand other macros."]
--------------------------------------------------------------------------------
//- @MB defines/binding MacroB
#define MB x
//- @MA defines/binding MacroA
#define MA MB
//- @MA ref/expands/transitive MacroB
//- @MA ref/expands MacroA
//- !{ @MA ref/expands/transitive MacroA }
int MA;
--------------------------------------------------------------------------------

[[refimports]]
ref/imports
~~~~~~~~~~~~

Brief description::
  A *ref/imports* B if B is imported at the site of A.
Points from::
  anchors
Points toward::
  semantic nodes
Ordinals are used::
  never

[kythe,Java,"Import references a class."]
--------------------------------------------------------------------------------
//- @LinkedList ref/imports LL
import java.util.LinkedList;
public class E {
  //- @LinkedList ref LL
  LinkedList field;
}
--------------------------------------------------------------------------------

[[refincludes]]
ref/includes
~~~~~~~~~~~~

Brief description::
  A *ref/includes* F if A is an anchor that inlines the text of file F.
Points from::
  anchors
Points toward::
  <<file,files>>
Ordinals are used::
  never

[kythe,C++,"Includes include files."]
--------------------------------------------------------------------------------
//- @"\"test.h\"" ref/includes HeaderFile
//- HeaderFile.node/kind file
#include "test.h"

#example test.h
// ...
--------------------------------------------------------------------------------

[[refqueries]]
ref/queries
~~~~~~~~~~~

Brief description::
  A *ref/queries* M if A is an anchor that queries whether macro M is bound.
Points from::
  anchors
Points toward::
  <<macro,macros>>, <<name,names>>
Ordinals are used::
  never

[kythe,C++,"Queries can be bound or unbound."]
--------------------------------------------------------------------------------
//- @FOO defines/binding MacroFoo
#define FOO BAR
//- @FOO ref/queries MacroFoo
//- MacroFoo named vname("FOO#m",_,_,_,_)
#if defined(FOO)
#endif
//- @BAZ ref/queries vname("BAZ#m",_,_,_,_)
#ifdef BAZ
#endif
--------------------------------------------------------------------------------


[[replaces]]
replaces
~~~~~~~~
Brief description::
  A *replaces* B if A's VName should be substituted everywhere for B's.
Commonly arises from::
  code generation
Points from::
  semantic nodes
Points toward::
  semantic nodes; never another *replacement*
Ordinals are used::
  never
See also::
  <<generates>>, <<replacement>>

A Kythe graph is not complete until (for all nodes N) for every edge N to B
(or B to N), there exists an edge from N to A (or A to N) with the same kind
and facts as the original edge.


[[specializes]]
specializes
~~~~~~~~~~~

Brief description::
  A *specializes* B if A provides a declaration of a type specialization B.
Commonly arises from::
  template total and partial specialization
Points from::
  semantic nodes
Points toward::
  semantic nodes (<<tapp>>)
Ordinals are used::
  never
See also::
  <<instantiates>>, <<instantiatesspeculative,[instantiates/speculative]>>

[kythe,C++,"Template specializations specialize."]
--------------------------------------------------------------------------------
//- @C defines/binding TemplateClassC
template <typename T> class C { };
//- @C defines/binding SpecializedClassC
template <> class C<int> { };
//- SpecializedClassC specializes TAppCInt
//- TAppCInt.node/kind tapp
//- TAppCInt param.0 TemplateClassC
//- TemplateClassC.node/kind abs
--------------------------------------------------------------------------------

[kythe,C++,"Function templates specialize."]
--------------------------------------------------------------------------------
//- @id defines/binding IdFn
template <typename T> T id(T x) { return x; }
//- @id defines/binding IdSpecFn
template <> bool id(bool x) { return !(!x); }
//- IdSpecFn specializes TAppIdFnBool
//- TAppIdFnBool.node/kind tapp
//- TAppIdFnBool param.0 IdFn
//- TAppIdFnBool param.1 vname("bool#builtin",_,_,_,_)
--------------------------------------------------------------------------------


[[specializesspeculative]]
specializes/speculative
~~~~~~~~~~~~~~~~~~~~~~~
See <<instantiatesspeculative,[instantiates/speculative]>>.


[[typed]]
typed
~~~~~

Brief description::
  A is *typed* B if A has the type B.
Commonly arises from::
  terms with types; definitions and declarations
Points from::
  anchors
Points toward::
  types
Ordinals are used::
  never

[kythe,C++,"Enumerations can be ascribed types."]
--------------------------------------------------------------------------------
//- @E defines/binding EnumE
//- EnumE typed IntType
enum E : int;
--------------------------------------------------------------------------------

[[undefines]]
undefines
~~~~~~~~~

Brief description::
  A *undefines* M if A detaches M from M's binding.
Commonly arises from::
  macro undefinition
Points from::
  anchors
Points toward::
  <<macro,macros>>

[kythe,C++,"Undef undefines macros."]
--------------------------------------------------------------------------------
//- @FOO defines/binding MacroFoo
#define FOO BAR
//- @FOO undefines MacroFoo
#undef FOO
//- @FOO defines/binding DifferentMacroFoo
#define FOO BAZ
--------------------------------------------------------------------------------

Node kinds
----------

[[abs]]
abs
~~~

Brief description::
  An *abs* abstracts over a subgraph by binding <<absvar>>s.
See also::
  <<absvar>>, <<specializes>>, <<tapp>>

It is not necessarily the case that the child of the abs node be a type;
for example, in $$C++$$, it may be a variable or a function.

[kythe,C++,"Templates are abs nodes."]
--------------------------------------------------------------------------------
//- @C defines/binding TemplateC
//- TemplateC.node/kind abs
//- TemplateCBody childof TemplateC
//- TemplateCBody.node/kind record
template <typename T, typename S> class C { };

//- @C defines/binding PartialSpecializationC
//- PartialSpecializationC.node/kind abs
template <typename U> class C<int, U> { };

//- @C defines/binding TotalSpecializationC
//- TotalSpecializationC.node/kind record
template <> class C<int, float> { };
--------------------------------------------------------------------------------

[[absvar]]
absvar
~~~~~~

Brief description::
  An *absvar* is bound by an <<abs>> and valid in its children.
See also::
  <<abs>>, <<specializes>>

[kythe,C++,"Type variables are absvars."]
--------------------------------------------------------------------------------
//- @C defines/binding TemplateC
//- @T defines/binding AbsVarT
//- AbsVarT.node/kind absvar
//- TemplateC param.0 AbsVarT
template <typename T> class C {
//- @T ref AbsVarT
  using S = T;
};
--------------------------------------------------------------------------------

[[anchor]]
anchor
~~~~~~

Brief description::
  An *anchor* connects concrete syntax to abstract syntax.
Naming convention::
  Language:::
    No special rules.
  Path:::
    The *Path* of the <<file>> this anchor is <<childof>> (or empty if there is
    no such file).
  Root:::
    The *Root* of the <<file>> this anchor is <<childof>>.
  Corpus:::
    The *Corpus* of the <<file>> this anchor is <<childof>>.
  Signature:::
    No special rules.
Expected out-edges::
  <<childof>>
Facts::
  loc/start:::
    The starting byte offset (from 0) in the <<file>> this anchor is <<childof>>
  loc/end:::
    The ending byte offset (exclusive) in the <<file>> this anchor is
    <<childof>>
  subkind::
    If set to `implicit`, this anchor should not also have `loc/start` or
    `loc/end` facts. It is an artifact of some internal process that may still
    have important semantic effects.
See also::
  <<file>>

Anchor VNames are specified such that one may determine the VName of the
<<file>> an anchor is <<childof>> by dropping the anchor VName's *Language*
and *Signature* fields.

[kythe,C++,"Anchors have byte offsets."]
--------------------------------------------------------------------------------
int 錨;
//- VarNameAnchor.loc/start 4
//- VarNameAnchor.loc/end 7
// Note that the glyph 錨 is encoded in UTF-8 as [e9 8c a8].
--------------------------------------------------------------------------------

[kythe,C++,"Anchors have VName rules."]
--------------------------------------------------------------------------------
//- @foo=vname(_,Corpus,Root,Path,"c++") childof vname("",Corpus,Root,Path,"")
int foo;
--------------------------------------------------------------------------------

[kythe,Java,"Anchors can overlap."]
--------------------------------------------------------------------------------
import java.util.Optional;
public class E {
  //- @"Optional<String>" ref TSpecClass
  //- @Optional ref OptClass
  //- @String ref StrClass
  Optional<String> f;
}
--------------------------------------------------------------------------------

[kythe,C++,"Implicit anchors arise from default constructors."]
--------------------------------------------------------------------------------
//- @C defines/binding ClassC
//- CCtor childof ClassC
//- CCtor.subkind constructor
//- CCtor.complete definition
class C { };
//- @D defines/binding ClassD
//- DCtor childof ClassD
//- DCtor.subkind constructor
//- DCtor.complete definition
class D { C c; };
D d;
//- ImplicitCallToCCtor.node/kind anchor
//- ImplicitCallToCCtor.subkind implicit
//- ImplicitCallToCCtor ref/call CCtor
//- ImplicitCallToCCtor childof DCtor
--------------------------------------------------------------------------------


[kythe,Java,"Anchors have VName rules."]
--------------------------------------------------------------------------------
public class E {
  //- @foo=vname(_,Corpus,Root,Path,"java") childof vname("",Corpus,Root,Path,"")
  int foo;
}
--------------------------------------------------------------------------------

[[constant]]
constant
~~~~~~~~

Brief description::
  A *constant* is a value that can be statically determined.
Facts::
  text:::
    A string representation of the constant.
See also::
  <<sum>>

[kythe,C++,"Enumerators are constants."]
--------------------------------------------------------------------------------
enum E {
//- @EM defines/binding Enumerator
  EM = 42
};
//- Enumerator.node/kind constant
//- Enumerator.text 42
--------------------------------------------------------------------------------

[kythe,Java,"Enumeration values are constants."]
--------------------------------------------------------------------------------
public enum E {
  //- @A defines/binding A
  //- A.node/kind constant
  A;
}
--------------------------------------------------------------------------------

[[doc]]
doc
~~~
Brief description::
  A *doc* is text that documents a node.
Facts::
  text:::
    The text of the document. The encoding must be UTF-8.
Notes::
  Embedded references inside a *doc* node's *text* are delimited using `[`
  and `]`. Ordinary brackets are escaped as `\[` and `\[`; backslash is escaped
  as `\\`. Targets of embedded references are stored as *param* edges on the
  document, where the nth opening bracket is matched with the nth *param*.
  Indexers should strip off comment delimiters.

See also::
  <<documents>>

In the following example, the `\n` in the assertion about `DocNode.text` is
stored as a newline in the graph. The escape is there for the verifier.

[kythe,C++,"Doc nodes contain documentation text."]
--------------------------------------------------------------------------------
/// A function.
/// It sums its parameters `x` and `y`.
int f(int x, int y) {
  return x + y;
}
//- DocNode documents FnF
//- DocNode.node/kind doc
//- DocNode.text " A function.\n It sums its parameters `[x]` and `[y]`."
//- DocNode param.0 VarX
//- DocNode param.1 VarY
//- FnF param.0 VarX
//- FnF param.1 VarY
--------------------------------------------------------------------------------

[[file]]
file
~~~~

Brief description::
  A *file* is an array of bytes with a significant external name.
Naming convention::
  Language:::
    *empty*
  Path:::
    *External path to this file (or some other unique ID if this file is
    virtual)*
  Signature:::
    *empty*
Facts::
  text:::
    Uninterpreted content as an array of bytes.
  text/encoding:::
    Encoding of the text fact.  See
    http://www.w3.org/TR/encoding/#names-and-labels for standard values.  If
    empty, "UTF-8" is assumed.
See also::
  <<anchor>>, <<refincludes,[ref/includes]>>

[kythe,C++,"Anchors are children of files."]
--------------------------------------------------------------------------------
int x;
//- XAnchor.node/kind anchor
//- XAnchor.loc/start 4
//- XAnchor.loc/end 5
//- XAnchor childof SourceFile
//- SourceFile.node/kind file
--------------------------------------------------------------------------------

[[interface]]
interface
~~~~~~~~~

Brief description::
  An *interface* defines an implementable type.

[kythe,Java,"Interfaces are interfaces."]
--------------------------------------------------------------------------------
//- @I defines/binding Interface
//- Interface.node/kind interface
public interface I {}
--------------------------------------------------------------------------------

[[function]]
function
~~~~~~~~

Brief description::
  A *function* binds zero or more parameters and returns a result.
Facts::
  complete:::
    `incomplete` if this is only a declaration; `definition` if it is a
    definition.
  subkind:::
    `constructor` for constructors; `destructor` for destructors;
    `none` or unspecified for normal or member functions

[kythe,C++,"Functions are functions."]
--------------------------------------------------------------------------------
//- @F defines/binding FnF
//- FnF.node/kind function
//- FnF.complete incomplete
//- @X defines/binding VarX
//- VarX.complete incomplete
//- FnF param.0 VarX
void F(int X);
--------------------------------------------------------------------------------

[[lookup]]
lookup
~~~~~~~

Brief description::
  A *lookup* is a structured name whose resolution cannot be completed
  without additional context.
Facts::
  text:::
    The deferred name to be resolved.
Notes::
  Name resolution can be a complicated problem. In $$C++$$ templates, the
  meaning of a dependent name cannot be determined until the template
  parameters it depends upon are supplied. Similarly, in dynamic languages
  like Python, name resolution may depend on the runtime context.
  Nevertheless, when we are unable to come up with a semantic representation
  of one or more nodes in a path-structured name, we record this name as
  a collection of *lookup* nodes. Each *lookup* node has some *text* (the
  'dynamic' lookup done at that node) as well as some *params* (to record the
  semantic object into which *text* is being used as a key).

[kythe,C++,"Dependent names are lookups."]
--------------------------------------------------------------------------------
template
//- @T defines/binding DepT
<template <typename> class T>
struct C {
//- @D ref DepTIntD
using S = typename T<int>::D;
};
//- DepTIntD.text D
//- DepTIntD.node/kind lookup
//- DepTIntD param.0 DepTInt
//- DepTInt.node/kind tapp
//- DepTInt param.0 DepT
//- DepTInt param.1 Int
--------------------------------------------------------------------------------

[kythe,C++,"Lookups record paths."]
--------------------------------------------------------------------------------
template
<template <typename> class T>
struct C {
//- @F ref DepTIntDEF
//- DepTIntDEF.text F
//- @E ref DepTIntDE
//- DepTIntDE.text E
//- @D ref DepTIntD
//- DepTIntD.text D
using S = typename T<int>::D::E::F;
};
//- DepTIntDEF param.0 DepTIntDE
//- DepTIntDE param.0 DepTIntD
--------------------------------------------------------------------------------

[[macro]]
macro
~~~~~
Brief description::
  A *macro* is a metaprogram that operates on source text.
Notes::
  Macros are distinct from <<abs,abs>> because they do not
  participate in the programming language proper. Instead, they are evaluated
  separately, usually before semantic analysis takes place.
See also::
  <<refexpands,[ref/expands]>>, <<refexpandstransitive,[ref/expands/transitive]>>,
  <<refqueries,[ref/queries]>>, <<undefines,[undefines]>>

[kythe,C++,"Defines define macros."]
--------------------------------------------------------------------------------
//- @FOO defines/binding MacroFoo
//- MacroFoo.node/kind macro
#define FOO BAR
--------------------------------------------------------------------------------

[[meta]]
meta
~~~~
Brief description::
  A *meta* is a node that describes details about a particular language.
Naming convention::
  Signature:::
    *kythe-node-name*#meta
  Language:::
    See <<lsr,Language-specific rules>> for language identifiers.
Facts::
  format:::
    See <<formats>>.

[kythe,C++,"C++ defines a default tapp format."]
--------------------------------------------------------------------------------
//- vname("tapp#meta","","","","c++").node/kind meta
//- vname("tapp#meta","","","","c++").format "%0.<%1,>"
--------------------------------------------------------------------------------

[[name]]
name
~~~~

Brief description::
  A *name* identifies zero or more nodes.
Naming convention::
  Signature:::
    *language-specific-string*#*language-specific-tag*
  Language:::
    See <<lsr,Language-specific rules>> for language identifiers.
Notes::
  See the <<lsr,Language-specific rules>> section below for name formation
  rules.

[kythe,C++,"Declarations and definitions share the same name."]
--------------------------------------------------------------------------------
//- @C defines/binding CDecl
class C;
//- @C defines/binding CDefn
class C { };
//- CDecl named CName=vname("C#c","","","","c++")
//- CDefn named CName
//- CName.node/kind name
--------------------------------------------------------------------------------

[[package]]
package
~~~~~~

Brief description::
  A *package* defines a module containing declarations.

[kythe,Java,"Top-level declarations are children of package nodes."]
--------------------------------------------------------------------------------
//- @pkg ref Pkg
//- Pkg named vname("pkg","","","","java")
//- Pkg.node/kind package
package pkg;
//- @E defines/binding ClassE
//- ClassE childof Pkg
public class E {}
--------------------------------------------------------------------------------

[[record]]
record
~~~~~~

Brief description::
  A *record* defines a type composed of a collection of elements.
Facts::
  subkind:::
    <<lsr,Language-specific subkind>> for this record.
  complete:::
    `incomplete` if this is only a declaration; `definition` if it is a
    definition.
Notes::
  This node is a nominal record such that two records with the same
  children but different names should always be considered to be distinct.

[kythe,C++,"Classes are records."]
--------------------------------------------------------------------------------
//- @C defines/binding ClassCDecl
//- ClassCDecl.node/kind record
//- ClassCDecl.complete incomplete
class C;

//- @C defines/binding ClassCDefn
//- ClassCDefn.node/kind record
//- ClassCDefn.complete definition
class C { };
--------------------------------------------------------------------------------

[kythe,Java,"Classes are records."]
--------------------------------------------------------------------------------
package pkg;
//- @E defines/binding ClassE
//- ClassE.node/kind record
//- ClassE.subkind class
public class E {
}
--------------------------------------------------------------------------------


[[replacement]]
replacement
~~~~~~~~~~~

Brief description::
  A *replacement* node gives another VName to a node in the graph.
Expected out-edges::
  <<replaces>>
See also::
  <<generates>>
Notes::
  *Replacement* nodes are useful when linking between the output of different
  indexers. For example, a tool may take an interface specification and emit
  skeleton code for that interface in a different language. This tool also
  annotates its generated code with references back to encoded identifiers in
  the original specification. An indexer for the specification language can
  generate *replacement* nodes with these identifiers encoded as VNames and
  can connect its own semantic nodes up to them using <<replaces>> edges.
  An indexer for the generated code can then attach other edges, like
  <<generates>>, to the *replacement* nodes. When the *replacement* nodes
  are eliminated, the specification indexer's nodes will *generate* the
  target language indexer's nodes.

In this example, `MetadataRecordM` is a node whose VName can be generated using
annotations from an RPC interface generator. The indexer for the source files
for that generator emit Kythe data that describe syntactic and semantic
relationships with regard to the interface generator's source language. This
indexer also associates some of the nodes involved in these relationships with
*replacement* nodes like `MetadataRecordM`.

[kythe,clike,"Output from interface generator"]
--------------------------------------------------------------------------------
//- @M defines/binding MessageM
//- MessageM.node/kind record
//- MessageM replaces MetadataRecordM
//- MetadataRecordM.node/kind replacement
message M { }
--------------------------------------------------------------------------------

The indexer for the interface generator's target language is able to import
the annotations. It uses them to add new edges to connect target language
objects up to the externally-nameable *replacement* nodes.

[kythe,clike,"Output from indexer using metadata from interface generator"]
--------------------------------------------------------------------------------
// These relationships are derived only from the target language:
//- @MImpl defines/binding MessageMImpl
//- MessageMImpl.node/kind record
class MImpl { };
// This relationship is established because of imported annotations:
//- MetadataRecordM generates MessageMImpl
--------------------------------------------------------------------------------

In a complete Kythe graph, all edges that include a *replacement* node are
duplicated with the *replacement* node changed out for the node that *replaces*
it. The original *replaces* edge and *replacement* node (and the other edges
that name it) may or may not remain.

[kythe,clike,"Graph after replacement elaboration"]
--------------------------------------------------------------------------------
//- MessageM replaces MetadataRecordM
//- MetadataRecordM generates MessageMImpl

// When we apply the replacement rule described above with the replacement node
// MetadataRecordM, we can derive the following edge:
//- MessageM generates MessageMImpl

// In other words, we cut one hop out of:
//     MessageM --replaces-> MetadataRecordM --generates-> MessageMImpl
// by using the replacement rule to add the new edge:
//                   MessageM --generates-> MessageMImpl

//- @MImpl defines/binding MessageMImpl
//- MessageMImpl.node/kind record
class MImpl { };
--------------------------------------------------------------------------------


[[sum]]
sum
~~~

Brief description::
  A *sum* defines a type whose instances must choose one out of a set of
  possible representations.
Facts::
  subkind:::
    <<lsr,Language-specific subkind>> for this record.
  complete:::
    * `incomplete` if this is only a declaration.
    * `complete` if this is a declaration that is considered usable by value.
    * `definition` if this provides a full description of the type.

[kythe,C++,"Enums are sums."]
--------------------------------------------------------------------------------
//- @CE defines/binding EnumCE
//- EnumCE.node/kind sum
//- EnumCE.complete definition
enum CE { };

//- @E defines/binding EnumE
//- EnumE.node/kind sum
//- EnumE.complete incomplete
enum class E;

//- @E defines/binding EnumETyped
//- EnumETyped.node/kind sum
//- EnumETyped.complete complete
enum class E : int;

//- @E defines/binding EnumEDefn
//- EnumEDefn.node/kind sum
//- EnumEDefn.complete definition
enum class E : int { };
--------------------------------------------------------------------------------

[kythe,Java,"Enums are sum/enumClasses."]
--------------------------------------------------------------------------------
//- @E defines/binding EnumE
//- E.node/kind sum
//- E.subkind enumClass
public enum E {}
--------------------------------------------------------------------------------

[[talias]]
talias
~~~~~~

Brief description::
  A *talias* gives a new name to an existing type.
Expected out-edges::
  <<aliases>>, <<named>>
Notes::
  A *talias* may be virtually removed from the graph. Some languages may have
  additional reduction rules.

[kythe,C++,"Type aliases are taliases."]
--------------------------------------------------------------------------------
//- @Counter defines/binding TAlias
//- TAlias.node/kind talias
using Counter = int;
--------------------------------------------------------------------------------

[[tapp]]
tapp
~~~~

Brief description::
  A *tapp* applies a type constructor or <<abs>> to zero or more parameters.
Expected out-edges::
  <<param>> (at least ordinal 0)

[kythe,C++,"Pointers are type constructors."]
--------------------------------------------------------------------------------
//- @"int*" ref IntPtrType
using PtrInt = int*;
//- IntPtrType.node/kind tapp
//- IntPtrType param.0 vname("ptr#builtin",_,_,_,"c++")
//- IntPtrType param.1 vname("int#builtin",_,_,_,"c++")
--------------------------------------------------------------------------------

[kythe,Java,"Generic classes are type constructors."]
--------------------------------------------------------------------------------
import java.util.Optional;
public class E {
  //- @f defines/binding Field
  //- Field typed TSpecClass
  //- TSpecClass.node/kind tapp
  //- TSpecClass param.0 OptClass
  //- TSpecClass param.1 StrClass
  Optional<String> f;
}
--------------------------------------------------------------------------------

[[tbuiltin]]
tbuiltin
~~~~~~~~

Brief description::
  A *tbuiltin* is a type that is supplied by the language itself.
Naming convention::
  Signature:::
    *language-specific-string*#builtin
Notes::
  See the <<lsr,Language-specific rules>> section below for enumerations of
  these builtin types.

[[tnominal]]
tnominal
~~~~~~~~

Brief description::
  A *tnominal* is a type that may be purely identified by its name.
Expected out-edges::
  <<named>>
Notes::
  When a `tnominal`'s definition is known, some <<lsr,language-specific rules>>
  dictate that the definition node be used instead of a `tnominal` in the
  type graph.

[kythe,C++,"Forward-declared classes are tnominals."]
--------------------------------------------------------------------------------
//- @C defines/binding ClassC
//- ClassC.node/kind record
//- ClassC named ClassCName
class C;
//- @"C*" ref PtrC
//- PtrC param.1 NominalC
//- NominalC.node/kind tnominal
//- NominalC named ClassCName
using Alias = C*;
--------------------------------------------------------------------------------


[[tsigma]]
tsigma
~~~~

Brief description::
  A *tsigma* is an ordered list of types that is unpacked on substitution.
Expected out-edges::
  <<param>> (at least ordinal 0)

[kythe,C++,"Parameter packs unpack tsigmas."]
--------------------------------------------------------------------------------
template <typename... Ts>
//- @f defines/binding FnTF
void f(Ts... ts) { }

//- @int ref IntType
//- @double ref DoubleType
//- @f ref FnF
int g(double x) { f(1, x); }

//- FnF instantiates AppFnTFSigma
//- AppFnTFSigma param.0 FnTF
//- AppFnTFSigma param.1 Sigma
//- Sigma.node/kind tsigma
//- Sigma param.0 IntType
//- Sigma param.1 DoubleType
--------------------------------------------------------------------------------


[[variable]]
variable
~~~~~~~~

Brief description::
  A *variable* is a location for storing data.
Facts::
  complete:::
    * `incomplete` if this is only a declaration.
    * `definition` if this is a variable definition.

[kythe,C++,"Variables are variables."]
--------------------------------------------------------------------------------
//- @x defines/binding VariableX
//- VariableX.node/kind variable
int x;
--------------------------------------------------------------------------------

[kythe,Java,"Fields are variables."]
--------------------------------------------------------------------------------
public class E {
  //- @f defines/binding Field
  //- Field.node/kind variable
  Optional<String> f;
}
--------------------------------------------------------------------------------

[kythe,Java,"Parameters are variables."]
--------------------------------------------------------------------------------
public class E {
  //- @arg defines/binding Param
  //- Param.node/kind variable
  void f(String arg) {}
}
--------------------------------------------------------------------------------

[kythe,Java,"Locals are variables."]
--------------------------------------------------------------------------------
public class E {
  void f() {
    //- @var defines/binding Local
    //- Local.node/kind variable
    String var;
  }
}
--------------------------------------------------------------------------------


[[vcs]]
vcs
~~~

Brief description::
  A *vcs* is a reference to a particular revision stored in a version control
  system.
Facts::
  vcs/id:::
    A stable identifier for a revision in the repository. For example, a
    Git repository uses commit hashes as identifiers.
  vcs/type:::
    * `darcs`: this is a Darcs repository.
    * `git`: this is a Git repository.
    * `hg`: this is a Mercurial repository.
    * `perforce`: this is a Perforce repository.
    * `svn`: this is a Subversion repository.
  vcs/uri:::
    A URI that points to the repository root. Acceptable values for this fact
    depend on the `vcs/type`.
Naming convention::
  When naming a `vcs` node, it is a good idea to use only the `corpus` field
  of a VName. You can then use that `corpus` value in the VNames of all nodes
  that are generated from that revision.
Notes::
  It is important that the `vcs` uses a stable reference to a revision. For
  example, using the name of a Git branch would not be a good idea, since
  Git branches point to different commits over time. It is better to use the
  (full) hash of the commit.

[[formats]]
Format strings
--------------

WARNING: This section is experimental.

Various Kythe nodes can be annotated with `format` facts. These facts are meant
to be used to generate user-visible strings that identify nodes. This is
distinct from the function of <<name>> nodes and <<named>> edges, which
represent (and attach to) names with various encodings, some of which may not
be sensible to show in a user interface.

A `format` fact is a UTF-8 string with embedded format tokens. These tokens
always begin with `%`. Some have an optional decimal number argument, denoted
`N` in the following table. We define a *format* function on nodes that produces
a string that represents some node (denoted *this*). Unescaped text is emitted
verbatim; otherwise, for each token, *format* makes the following substitutions:

[width="50%",options="header"]
|======================
|Format token | Definition
|%%           | Insert a literal *%*.
|%^           | For a single *N'* such that *this* *childof* *N'*, insert *format*(*N'*)
|%N.          | For a single *N'* such that *this* *param.N* *N'*, insert *format*(*N'*)
|%N`          | For a single *N'* such that *this* typed *M* and *M* *param.N* *N'*, insert *format*(*N'*)
|%N,          | For each integer *N'* starting at *N* and until there is no node *M* such that *this* *param.N'* *M*,
                for a single *M* such that *this* *param.N'* *M*, insert *format*(*M*), separating adjacent insertions
                with a comma and a space `", "`.
|======================

The `format` fact used by the expansion *format*(*this*) is determined as
follows:

  * If *this* has a `format` fact, use that.
  * If *this* is a <<tapp>> node that has a <<param>>.0 that has a `format`
     fact, use that. (If there are multiple candidates, choose one arbitrarily.)
  * If the <<meta>> node for the kind of *this* has a `format` fact, use that.
  * Otherwise, use the empty string.

Implementations are free to discard invalid tokens or tokens that fail to find
the necessary graph nodes. Implementations are also advised to implement a
maximum expansion width and depth and to emit a placeholder string (like "...")
if the output grows too large. It may be wise to store pre-expanded signatures
for a subset of formattable nodes in the graph. Format strings allow
implementations to decide which of these signatures to persist, reducing the
total amount of data produced and stored from indexers.

[kythe,C++,"Formatting a variable"]
--------------------------------------------------------------------------------
//- @ns defines/binding NsNs
//- NsNs.format "%^::ns"
namespace ns {
//- @x defines/binding VarX
//- VarX.format "%^::x"
//- VarX childof NsNs
//- VarX typed IntPtr
//- IntPtr.node/kind tapp
//- IntPtr param.0 Ptr
//- Ptr.format "%1.*"
//- IntPtr param.1 Int
//- Int.format "int"
  int* x;
}
--------------------------------------------------------------------------------

To format `VarX` in this example, we use `VarX`'s `format` fact, `%^::x`.
We must recursively format `NsNs`. `NsNs` has no parent, so `%^` has
no effect; we emit `::ns`, then `::x`, giving `::ns::x`.

To format `IntPtr`, we note that `IntPtr` is a <<tapp>> with a `param.0` with
a defined `format`, `%1.*`. `IntPtr`'s `param.1` is `Int`, with the literal
`format` `int`. We therefore produce `int*`.

[[lsr]]
Language-specific rules
-----------------------

$$C++$$
~~~~~~~

$$C++$$'s source language is spelled "`c++`".

Builtin types
^^^^^^^^^^^^^

$$C++$$ supplies the following <<tbuiltin>> nodes by default:

[kythe,C++,"Builtin type nodes"]
--------------------------------------------------------------------------------
//- @"void" ref vname("void#builtin","","","","c++")
using Void = void;

//- @"void*" ref TappPtrVoid
//- TappPtrVoid param.0 vname("ptr#builtin","","","","c++")
using PtrVoid = void*;

//- @"int" ref vname("int#builtin","","","","c++")
using Int = int;

//- @ConstVoid defines/binding TappConstVoidAlias
//- TappConstVoidAlias aliases TAppConstVoid
//- TAppConstVoid param.0 vname("const#builtin","","","","c++")
using ConstVoid = const void;

//- @VolatileVoid defines/binding TappVolatileVoidAlias
//- TappVolatileVoidAlias aliases TAppVolatileVoid
//- TAppVolatileVoid param.0 vname("volatile#builtin","","","","c++")
using VolatileVoid = volatile void;

///- @RestrictPtrVoid defines/binding TappRestrictPtrVoidAlias
///- TappRestrictPtrVoidAlias aliases TAppRestrictPtrVoid
///- TAppRestrictPtrVoid param.0 vname("restrict#builtin","","","","c++")
using RestrictPtrVoid = void * __restrict__;
--------------------------------------------------------------------------------

Record and sum subkinds
^^^^^^^^^^^^^^^^^^^^^^^

$$C++$$ defines the following subkinds for <<record>> nodes:

[kythe,C++,"Record subkinds"]
--------------------------------------------------------------------------------
//- @C defines/binding ClassC
//- C.subkind class
class C;

//- @S defines/binding StructS
//- S.subkind struct
struct S;

//- @U defines/binding UnionU
//- U.subkind union
union U;
--------------------------------------------------------------------------------

$$C++$$ defines the following subkinds for <<sum>> nodes:

[kythe,C++,"Sum subkinds"]
--------------------------------------------------------------------------------
//- @E defines/binding EnumE
//- E.subkind enum
enum E { };

//- @EC defines/binding EnumClassEC
//- EnumClassEC.subkind enumClass
enum class EC;
--------------------------------------------------------------------------------

Names
^^^^^

$$C++$$ defines the following language-specific tags for lexically scoped names:

  * `m`: macros (see <<macro>>)
  * `c`: class or struct (see <<record>>)
  * `u`: union (see <<record>>)
  * `n`: any other name

A $$C++$$ lexically-scoped name is stored as a colon-delimited path, starting
with the most specific name and ending with the most general.

[kythe,C++,"Lexically scoped names"]
--------------------------------------------------------------------------------
//- @C defines/binding ClassC
//- ClassC named vname("C#c",_,_,_,_)
class C;
namespace A {
//- @D defines/binding ClassD
//- ClassD named vname("D:A#c",_,_,_,_)
  class D;
  namespace B {
//- @E defines/binding ClassE
//- ClassE named vname("E:B:A#c",_,_,_,_)
    class E;
  }
}
--------------------------------------------------------------------------------

Anonymous namespaces are represented using `@#anon` and possibly some extra
(opaque) information. Scopes without names are given ordinal values reflecting
an arbitrary but consistent ordering between syntactic elements:

[kythe,C++,"Ordinal path nodes in names"]
--------------------------------------------------------------------------------
void foo() {
//- @x defines/binding VarNode
//- VarNode named vname("x:0:0:foo#n",_,_,_,_)
  int x;
//- @x defines/binding VarNode2
//- VarNode2 named vname("x:0:1:0:foo#n",_,_,_,_)
  { int x; }
//- @x defines/binding VarNode3
//- VarNode3 named vname("x:0:2:0:foo#n",_,_,_,_)
  { int x; }
}
--------------------------------------------------------------------------------

References to definitions and declarations of types
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

If the indexer has available a *definition* of a $$C++$$ node, edges should
be drawn directly to that node:

[kythe,C++,"Refer to definitions directly."]
--------------------------------------------------------------------------------
//- @C defines/binding ClassCDefn
class C { };
//- @Alias defines/binding CAlias
//- CAlias aliases ClassCDefn
using Alias = C;
--------------------------------------------------------------------------------

If the indexer only has a *complete* $$C++$$ node, or if the node is
*incomplete*, edges should be drawn to a <<tnominal>> node:

[kythe,C++,"Refer to complete or incomplete declarations indirectly."]
--------------------------------------------------------------------------------
//- @E defines/binding CompleteEnumE
//- CompleteEnumE named EnumEName
enum class E : int;
//- @Alias defines/binding EAlias
//- EAlias aliases EnumETNominal
//- EnumETNominal.node/kind tnominal
//- EnumETNominal named EnumEName
using Alias = E;
--------------------------------------------------------------------------------

When generating the name of a $$C++$$ type that requires looking down some
edge, the following should be kept in mind. If there are multiple possible
nodes connected by *edge*, consistently prefer one that has a `complete`
fact set to `definition`; failing that, prefer one that has a `complete`
fact set to `complete`; failing that, consistently prefer an arbitrary
node from the *edge*-connected set (see <<record>>, <<sum>>).

Qualifiers on types
^^^^^^^^^^^^^^^^^^^

The `const`, `restrict`, and `volatile` qualifiers may be applied to types.
These are represented as type constructors. The indexer always applies them
in the same order (`const` innermost, then `restrict`, then `volatile`) and
collapses redundant qualifiers should they arise (`const const` becomes
`const`). Tools should optimally canonicalize types according to these rules
(for instance, after removing a <<talias>> node).

[kythe,C++,"Qualifiers have canonical order."]
--------------------------------------------------------------------------------
//- @U defines/binding VRCAlias
//- VRCAlias aliases VRCInt
using U = int * __restrict__ const volatile;
//- @V defines/binding AnotherAlias
//- AnotherAlias aliases VRCInt
using V = int * volatile __restrict__ const;
--------------------------------------------------------------------------------

[kythe,C++,"Redundant CVR-qualifiers are dropped."]
--------------------------------------------------------------------------------
#arguments -Wno-duplicate-decl-specifier
//- @U defines/binding CIAlias
//- CIAlias aliases CIType
using U = const const int;
//- @V defines/binding AnotherCIAlias
//- AnotherCIAlias aliases CIType
using V = const int;
--------------------------------------------------------------------------------

Function types
^^^^^^^^^^^^^^

The `fn#builtin` type constructor is used to represent function types.
Its first parameter is the return type; subsequent parameters are arguments.

[kythe,C++,"Function types use a builtin type constructor."]
--------------------------------------------------------------------------------
//- @U defines/binding UAlias
//- UAlias aliases TAppFn
//- TAppFn param.0 vname("fn#builtin",_,_,_,_)
//- TAppFn param.1 vname("int#builtin",_,_,_,_)
//- TAppFn param.2 vname("short#builtin",_,_,_,_)
//- TAppFn param.3 vname("float#builtin",_,_,_,_)
using U = int(short, float);
--------------------------------------------------------------------------------

For K&R-style prototypes in C, the indexer will use the `knrfn#builtin` type.

Structural hashes
^^^^^^^^^^^^^^^^^

<<record>> and <<sum>> definitions are given vnames with `signatures` composed
of their lexical names and their *structural hash*, which unifies equivalent
definitions that appear across distinct and unrelated translation units.

Template template parameters
^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Template template parameters are stored as <<abs>>-dominated <<absvar>>
parameters of their binding abstractions. The name of the template template
parameter is given to the inner <<abs>>.

[kythe,C++,"We do not represent higher kinds"]
--------------------------------------------------------------------------------
//- @A defines/binding AbsvarA
//- @B defines/binding NestedAbs
//- @C defines/binding TemplateC
template <template <typename A> class B> class C;
//- TemplateC param.0 NestedAbs
//- NestedAbs.node/kind abs
//- NestedAbsvar childof NestedAbs
//- NestedAbs param.0 AbsvarA
--------------------------------------------------------------------------------

Special values for dependent lookups
^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^

Sometimes, the indexer must synthesize a <<lookup>> node to a constructor or
destructor without knowing the name of the type being constructed or destroyed.
In this case, the constructor (or destructor) is named `#ctor` (or `#dtor`):

[kythe,C++,"Dependent ctors and dtors"]
--------------------------------------------------------------------------------
//- @T defines/binding TyvarT
template <typename T>
class C : T {
  //- @"T()" ref/call LookupTCtor
  //- LookupTCtor.node/kind lookup
  //- LookupTCtor param.0 TyvarT
  //- LookupTCtor.text "#ctor"
  C() : T() { }

  T *t;
  //- @"delete t" ref/call LookupTDtor
  //- LookupTDtor.node/kind lookup
  //- LookupTDtor param.0 TyvarT
  //- LookupTDtor.text "#dtor"
  void f() { delete t; }
};
--------------------------------------------------------------------------------

Go
~~

The source language for Go is spelled "`go`".

Java
~~~~

Java's source language is spelled "`java`".

Builtin types
^^^^^^^^^^^^^

Java supplies the following <<tbuiltin>> nodes by default:

[kythe,Java,"Builtin type nodes"]
--------------------------------------------------------------------------------
public class E {
  //- @f defines/binding F
  //- F typed FnType
  //- FnType.node/kind tapp
  //- FnType param.0 FnBuiltin = vname("fn#builtin","","","","java")
  //- FnType param.1 VoidBuiltin = vname("void#builtin","","","","java")
  public static void f(
    //- FnType param.2 BooleanBuiltin = vname("boolean#builtin","","","","java")
    boolean bool,
    //- FnType param.3 ByteBuiltin = vname("byte#builtin","","","","java")
    byte b,
    //- FnType param.4 ShortBuiltin = vname("short#builtin","","","","java")
    short s,
    //- FnType param.5 IntBuiltin = vname("int#builtin","","","","java")
    int i,
    //- FnType param.6 LongBuiltin = vname("long#builtin","","","","java")
    long l,
    //- FnType param.7 CharBuiltin = vname("char#builtin","","","","java")
    char c,
    //- FnType param.8 FloatBuiltin = vname("float#builtin","","","","java")
    float f,
    //- FnType param.9 DoubleBuiltin = vname("double#builtin","","","","java")
    double d,
    //- FnType param.10 StrArray
    //- StrArray.node/kind tapp
    //- StrArray param.0 ArrayBuiltin = vname("array#builtin","","","","java")
    //- StrArray param.1 String
    String[] arry) {}
}
--------------------------------------------------------------------------------


Node Subkinds
^^^^^^^^^^^^^

Classes and Enums
+++++++++++++++++

In Java, classes are [[record]] nodes with a subkind of 'class'.  Likewise, enum
classes are [[sum]] nodes with a subkind of 'enumClass'.

[kythe,Java,"Classes and enums"]
--------------------------------------------------------------------------------
//- @E defines/binding EClass
//- EClass.node/kind record
//- EClass.subkind class
public class E {

  //- @Enum defines/binding Enum
  //- Enum.node/kind sum
  //- Enum.subkind enumClass
  static enum Enum {}
}
--------------------------------------------------------------------------------

Functions
+++++++++

All methods are [[function]] nodes, including class constructors.  To
differentiate between constructors and other methods, [[function]] nodes for
constructors have the subkind 'constructor'.

[kythe,Java,"Methods and constructors"]
--------------------------------------------------------------------------------
public class E {

  //- @E defines/binding ECtor
  //- ECtor.node/kind function
  //- ECtor.subkind constructor
  public E() {}

  //- @staticMethod defines/binding StaticMethod
  //- StaticMethod.node/kind function
  public static void staticMethod() {}

  //- @instanceMethod defines/binding InstanceMethod
  //- InstanceMethod.node/kind function
  public void instanceMethod() {}
}
--------------------------------------------------------------------------------

Variables
+++++++++

Java has 5 types of [[variable]] nodes, each with a distinct subkind:

Fields:: 'field' subkind
Locals:: 'local' subkind
Exception Variables (see http://docs.oracle.com/javase/tutorial/essential/exceptions/catch.html[catch blocks]):: 'local/exception' subkind
Parameters:: 'local/parameter' subkind
Resource Variables (see the http://docs.oracle.com/javase/tutorial/essential/exceptions/tryResourceClose.html[try-with-resources statement]):: 'local/resource' subkind

[kythe,Java,"Variables"]
--------------------------------------------------------------------------------
import java.io.IOException;
import java.io.OutputStream;

public class E {

  //- @field defines/binding Field
  //- Field.node/kind variable
  //- Field.subkind field
  private final Object field = null;

  //- @param defines/binding Parmeter
  //- Parameter.node/kind variable
  //- Parameter.subkind local/parameter
  public static void m(String param) throws IOException {

    //- @local defines/binding Local
    //- Local.node/kind variable
    //- Local.subkind local
    int local = 42;

    //- @resource defines/binding ResourceVar
    //- ResourceVar.node/kind variable
    //- ResourceVar.subkind local/resource
    try (OutputStream resource = System.out) {
      resource.write("hello");

      //- @exception defines/binding ExceptionVar
      //- ExceptionVar.node/kind variable
      //- ExceptionVar.subkind local/exception
    } catch (IOException exception) {}
  }
}
--------------------------------------------------------------------------------

Protocol Buffers
~~~~~~~~~~~~~~~~

The source language for Protocol Buffers is spelled `"protobuf"`.

Common Lisp
~~~~~~~~~~~

The source language for Common Lisp is spelled "`lisp`".
